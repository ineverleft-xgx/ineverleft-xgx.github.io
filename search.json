[{"title":"差分","path":"/2024/09/30/莫队/","content":"莫队基础莫队适用范围：已知 $[l,r]$ 的答案，可以 $O(1)$ 的得出 $[l-1,r], [l,r-1], [l+1,r], [l,r+1]$ 的答案，时间复杂度 $O(n \\sqrt n)$ 例题：P1972 [SDOI2009] HH的项链 方法： 离线处理，将数组分块，将询问左端点按块的编号排序，右端点按编号排序，每次处理询问类似双指针暴力从上一个询问区间转移到下一个询问区间，单次复杂度 $O(\\sqrt n)$ ，总复杂度 $O(m\\sqrt n)$ 优化：排序时偶数块右端点从小到大排序，奇数块右端点从大到小排序 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;using namespace std;const int N=50005,M=2e5+5,S=1e6+5;int n,m,len;int w[N],ans[M];int get(int x)&#123; return x/len;&#125;struct Query&#123; int id,l,r; friend bool operator&lt;(const Query a,const Query b)&#123; int i=get(a.l),j=get(b.l); if(i!=j)return i&lt;j; if(i&amp;1)return a.r&gt;b.r; return a.r&lt;b.r; &#125;&#125;q[M];int cnt[S];void add(int x,int &amp;res)&#123; if(!cnt[x])res++; cnt[x]++;&#125;void del(int x,int &amp;res)&#123; cnt[x]--; if(!cnt[x])res--;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cin &gt;&gt; n; for(int i=1;i&lt;=n;i++)&#123; cin &gt;&gt; w[i]; &#125; cin &gt;&gt; m; len=max(1.0,sqrt((double)n*n/m)); for(int i=1;i&lt;=m;i++)&#123; int l,r; cin &gt;&gt; l &gt;&gt; r; q[i]=&#123;i,l,r&#125;; &#125; sort(q+1,q+m+1); for(int k=1,i=1,j=0,res=0;k&lt;=m;k++)&#123; int id=q[k].id,l=q[k].l,r=q[k].r; while(i&lt;l)del(w[i++],res); while(i&gt;l)add(w[--i],res); while(j&lt;r)add(w[++j],res); while(j&gt;r)del(w[j--],res); ans[id]=res; &#125; for(int i=1;i&lt;=m;i++)&#123; cout &lt;&lt; ans[i] &lt;&lt; &#x27; &#x27;; &#125; return 0;&#125; 带修改的莫队有修改的基础莫队 例题：P1903 [国家集训队] 数颜色 &#x2F; 维护队列 分析： 新增一维 t 表示这次询问查询的是第 t 次修改之后的值，这样每次 t+1&#x2F;t-1 都可以 $O(1)$ 完成（具体实现见代码）。 排序时先按左端点所在块编号，然后按右端点所在块编号，然后按 t 排序 。 理论块长 $^3\\sqrt{nt}$ ，实际 $^3\\sqrt {n^2}$ 也可以。 修改t时有一点小优化，具体细节见代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;bits/stdc++.h&gt;using namespace std;const int N=2e5+5,S=1e6+5;int n,m,len;int w[N],ans[N];int get(int x)&#123; return x/len;&#125;struct Query&#123; int id,l,r,t; friend bool operator&lt;(const Query a,const Query b)&#123; int al=get(a.l),ar=get(a.r); int bl=get(b.l),br=get(b.r); if(al!=bl)return al&lt;bl; if(ar!=br)return ar&lt;br; return a.t&lt;b.t; &#125;&#125;q[N];struct Modify&#123; int p,c;&#125;c[N];int cnt[S],mq,mc;void add(int x,int &amp;res)&#123; if(!cnt[x])res++; cnt[x]++;&#125;void del(int x,int &amp;res)&#123; cnt[x]--; if(!cnt[x])res--;&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++)&#123; scanf(&quot;%d&quot;,&amp;w[i]); &#125; for(int i=1;i&lt;=m;i++)&#123; char opt[2]; scanf(&quot;%s&quot;,opt); if(opt[0]==&#x27;Q&#x27;)&#123; int l,r; scanf(&quot;%d%d&quot;,&amp;l,&amp;r); q[++mq]=&#123;mq,l,r,mc&#125;; &#125; else&#123; int x,k; scanf(&quot;%d%d&quot;,&amp;x,&amp;k); c[++mc]=&#123;x,k&#125;; &#125; &#125; len=max(1.0,pow(1.0*n*n,1.0/3)); sort(q+1,q+mq+1); for(int k=1,t=0,i=1,j=0,res=0;k&lt;=mq;k++)&#123; int id=q[k].id,tm=q[k].t,l=q[k].l,r=q[k].r; while(i&lt;l)del(w[i++],res); while(i&gt;l)add(w[--i],res); while(j&lt;r)add(w[++j],res); while(j&gt;r)del(w[j--],res); while(t&gt;tm)&#123; if(c[t].p&gt;=i&amp;&amp;c[t].p&lt;=j)&#123; del(w[c[t].p],res); add(c[t].c,res); &#125; swap(w[c[t].p],c[t].c); t--; &#125; while(t&lt;tm)&#123; t++; if(c[t].p&gt;=i&amp;&amp;c[t].p&lt;=j)&#123; del(w[c[t].p],res); add(c[t].c,res); &#125; swap(w[c[t].p],c[t].c); &#125; ans[id]=res; &#125; for(int i=1;i&lt;=mq;i++)&#123; printf(&quot;%d &quot;,ans[i]); &#125; return 0;&#125; 回滚莫队当基础莫队删除&#x2F;插入（以下以删除为例，插入同理）操作难以 $O(1)$ 实现（如取 max）时，使用回滚莫队。 AT_joisc2014_c 歴史の研究 分析： 由于删除难以实现，因此只操作增加 把操作先按左端点块编号排序，然后按右端点排序，接下来从左到右计算每个块的答案。 当左右端点都在这个块中时，由于块长为 $\\sqrt n$ ，因此暴力即可。 当左端点在块中，右端点在右侧的其他块时，由于右端点一定是单调的，因此从当前询问转移到下一个询问时右端点一定只有增加操作，因此每次处理询问后删除所有增加的左端点（即先增加右端点，然后记录当前答案，增加完左端点后恢复答案和 cnt 数组） 注意清空 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N=1e5+5;int n,m,len;int w[N],cnt[N];ll ans[N];int get(int x)&#123; return x/len;&#125;struct Query&#123; int id,l,r; friend bool operator&lt;(const Query a,const Query b)&#123; int i=get(a.l),j=get(b.l); if(i!=j)return i&lt;j; return a.r&lt;b.r; &#125;&#125;q[N];vector&lt;int&gt;nums;void add(int x,ll &amp;res)&#123; cnt[x]++; res=max(res,1ll*cnt[x]*nums[x]);&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cin &gt;&gt; n &gt;&gt; m; len=max(1.0,sqrt(n)); for(int i=1;i&lt;=n;i++)&#123; cin &gt;&gt; w[i]; nums.push_back(w[i]); &#125; sort(nums.begin(),nums.end()); nums.erase(unique(nums.begin(),nums.end()),nums.end()); for(int i=1;i&lt;=n;i++)&#123; w[i]=lower_bound(nums.begin(),nums.end(),w[i])-nums.begin(); &#125; for(int i=1;i&lt;=m;i++)&#123; int l,r; cin &gt;&gt; l &gt;&gt; r; q[i]=&#123;i,l,r&#125;; &#125; sort(q+1,q+m+1); for(int x=1;x&lt;=m;)&#123; int y=x; while(y&lt;=m&amp;&amp;get(q[y].l)==get(q[x].l))y++; int right=get(q[x].l)*len+len-1; //求块内的询问——暴力 while(x&lt;y&amp;&amp;q[x].r&lt;=right)&#123; ll res=0; int id=q[x].id,l=q[x].l,r=q[x].r; for(int k=l;k&lt;=r;k++)add(w[k],res); ans[id]=res; for(int k=l;k&lt;=r;k++)cnt[w[k]]--; x++; &#125; //求块外的询问——莫队 ll res=0; int i=right+1,j=right; while(x&lt;y)&#123; int id=q[x].id,l=q[x].l,r=q[x].r; while(j&lt;r)add(w[++j],res); ll backup=res; while(i&gt;l)add(w[--i],res); ans[id]=res; while(i&lt;right+1)cnt[w[i++]]--; res=backup;//回滚 x++; &#125; memset(cnt,0,sizeof cnt); &#125; for(int i=1;i&lt;=m;i++)&#123; cout &lt;&lt; ans[i] &lt;&lt; &#x27; &#x27;; &#125; return 0;&#125; 树上莫队首先考虑如何把树上问题转化成序列问题。 首先求出树的欧拉序（即 根+子树+根），然后不难发现以下规律： 记 $first[u]$ 为 $u$ 在欧拉序中第一次出现的位置，$last[u]$ 为 $u$ 在欧拉序中最后一次出现的位置，则对于两个点 $x,y$ 满足 $first[x]&lt;first[y]$ ，则 若 $lca(x,y)&#x3D;x$，则 $x$ 到 $y$ 的路径为欧拉序中 $[first[x],first[y]]$ 中只出现一次的点 若 $lca(x,y) ot &#x3D; x$，则 $x$ 到 $y$ 的路径为欧拉序中 $[last[x],first[y]]$ 中只出现一次的点和 $lca(x,y)$ 这样就把树上问题转化为了序列问题。 例题：AcWing 2534 树上计数2&#x2F;SP10707 COT2 - Count on a tree II 处理序列时使用一个数组 $st$ ，每次增加&#x2F;删除一个点 $x$ 时将 $st[x] \\oplus 1$ ，若 $st[x]&#x3D;0$，则表示出现了 0 或 2 次，删去，否则表示出现了 1 次，加入。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include&lt;bits/stdc++.h&gt;using namespace std;const int N=1e5+5;int n,m;int len;int w[N],ans[N],cnt[N];int euler[N],idx,first[N],last[N];bool st[N];int get(int x)&#123; return x/len;&#125;struct Query&#123; int id,l,r; friend bool operator&lt;(const Query x,const Query y)&#123; int i=get(x.l),j=get(y.l); if(i!=j)return i&lt;j; if(i&amp;1)return x.r&gt;y.r; return x.r&lt;y.r; &#125;&#125;q[N];vector&lt;int&gt;to[N];int fa[N][30],d[N];void dfs(int u,int f)&#123; d[u]=d[f]+1; fa[u][0]=f; euler[++idx]=u; first[u]=idx; for(auto x:to[u])&#123; if(x!=f)dfs(x,u); &#125; euler[++idx]=u; last[u]=idx;&#125;void init()&#123; for(int k=1;k&lt;30;k++)&#123; for(int i=1;i&lt;=n;i++)&#123; fa[i][k]=fa[fa[i][k-1]][k-1]; &#125; &#125;&#125;int lca(int x,int y)&#123; if(d[x]&lt;d[y])swap(x,y); for(int i=29;i&gt;=0;i--)&#123; if(d[fa[x][i]]&gt;=d[y])x=fa[x][i]; &#125; if(x==y)return x; for(int i=29;i&gt;=0;i--)&#123; if(fa[x][i]!=fa[y][i])x=fa[x][i],y=fa[y][i]; &#125; return fa[x][0];&#125;vector&lt;int&gt;nums;void change(int x,int &amp;res)&#123; st[euler[x]]^=1; if(st[euler[x]])&#123; if(!cnt[w[euler[x]]])res++; cnt[w[euler[x]]]++; &#125; else&#123; cnt[w[euler[x]]]--; if(!cnt[w[euler[x]]])res--; &#125;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cin &gt;&gt; n &gt;&gt; m; for(int i=1;i&lt;=n;i++)&#123; cin &gt;&gt; w[i]; nums.push_back(w[i]); &#125; sort(nums.begin(),nums.end()); nums.erase(unique(nums.begin(),nums.end()),nums.end()); for(int i=1;i&lt;=n;i++)&#123; w[i]=lower_bound(nums.begin(),nums.end(),w[i])-nums.begin(); &#125; for(int i=1;i&lt;n;i++)&#123; int x,y; cin &gt;&gt; x &gt;&gt; y; to[x].push_back(y); to[y].push_back(x); &#125; dfs(1,0); init(); for(int i=1;i&lt;=m;i++)&#123; int l,r; cin &gt;&gt; l &gt;&gt; r; q[i]=&#123;i,first[l],first[r]&#125;; &#125; sort(q+1,q+m+1); for(int k=1,i=1,j=0;k&lt;=m;k++)&#123; int id=q[k].id,l=q[k].l,r=q[k].r,res; while(i&lt;l)change(i++,res); while(i&gt;l)change(--i,res); while(j&lt;r)change(++j,res); while(j&gt;r)change(j--,res); if(lca(euler[l],euler[r])!=euler[l])&#123; change(lca(euler[l],euler[r]),res); ans[id]=res; change(lca(euler[l],euler[r]),res); &#125; else&#123; ans[id]=res; &#125; &#125; for(int i=1;i&lt;=m;i++)&#123; cout &lt;&lt; ans[i] &lt;&lt; &#x27; &#x27;; &#125; return 0;&#125; 二次离线莫队例题：P4887 【模板】莫队二次离线（第十四分块(前体)） 题目大意：给定一个序列，每次询问一个区间内异或和二进制下有 $k$ 个 1 的二元组个数。 分析： 分析操作，主要难点是处理区间的扩展，下面以 $[L,R]$ 扩展到 $[L,R+1]$ 为例分析如何操作。 当增加一个数 $w[R+1]$ 时，就需要求 $[L,R]$ 中有多少个数与这个数配对（即异或和有 $k$ 个1），也就是这个数对 $res$ 的贡献。 记 $S_i$ 表示前 $i$ 个数中与 $w[R+1]$ 配对的数的个数，则这个数的贡献就是 $S_R-S_{L-1}$。 首先考虑如何求 $S_R$ ，记 $f_i$ 表示 $w_1 \\sim w_i$ 中有多少个数与 $w_i+1$ 配对，则 $S_R&#x3D;f_R$。可以递推求 $f_i$，维护一个辅助数组 $g_x$ ，表示前 $i$ 个数中有多少个与 $x$ 配对，则 $f_i&#x3D;x_{w_{i+1}}$ 。 接下来考虑如何求 $S_{L-1}$，可以发现很难直接算出来，因此可以先进行一遍莫队，记录所有要求的 $S_{L-1}$ ，然后离线求出。 其余操作略有不同，但推导过程相同，详见代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;bits/stdc++.h&gt;using namespace std;const int N=1e5+5;typedef long long ll;int n,m,k,len;int w[N];ll ans[N];int get(int x)&#123; return x/len;&#125;struct Query&#123; int id,l,r; ll res; friend bool operator&lt;(const Query &amp;a,const Query &amp;b)&#123; int i=get(a.l),j=get(b.l); if(i!=j)return i&lt;j; return a.r&lt;b.r; &#125;&#125;q[N];struct Range&#123; int id,l,r,t;&#125;;vector&lt;Range&gt;range[N];int f[N],g[N];int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for(int i=1;i&lt;=n;i++)&#123; cin &gt;&gt; w[i]; &#125; vector&lt;int&gt;nums; for(int i=0;i&lt;1&lt;&lt;14;i++)&#123; if(__builtin_popcount(i)==k)&#123; nums.push_back(i); &#125; &#125; for(int i=1;i&lt;=n;i++)&#123; for(auto y:nums)&#123; g[w[i]^y]++; &#125; f[i]=g[w[i+1]]; &#125; for(int i=1;i&lt;=m;i++)&#123; int l,r; cin &gt;&gt; l &gt;&gt; r; q[i]=&#123;i,l,r&#125;; &#125; len=sqrt(n); sort(q+1,q+n+1); for(int i=1,L=1,R=0;i&lt;=m;i++)&#123; int l=q[i].l,r=q[i].r; //S(R)-S(L-1) if(R&lt;r)range[L-1].push_back(&#123;i,R+1,r,-1&#125;); while(R&lt;r)q[i].res+=f[R++]; //-(S(R-1)-S(L-1))=-S(R-1)+S(L-1) if(R&gt;r)range[L-1].push_back(&#123;i,r+1,R,1&#125;); while(R&gt;r)q[i].res-=f[--R]; //-(S(R)-S(L))=-S(R)+S(L)=-S(R)+f(L-1)+!k if(L&lt;l)range[R].push_back(&#123;i,L,l-1,-1&#125;); while(L&lt;l)q[i].res+=f[L-1]+!k,L++; //S(R)-S(L-1)=S(R)-(f(L-2)+!k) if(L&gt;l)range[R].push_back(&#123;i,l,L-1,1&#125;); while(L&gt;l)q[i].res-=f[L-2]+!k,L--; &#125; memset(g,0,sizeof g); for(int i=1;i&lt;=n;i++)&#123; for(auto y:nums)++g[w[i]^y]; for(auto&amp;rg:range[i])&#123; int id=rg.id,l=rg.l,r=rg.r,t=rg.t; for(int x=l;x&lt;=r;x++)&#123; q[id].res+=g[w[x]]*t; &#125; &#125; &#125; for(int i=2;i&lt;=m;i++)&#123; q[i].res+=q[i-1].res; &#125; for(int i=1;i&lt;=m;i++)&#123; ans[q[i].id]=q[i].res; &#125; for(int i=1;i&lt;=m;i++)&#123; cout &lt;&lt; ans[i] &lt;&lt; &#x27; &#x27;; &#125; return 0;&#125;"},{"title":"扩展欧几里得算法","path":"/2024/08/12/扩展欧几里得算法/","content":"扩展欧几里得算法裴蜀定理对于任意正整数 a,b，那么一定存在整数 x,y，使得 ax+by&#x3D;(a,b) 扩展欧几里得首先看欧几里得算法的步骤： 123456int gcd(int a,int b)&#123; if(!b)&#123; return a; &#125; return gcd(b,a%b);&#125; 可以发现，当 b&#x3D;0 时，方程为 $a\\cdot x+0\\cdot y&#x3D;(a,0)&#x3D;a$，不难发现 $(1,0)$，为方程的一组解 接下来考虑其他情况： 首先已经得到了 $a’&#x3D;b，b’&#x3D;a%b$ 的一组解 $(x,y)$，记 $a$,$b$ 的最大公因数为 $d$ ，观察方程:$$b\\cdot x+(a\\bmod b)\\cdot y&#x3D;d$$由于 $a \\bmod b &#x3D; a- \\lfloor \\frac a b \\rfloor \\cdot b$，$$b\\cdot x+(a- \\lfloor \\frac a b \\rfloor \\cdot b)\\cdot y&#x3D;d\\a\\cdot y+ b\\cdot(x-\\lfloor \\frac a b \\rfloor\\cdot y)&#x3D;d$$因此 $a,b$ 的解就是 $(y,x-\\lfloor \\frac a b \\rfloor\\cdot y)$ 为了方便，将 $x,y$ 交换，则答案为 $(x,y-\\lfloor \\frac a b \\rfloor\\cdot x)$ 12345678910int exgcd(int a,int b,int &amp;x,int &amp;y)&#123; if(!b)&#123; x=1,y=0; return a; &#125; int d=exgcd(b,a%b,y,x); y=y-a/b*x; return d;&#125;"},{"title":"数据结构技巧总结","path":"/2024/07/29/数据结构技巧总结/","content":"P4513 小白逛公园 线段树求连续区间问题可以在每个点上增加 mx，mxl，mxr，分别表示当前区间的最大值，包含左端点的最大值和包含右端点的最大值"},{"title":"图论技巧总结","path":"/2024/07/27/图论技巧总结/","content":"floyd ： 1234567for(int k=1;k&lt;=n;k++)&#123; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; d[i][j]=min(d[i][j],d[i][k]+d[k][j]); &#125; &#125;&#125; 当枚举到 k 时，d[i][j] 表示只经过 1~k 的 i 到 j 的最短路径 同余最短路 P3403"},{"title":"高精度","path":"/2024/07/25/高精度/","content":"高精度存储方式：数组（可用vector，自带size函数），由低位向高位存各位数字 运算方式：模拟 高精度加法例：$123+89$ 0 1 2 3 A 3 2 1 0 B 9 8 0 0 C 2 1 2 0 思路： 输入两个字符串，并转化成vector 循环至两数的最高位，每次判断两个数是否有第$i$位，若有，$t$加上第$i$位，和的第$i$位$&#x3D;t %10，t&#x2F;&#x3D;10$ 循环完后判断$t$是否为$0$，若不为零，则进位 代码实现： 123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;string a,b;vector&lt;int&gt;A,B;vector&lt;int&gt; add(vector&lt;int&gt; &amp;x,vector&lt;int&gt; &amp;y)&#123; vector&lt;int&gt;s; int t=0; for(int i=0;i&lt;x.size()||i&lt;y.size();i++)&#123; if(i&lt;x.size())t+=x[i]; if(i&lt;y.size())t+=y[i]; s.push_back(t%10); t/=10; &#125; if(t)s.push_back(t); return s;&#125;int main()&#123; cin &gt;&gt; a &gt;&gt; b; for(int i=a.length()-1;i&gt;=0;i--)&#123; A.push_back(a[i]-&#x27;0&#x27;); &#125; for(int i=b.length()-1;i&gt;=0;i--)&#123; B.push_back(b[i]-&#x27;0&#x27;); &#125; auto C=add(A,B); for(int i=C.size()-1;i&gt;=0;i--)&#123; cout &lt;&lt; C[i]; &#125; return 0;&#125; 高精度减法 判断$A,B$的大小 当长度不同时，长度越短，大小越小 当长度相同时，从高位循环到低位，若当前位不同，则当前位小的数小 循环到最高位，首先$t&#x3D;A[i]-t$(减去借位),然后如果$B$有第$i$位，$t$减去$B[i]$，当前位等于$(t+10)%10$（防止负数）,若$t$为负数，则$t&#x3D;1$(借位标记)，否则$t&#x3D;0$ 循环结束去掉前导$0$ 从最高位开始循环直到$size()&#x3D;&#x3D;1$（结果为$0$时保留），若当前位是0($C.back()&#x3D;&#x3D;0$),则删除当前位($C.pop_back()$),若当前位不为零，则跳出循环 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;using namespace std;string a,b;vector&lt;int&gt;A,B;bool operator&lt;(vector&lt;int&gt;x,vector&lt;int&gt;y)&#123; if(x.size()==y.size())&#123; for(int i=x.size()-1;i&gt;=0;i--)&#123; if(x[i]!=y[i])return x[i]&lt;y[i]; &#125; return 0; &#125; return x.size()&lt;y.size();&#125;vector&lt;int&gt; sub(vector&lt;int&gt; &amp;x,vector&lt;int&gt; &amp;y)&#123; vector&lt;int&gt;s; int t=0; for(int i=0;i&lt;x.size();i++)&#123; t=x[i]-t; if(i&lt;y.size())t-=y[i]; s.push_back((t+10)%10); if(t&lt;0)t=1; else t=0; &#125; while(s.size()&gt;1&amp;&amp;s.back()==0)&#123; s.pop_back(); &#125; return s;&#125;int main()&#123; cin &gt;&gt; a &gt;&gt; b; for(int i=a.length()-1;i&gt;=0;i--)&#123; A.push_back(a[i]-&#x27;0&#x27;); &#125; for(int i=b.length()-1;i&gt;=0;i--)&#123; B.push_back(b[i]-&#x27;0&#x27;); &#125; vector&lt;int&gt;C; bool flag=0; if(A&lt;B)&#123; C=sub(B,A); cout &lt;&lt; &#x27;-&#x27;; &#125; else&#123; C=sub(A,B); &#125; for(int i=C.size()-1;i&gt;=0;i--)&#123; cout &lt;&lt; C[i]; &#125; return 0;&#125; 高精度乘法 双重循环，$C[i+j]&#x3D;A[i]*B[j]$,处理进位 循环结束去掉前导$0$ 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;using namespace std;string a,b;vector&lt;int&gt;A,B;vector&lt;int&gt; mul(vector&lt;int&gt; &amp;x,vector&lt;int&gt; &amp;y)&#123;\tvector&lt;int&gt;s;\tfor(int i=0;i&lt;y.size();i++)&#123; for(int j=0;j&lt;x.size();j++)&#123; if(j+i&lt;s.size())&#123; s[j+i]+=x[j]*y[i]; &#125; else&#123; s.push_back(x[j]*y[i]); &#125; if(s[j+i]&gt;9)&#123; if(j+i+1&lt;s.size())&#123; s[j+i+1]+=s[j+i]/10; s[j+i]%=10; &#125; else&#123; s.push_back(s[j+i]/10); s[j+i]%=10; &#125; &#125; &#125;\t&#125;\twhile(s.size()&gt;1&amp;&amp;s.back()==0)&#123; s.pop_back();\t&#125;\treturn s;&#125;int main()&#123;\tcin &gt;&gt; a &gt;&gt; b;\tfor(int i=a.length()-1;i&gt;=0;i--)&#123; A.push_back(a[i]-&#x27;0&#x27;);\t&#125;\tfor(int i=b.length()-1;i&gt;=0;i--)&#123; B.push_back(b[i]-&#x27;0&#x27;);\t&#125;\tauto C=mul(A,B);\tfor(int i=C.size()-1;i&gt;=0;i--)&#123; cout &lt;&lt; C[i];\t&#125;\treturn 0;&#125; 高精度除法 输入高精度数$A$和长整型数$b$ 初始$r&#x3D;0$，从高位向低位循环，每次$r&#x3D;r*10+A[i]$,则答案的第$i$位为$r&#x2F;b$，$r&#x3D;r%b$ 结束后答案数组是由高位向低位存储，所以翻转数组（$reserve(C.begin(),C.end())$） 去掉前导$0$ $r$即为余数(传入$r$时用$&amp;r$，可以实时改变$r$的真实值) 代码实现： 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;string a;long long b;vector&lt;int&gt;A;vector&lt;int&gt; div(vector&lt;int&gt; &amp;x,long long y,long long &amp;r)&#123; vector&lt;int&gt;s; r=0; for(int i=A.size()-1;i&gt;=0;i--)&#123; r=r*10+A[i]; s.push_back(r/y); r%=y; &#125; reverse(s.begin(),s.end()); while(s.size()&gt;1&amp;&amp;s.back()==0)&#123; s.pop_back(); &#125; return s;&#125;int main()&#123;\tcin &gt;&gt; a &gt;&gt; b;\tfor(int i=a.length()-1;i&gt;=0;i--)&#123; A.push_back(a[i]-&#x27;0&#x27;);\t&#125;\tlong long r;\tauto C=div(A,b,r);\tfor(int i=C.size()-1;i&gt;=0;i--)&#123; cout &lt;&lt; C[i];\t&#125; cout &lt;&lt; endl &lt;&lt; r;//余数\treturn 0;&#125; 高精度模板： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt; change(string s)&#123;//字符串转vector数组 vector&lt;int&gt;to; for(int i=s.length()-1;i&gt;=0;i--)&#123; to.push_back(s[i]-&#x27;0&#x27;); &#125; return to;&#125;vector&lt;int&gt; add(vector&lt;int&gt; &amp;x,vector&lt;int&gt; &amp;y)&#123;//加法 vector&lt;int&gt;s; int t=0; for(int i=0;i&lt;x.size()||i&lt;y.size();i++)&#123; if(i&lt;x.size())t+=x[i]; if(i&lt;y.size())t+=y[i]; s.push_back(t%10); t/=10; &#125; if(t)s.push_back(t); return s;&#125;bool operator&lt;(vector&lt;int&gt;x,vector&lt;int&gt;y)&#123; if(x.size()==y.size())&#123; for(int i=x.size()-1;i&gt;=0;i--)&#123; if(x[i]!=y[i])return x[i]&lt;y[i]; &#125; return 0; &#125; return x.size()&lt;y.size();&#125;vector&lt;int&gt; sub(vector&lt;int&gt; &amp;x,vector&lt;int&gt; &amp;y)&#123;//减法 vector&lt;int&gt;s; int t=0; for(int i=0;i&lt;x.size();i++)&#123; t=x[i]-t; if(i&lt;y.size())t-=y[i]; s.push_back((t+10)%10); if(t&lt;0)t=1; else t=0; &#125; while(s.size()&gt;1&amp;&amp;s.back()==0)&#123; s.pop_back(); &#125; return s;&#125;vector&lt;int&gt; mul(vector&lt;int&gt; &amp;x,vector&lt;int&gt; &amp;y)&#123;//乘法\tvector&lt;int&gt;s;\tfor(int i=0;i&lt;y.size();i++)&#123; for(int j=0;j&lt;x.size();j++)&#123; if(j+i&lt;s.size())&#123; s[j+i]+=x[j]*y[i]; &#125; else&#123; s.push_back(x[j]*y[i]); &#125; if(s[j+i]&gt;9)&#123; if(j+i+1&lt;s.size())&#123; s[j+i+1]+=s[j+i]/10; s[j+i]%=10; &#125; else&#123; s.push_back(s[j+i]/10); s[j+i]%=10; &#125; &#125; &#125;\t&#125;\twhile(s.size()&gt;1&amp;&amp;s.back()==0)&#123; s.pop_back();\t&#125;\treturn s;&#125;vector&lt;int&gt; div(vector&lt;int&gt; &amp;x,long long y,long long &amp;r)&#123;//除法 vector&lt;int&gt;s; r=0; for(int i=x.size()-1;i&gt;=0;i--)&#123; r=r*10+x[i]; s.push_back(r/y); r%=y; &#125; reverse(s.begin(),s.end()); while(s.size()&gt;1&amp;&amp;s.back()==0)&#123; s.pop_back(); &#125; return s;&#125;int main()&#123; return 0;&#125;"},{"title":"高斯消元","path":"/2024/07/25/高斯消元/","content":"高斯消元在$O(n^3)$的复杂度下求解形如：$$\\left{\\begin{matrix} a_{1,1}x_1+a_{1,2}x_2+\\cdots+a_{1,n}x_n&#x3D;b_1\\ a_{2,1}x_1+a_{2,2}x_2+\\cdots+a_{2,n}x_n&#x3D;b_2\\ \\cdots\\ a_{n,1}x_1+a_{n,2}x_2+\\cdots+a_{n,n}x_n&#x3D;b_n\\\\end{matrix}\\right.$$的线性方程组的解。 步骤： 枚举每一列c 找到绝对值最大的一行 将改行换到最上面 将该行的第一个数变成1 将下面所有行的第c列消成0 模板题 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;bits/stdc++.h&gt;using namespace std;const int N=105;const double eps=1e-6;int n;double a[N][N];int gauss()&#123; int c,r; for(c=0,r=0;c&lt;n;c++)&#123; int t=r; for(int i=r;i&lt;n;i++)&#123; if(fabs(a[i][c])&gt;fabs(a[t][c]))&#123; t=i; &#125; &#125; if(fabs(a[t][c])&lt;eps)continue; for(int i=c;i&lt;=n;i++)&#123; swap(a[t][i],a[r][i]); &#125; for(int i=n;i&gt;=c;i--)&#123; a[r][i]/=a[r][c]; &#125; for(int i=r+1;i&lt;n;i++)&#123; if(fabs(a[i][c])&gt;eps)&#123; for(int j=n;j&gt;=c;j--)&#123; a[i][j]-=a[r][j]*a[i][c]; &#125; &#125; &#125; r++; &#125; if(r&lt;n)&#123; for(int i=r;i&lt;n;i++)&#123; if(fabs(a[i][n])&gt;eps)&#123; return 2; &#125; &#125; return 1; &#125; for(int i=n-1;i&gt;=0;i--)&#123; for(int j=i+1;j&lt;n;j++)&#123; a[i][n]-=a[i][j]*a[j][n]; &#125; &#125; return 0;&#125;int main()&#123; cin &gt;&gt; n; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;n+1;j++)&#123; cin &gt;&gt; a[i][j]; &#125; &#125; int t=gauss(); if(t==0)&#123; for(int i=0;i&lt;n;i++)&#123; cout &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; a[i][n] &lt;&lt; endl; &#125; &#125; else&#123; cout &lt;&lt; &quot;No Solution &quot;; &#125; return 0;&#125;"},{"title":"队列和栈","path":"/2024/07/25/队列和栈/","content":"队列和栈栈定义：后进先出 存储： 1int stk[N],tt;//stk存储栈的元素，tt存储栈顶位置 插入： 1stk[++tt]=x; 删除： 1t--; 判断栈是否为空： 123bool empty()&#123; return !tt;&#125; 栈顶元素： 1stk[tt]; 元素个数： 1tt 队列定义：先进先出 存储： 1int que[N],hh,tt=-1;//que存储队列,hh表示队头位置，tt表示队尾位置 插入： 1que[++tt]=x; 删除: 1hh++; 判断栈是否为空： 123bool empty()&#123; return hh&gt;tt;&#125; 队首元素： 1que[hh]; 队尾元素： 1que[tt]; 队列大小： 1tt-hh+1;"},{"title":"链表","path":"/2024/07/25/链表/","content":"链表单链表作用：存储图和树 存储： 12int head,ne[N],e[N];int cnt; 插入(头节点): 12345void insert_h(int x)&#123; e[++cnt]=x; ne[cnt]=head; head=cnt;&#125; 插入(第$k$个插入的数后): 12345void insert(int k,int x)&#123; e[++cnt]=x; ne[cnt]=ne[k]; ne[k]=cnt;&#125; 删除(第$k$个插入的数的后一个数): 12345678void del(int k)&#123; if(k==0)&#123; head=ne[head]; &#125; else&#123; ne[k]=ne[ne[k]]; &#125;&#125; 如果需要查找元素的位置，可以用一个数组$plc$,在插入时记录每个数的$cnt$即可 双链表作用：优化某些问题 存储： 12int head,tail,l[N],r[N],e[N];int cnt; 插入（头节点）: 12345678void insert_head(int x)&#123; e[++cnt]=x; l[cnt]=0; l[head]=cnt; r[cnt]=head; head=cnt; if(!tail)tail=cnt;&#125; 插入（尾节点）： 12345678void insert_tail(int x)&#123; e[++cnt]=x; l[cnt]=tail; r[tail]=cnt; r[cnt]=0; if(!head)head=cnt; tail=cnt;&#125; 插入（第$k$个数左）： 123456789101112131415void insert_l(int k,int x)&#123; e[++cnt]=x; if(head==k)&#123; l[k]=cnt; head=cnt; l[cnt]=0; r[cnt]=k; &#125; else&#123; r[l[k]]=cnt; l[cnt]=l[k]; l[k]=cnt; r[cnt]=k; &#125;&#125; 插入（第$k$个数右）： 123456789101112131415void insert_r(int k,int x)&#123; e[++cnt]=x; if(tail==k)&#123; r[k]=cnt; tail=cnt; l[cnt]=k; r[cnt]=0; &#125; else&#123; l[r[k]]=cnt; r[cnt]=r[k]; r[k]=cnt; l[cnt]=k; &#125;&#125; 删除（第$k$个插入的数）: 1234567891011121314151617void del(int k)&#123; if(tail==k&amp;&amp;head==k)&#123; tail=0,head=0; &#125; else if(head==k)&#123; head=r[k]; l[r[k]]=0; &#125; else if(tail==k)&#123; tail=l[k]; r[l[k]]=0; &#125; else&#123; r[l[k]]=r[k]; l[r[k]]=l[k]; &#125;&#125;"},{"title":"质数","path":"/2024/07/25/质数/","content":"质数定义：在大于一的整数中，如果只包含1和它本身两个约数，则被称为质数，也叫素数 质数的判定——试除法若$n$小于2，则不是质数 从2开始，一直判定到$n-1$，若均无法整除，则为质数 1234567bool isprime(int x)&#123; if(x&lt;2)return 0; for(int i=2;i&lt;x;i++)&#123; if(x%i==0)return 0; &#125; return 1;&#125; 优化：可以发现，约数是成对出现的，所以只用循环到$\\sqrt{n}$即可 12345678bool isprime(int x)&#123; if(x&lt;2)return 0; int t=sqrt(x); for(int i=2;i&lt;=t;i++)&#123; if(x%i==0)return 0; &#125; return 1;&#125; 分解质因数——试除法从小到大枚举$n$的约数，若整除，则为约数，此时求其次数 123456789101112void divide(int x)&#123; for(int i=2;i&lt;=x;i++)&#123; if(x%i==0)&#123; int s=0; while(x%i==0)&#123; x/=i; s++; &#125; cout &lt;&lt; i &lt;&lt; &#x27; &#x27; &lt;&lt; s &lt;&lt; endl; &#125; &#125;&#125; 考虑优化： 由于$n$中最多只包含一个大于$\\sqrt{n}$的质因子，所以只需枚举到$n&#x2F;i$，最后会剩余一个数，若这个数大于$n$，则此数为大于$\\sqrt{n}$d的那个素因子，单独判断即可 123456789101112131415void divide(int x)&#123; for(int i=2;i&lt;=x/i;i++)&#123; if(x%i==0)&#123; int s=0; while(x%i==0)&#123; x/=i; s++; &#125; cout &lt;&lt; i &lt;&lt; &#x27; &#x27; &lt;&lt; s &lt;&lt; endl; &#125; &#125; if(x&gt;1)&#123; cout &lt;&lt; x &lt;&lt; &#x27; &#x27; &lt;&lt; 1 &lt;&lt; endl; &#125;&#125; 质数筛法朴素筛法每次循环每个数的倍数筛去 12345678910bool st[N];int prime[N],cnt;void getprime(int n)&#123; for(int i=2;i&lt;=n;i++)&#123; if(!st[i])prime[++cnt]=i; for(int j=i*2;j&lt;=n;j+=i)&#123; st[j]=1; &#125; &#125;&#125; 复杂度$O(\\log n)$ 埃氏筛每次筛时只筛素数的倍数 123456789101112bool st[N];int prime[N],cnt;void getprime(int n)&#123; for(int i=2;i&lt;=n;i++)&#123; if(!st[i])&#123; prime[++cnt]=i; for(int j=i*2;j&lt;=n;j+=i)&#123; st[j]=1; &#125; &#125; &#125;&#125; 复杂度$O(n\\log \\log n)$ 线性筛每个数只会被其最小质因子筛掉 循环，每次筛小于$n&#x2F;i$的质数的$i$倍直到$i%prime_j&#x3D;0$ 每次筛数时： 若$i%prime_j&#x3D;0$，则$prime_j$一定是$i$的最小质因子，$prime_j$也一定是$prime_j*i$的最小质因子 若$i%prime_j ot &#x3D; 0$,，则$prime_j$一定小于$i$的所有质因子，$prime_j$也一定是$prime_j*i$的最小质因子 对于一个合数$x$,假设$prime_j$是$x$的最小质因子，当$i$枚举到$x&#x2F;prime_j$时，一定会被筛掉 1234567891011bool st[N];int prime[N],cnt;void getprime(int n)&#123; for(int i=2;i&lt;=n;i++)&#123; if(!st[i])prime[++cnt]=i; for(int j=1;prime[j]&lt;=n/i;j++)&#123; st[prime[j]*i]=1; if(i%prime[j]==0)break; &#125; &#125;&#125; 复杂度$O(n)$"},{"title":"计算几何","path":"/2024/07/25/计算几何/","content":"计算几何前置知识点 $\\pi&#x3D;\\arccos (-1)$ $\\cos(\\pi)&#x3D;-1,\\arccos (\\cos(\\pi))&#x3D;\\arccos(-1)&#x3D;\\pi$ 余弦定理 $c^2&#x3D;a^2+b^2-2ab\\cos C$ 正弦定理 $\\frac a {\\sin A} &#x3D;\\frac b {\\sin B}&#x3D;\\frac c {sinC}$ 浮点数的比较1234567891011const double eps=1e-8;//精度int sign(double x)&#123; if(fabs(x)&lt;eps)return 0;//等于0 if(x&lt;0)return -1;//小于0 return 1;//大于0&#125;int cmp(double x,double y)&#123; if(fabs(x-y)&lt;eps)return 0;//x=y if(x&lt;y)return -1;//x&lt;y return 1;//x&gt;y&#125; 向量设 $\\vec {A}&#x3D;(x_1,y_1),\\vec{B}&#x3D;(x_2,y_2)$ 向量的加减法与数乘运算$\\vec{A}+\\vec{B}&#x3D;(x_1+x_2,y_1+y_2)$ $\\vec{A}-\\vec{B}&#x3D;(x_1-x_2,y_1-y_2)$ $\\lambda \\vec A&#x3D;(\\lambda x_1,\\lambda y_1)$ 内积（点积）$\\vec A\\cdot \\vec B &#x3D;|\\vec A||\\vec B|\\cos \\theta&#x3D;x_1x_2+y_1y_2$ 几何意义向量 A 在向量 B 上的投影与 向量 B 的长度的乘积 代码实现123double dot(Point a,Point b)&#123; return a.x*b.x+a.y*b.y;&#125; 外积（叉积）$\\vec A\\times \\vec B&#x3D;|\\vec A||\\vec B|\\sin\\theta&#x3D;x_1y_2-x_2y_1$ 几何意义向量 A 与向量 B 张成的平行四边形的有向面积， B 在 A 的逆时针方向为正。 代码实现123double cross(Point a,Point b)&#123; return a.x*b.y-b.x*a.y;&#125; 常用函数取模$|\\vec A|&#x3D;\\sqrt{x^2+y^2}$ 123double get_length(Point a)&#123; return sqrt(dot(a,a));&#125; 计算向量夹角$\\cos \\theta &#x3D;\\frac{\\vec A \\cdot \\vec B}{|\\vec A||\\vec B|}$ $\\theta &#x3D; \\arccos(\\cos \\theta)$ 123double get_angle(Point a,Point b)&#123; return acos(dot(a,b)/get_length(a)/get_length(b));&#125; 计算两个向量构成的平行四边形有向面积123double area(Point a,Point b,Point c)&#123; return cross(b-a,c-a);&#125; 向量 A 顺时针旋转一定角度设 $\\vec A$ 与 x 轴夹角为 $\\alpha$，要顺时针旋转 $\\theta$，设旋转后的向量 $\\vec{A’}&#x3D;(x’,y’)$，则 $x’&#x3D;|\\vec A|\\cos (\\alpha-\\theta)&#x3D;\\sqrt{x^2+y^2}(\\cos \\alpha \\cos \\theta+\\sin \\alpha \\sin \\theta)$ $y’&#x3D;|\\vec A| \\sin(\\alpha-\\theta)&#x3D;\\sqrt{x^2+y^2}(\\sin \\alpha\\cos \\theta-\\cos \\alpha \\sin \\theta)$ 由于 $\\sin \\alpha&#x3D;\\frac y {\\sqrt{x^2+y^2}},\\cos \\alpha &#x3D;\\frac x{\\sqrt{x^2+y^2}}$，所以 $x’&#x3D; \\sqrt{x^2+y^2}(\\frac x{\\sqrt{x^2+y^2}} \\cos \\theta+\\frac y {\\sqrt{x^2+y^2}} \\sin \\theta)&#x3D;x\\cos \\theta+y\\sin \\theta$ $y’&#x3D;\\sqrt{x^2+y^2}(\\frac y {\\sqrt{x^2+y^2}}\\cos \\theta-\\frac x{\\sqrt{x^2+y^2}} \\sin \\theta)&#x3D;y\\cos\\theta-x\\sin\\theta$ 123Point rotate(Point a,double angle)&#123; return Point(a.x*cos(angle)+a.y*sin(angle),-a.x*sin(angle)+a.y*cos(angle));&#125; 点与线直线定理 一般式：$ax+by+c&#x3D;0$ 点向式：$P_0+t\\vec v$ （$p_0$ 是一个点，$\\vec v$ 是一个向量） 斜截式：$y&#x3D;kx+b$ 常用操作判断点在直线上任取直线上的两个点构成的向量 $\\vec A$ 和直线上一个点与需要判断的点构成的一个向量 $\\vec B$，若 $\\vec A \\times \\vec B&#x3D;0$，则点在直线上 两直线相交使用点向式表示两个直线，分别为 $P+t\\vec v,Q+t\\vec w$ 首先判断两直线是否平行或重合 $\\vec v \\times \\vec w&#x3D;0 $ 作出向量 $\\vec {QP}$，即 $P-Q$，记为 $\\vec u$， 连接 $PA$，则 $\\vec u \\times \\vec w &#x3D; 2S_{\\triangle PQA}$，把向量 $\\vec v$ 平移至点 $Q$，记为 $\\vec {v’}$，连接 $AB$，则 $\\vec v \\times \\vec w&#x3D;\\vec {v’} \\times \\vec w&#x3D;2S_{\\triangle AQB}$，所以 $t&#x3D;\\frac{\\vec w \\times \\vec u}{\\vec v \\times \\vec w}&#x3D;\\frac {S_{\\triangle PQA}}{S_{\\triangle AQB}}$ 作 $PC \\bot QA$ 于 $C$ ，$BD \\bot QA$ 于 $D$ ，则$t&#x3D;\\frac {S_{\\triangle PQA}}{S_{\\triangle AQB}}&#x3D;\\frac {PC}{BD}$，易证 $\\triangle PCE \\sim \\triangle BDQ$，相似比为 $\\frac {PC}{BQ}&#x3D;t$ ，所以 $\\frac {PE} {BQ}&#x3D;t,PE&#x3D;t\\vec v$，所以 交点 $E&#x3D;P+t\\vec v$。 12345Point get_line_intersection(Point p,Point v,Point q,Point w)&#123; Point u=p-q; double t=cross(w,u)/cross(v,w); return p+v*t;&#125; 点到直线的距离设直线上两点 $A,B$，直线外一点 $P$，则距离 $d&#x3D;\\frac {2S_{\\triangle PAB}}{AB}&#x3D;\\frac{|\\vec{AP}\\times \\vec {AB}|}{|\\vec {AB}|}$ 1234double distance_to_line(Point p,Point a,Point b)&#123; Point v1=b-a,v2=p-a; return fabs(cross(v1,v2)/get_length(v1));&#125; 点到线段的距离若 $A,B$ 重合，即点到点的距离 记点 $P$ 到线段 $AB$ 所在直线的垂线为点 $H$ 若 $H$ 在 $A$ 的左侧，即 $\\vec{AP} \\cdot \\vec{AB} &lt;0$，则距离为 $PA$ 若 $H$ 在 $B$ 的右侧，即 $\\vec {BP} \\cdot \\vec{BA} &lt;0, \\vec {BP} \\cdot \\vec{AB} &gt;0$，则距离为 $PB$ 否则，距离为 $P$ 到 $AB$ 所在直线的距离。 1234567double distance_to_segment(Point p,Point a,Point b)&#123; if(a==b)return get_length(p-a); Point v1=b-a,v2=p-a,v3=p-b; if(sign(dot(v1,v2))&lt;0)return get_length(v2); if(sign(dot(v1,v3))&gt;0)return get_length(v3); return distance_to_line(p,a,b);&#125; 点在直线上的投影设直线上两点 $A,B$，直线外一点 $P$ ，记向量 $\\vec{AP}$ 在向量 $\\vec{AB}$ 上的投影为 $\\vec{AC}&#x3D;\\frac {\\vec{AB} \\cdot \\vec{AP}}{\\vec{AB}^2} \\vec{AB}$，则 $PC\\bot AB$，所以 $C&#x3D;A+\\frac {\\vec{AB} \\cdot \\vec{AP}}{\\vec{AB}^2} \\vec{AB}$ 即为所求 1234Point get_line_projection(Point p,Point a,Point b)&#123; Point v=b-a; return a+v*(dot(v,p-a)/dot(v,v));&#125; 点是否在线段上设线段 $A,B$，点 $P$，则若 $\\vec{AP}\\cross \\vec{BP}&#x3D;0$，则 $P$ 在直线 $AB$ 上，若 $\\vec {AP} \\cdot \\vec{BP}\\le 0$，即两向量夹角为钝角，则 $P$ 在 $AB$ 之间。 123bool on_segment(Point p,Point a,Point b)&#123; return sign(cross(p-a,p-b))==0&amp;&amp;sign(dot(p-a,p-b))&lt;=0;&#125; 判断两线段是否相交若 $(\\vec {A_1A_2} \\cross \\vec{A_1B_1})(\\vec {A_1A_2} \\cross \\vec{A_1B_2})\\le 0$，则表示 $B_1,B_2$ 在线段 $A_1A_2$ 两侧，同理，若 $A_1,A_2$也在 $B_1B_2$ 两侧，则两线段相交 12345bool segment_intersection(Point a1,Point a2,Point b1,Point b2)&#123; double c1=cross(a2-a1,b1-a1),c2=cross(a2-a1,b2-a1); double c3=cross(b2-b1,a2-b1),c4=cross(b2-b1,a1-b1); return sign(c1)*sign(c2)&lt;=0&amp;&amp;sign(c3)*sign(c4)&lt;=0;&#125; 多边形三角形面积 叉积 $S_{\\triangle ABC}&#x3D;\\frac 1 2\\vec{AB}\\cross \\vec{AC}$ 海伦公式 设 $p&#x3D;\\frac{a+b+c} 2$，则 $S&#x3D;\\sqrt{p(p-a)(p-b)(p-c)}$ 三角形四心 外心，外接圆圆心 三边中垂线交点，到三角形三个顶点的距离相等 内心，内接圆圆心 角平分线交点，到三边距离相等 垂心 三条垂线交点 重心 三条中线交点，到三角形三顶点距离的平方和最小的点，三角形内到三边距离之积最大的点 普通多边形通常按逆时针存储所有点 定义多边形由在同一平面且不在同一直线上的多条线段首尾顺次连接且不相交所组成的图形叫多边形 简单多边形除相邻边外其他边不相交的多边形叫简单多边形 凸多边形过多边形的任意一边做一条直线，如果其他各个顶点都在这条直线的同侧，则把这个多边形叫做凸多边形 任意凸多边形外角和均为 $360\\degree$ 任意凸多边形的内角和为 $(n-2)180\\degree$ 常用函数求多边形面积从第一个顶点把多边形划分为 n-2 个三角形 1234567double polygon_area(Point p[],int n)&#123; double s=0; for(int i=1;i+1&lt;n;i++)&#123; s+=cross(p[i]-p[0],p[i+1]-p[i]); &#125; return s/2;&#125; 判断点是否在多边形内 射线法 从该点任意做一条和所有边都不平行的射线，若与多边形的交点为奇数个，则点在多边形内，否则点在多边形外 转角法 计算点与一个顶点连线到下一个点的连线转过的角度，若角度之和为 $360\\degree$，则点在多边形内，否则，点在多边形外 判断点是否在凸多边形内 只需判断点是否在所有边的左边，即点到每条边两段的向量的叉积为正即可。 皮克定理 皮克定理是指一个计算点阵中顶点在格点上的多边形面积公式，该公式可以表示为： $S&#x3D;a+\\frac b 2 -1$ 其中 $a$ 表示多边形内部的点数，$ b $ 表示多边形边界上的点数，$S$表示多边形的面积。 圆圆的方程：$(x-a)^2+(y-b)^2&#x3D;r^2$，直线的方程 $ax+by+c&#x3D;0$，联立，解方程即可。"},{"title":"莫比乌斯反演","path":"/2024/07/25/莫比乌斯反演/","content":"莫比乌斯反演莫比乌斯函数定义$$x&#x3D;p_1^{\\alpha_1}p_2^{\\alpha_2}\\cdots p_k^{\\alpha_k}\\\\mu(x) &#x3D; \\left{\\begin{matrix} 0 &amp; \\text{if } \\exists \\alpha_i \\ge2 \\ (-1)^k &amp; \\text{if } \\forall \\alpha_i &#x3D; 1\\end{matrix}\\right.$$ 性质记 $S(n)&#x3D; \\sum_{d|n} \\mu(d)$ ，那么 $S(n) &#x3D; \\left{\\begin{matrix} 1 &amp; \\text{if } n&#x3D;1\\ 0 &amp; \\text{if } n&gt;1\\end{matrix}\\right.$ 莫比乌斯反演若 $F(n)&#x3D;\\sum_{d|n} f(d)$ ，则 $f(n)&#x3D;\\sum_{d|n}\\mu(d)F(\\frac n d)$ 若 $F(n)&#x3D;\\sum_{n|d} f(d)$ ，则 $f(n)&#x3D;\\sum_{n|d}\\mu(\\frac d n)F(d)$ 例题1：洛谷 P2522 [HAOI2011] Problem b&#x2F;AcWing 2702. problem b 对于给出的 $ n $ 个询问，每次求有多少个数对 $ (x,y) $，满足 $ a≤x≤b，c≤y≤d $，且 $ \\text{gcd}(x,y) &#x3D; k $，$ \\text{gcd}(x,y) $ 函数为 $ x $ 和 $ y $ 的最大公约数。 输入格式第一行一个整数 $ n $。 接下来 $ n $ 行每行五个整数，分别表示 $ a、b、c、d、k $。 输出格式共 $ n $ 行，每行一个整数表示满足要求的数对 $ (x,y) $ 的个数。 数据范围$ 1 \\le n \\le 50000 $,$ 1 \\le a \\le b \\le 50000 $,$ 1 \\le c \\le d \\le 50000 $,$ 1 \\le k \\le 50000 $ 输入样例：12322 5 1 5 11 5 1 5 2 输出样例：12143 分析： 记答案为 $S$ ，$S&#x3D;S_{b,d}-S_{a-1,d}-S_{b,c-1}+S_{a-1,c-1}$，转化为求 $1 \\le x \\le a,1\\le y \\le b$ 的结果（前缀和） 定义 $F(n)&#x3D;\\sum_{x&#x3D;1}^a\\sum_{y&#x3D;1}^ b [n|(x,y)] $ （ 满足 $1 \\le x \\le a , 1 \\le y \\le b , n|(x,y)$ 的点 $(x,y)$ 的数量），$f(n)&#x3D;\\sum_{x&#x3D;1}^a \\sum_{y&#x3D;1}^b[(x,y)&#x3D;n]$（ 满足 $1 \\le x \\le a , 1 \\le y \\le b , (x,y)&#x3D;n$ 的点 $(x,y)$ 的数量） 则 $F(n)&#x3D;\\sum_{n|d} f(d)$，因此可以使用莫比乌斯反演，$f(n)&#x3D;\\sum_{n|d} \\mu(\\frac d n) F(d)$ 考虑如何求 $F(d)$，由于$d|(x,y)$，所以 $d|x,d|y$ ，所以 $F(d)&#x3D;\\lfloor \\frac a d \\rfloor \\lfloor \\frac b d \\rfloor$，所以 $f(n)&#x3D;\\sum_{n|d} \\mu(\\frac d n) \\lfloor \\frac a d \\rfloor \\lfloor \\frac b d \\rfloor$ 记 $d’&#x3D;\\frac d n$（$d’&#x3D;1,2,\\cdots$ ），则 $d&#x3D;d’n$ ，$f(n)&#x3D;\\sum_{d’} \\mu(d’) \\lfloor \\frac a {d’n} \\rfloor \\lfloor \\frac b {d’n} \\rfloor$ 由于 $a,b,n$ 的取值与 $d’$ 无关，因此可以记 $a’&#x3D;\\frac a n,b’&#x3D;\\frac b n$ ，$f(n)&#x3D;\\sum_{d’} \\mu(d’) \\lfloor \\frac {a’} {d’} \\rfloor \\lfloor \\frac {b’} {d’} \\rfloor$，此时直接求的复杂度为 $O(n)$ 由于 $d’$ 的取值为 $1,2,\\cdots$，由整数分块可知，可以将 $1\\sim n$ 划分为 $O(\\sqrt n)$ 段，在每一段中 $\\lfloor \\frac {a’} {d’} \\rfloor \\lfloor \\frac {b’} {d’} \\rfloor$ 的取值都相等，记这个值为 $c$，记一段的左端点为 $L$ ，右端点为 $R$ ，则这一段的值就为 $c\\cdot[\\mu(L)+\\mu(L+1)+\\cdots + \\mu(R)]$，$\\mu(i)$ 可以通过线性筛在 $O(n)$ 的时间复杂度内算出，可以使用前缀和将每次查询优化至 $O(1)$，因此计算每一段的值的时间复杂度为 $O(1)$，计算$f(n)$ 的时间复杂度为 $O(\\sqrt n)$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N=5e4+5;int primes[N],cnt,mu[N];bool st[N];int sum[N];void init()&#123; mu[1]=1; for(int i=2;i&lt;N;i++)&#123; if(!st[i])primes[cnt++]=i,mu[i]=-1; for(int j=0;primes[j]*i&lt;N;j++)&#123; st[primes[j]*i]=true; if(i%primes[j]==0)break; mu[primes[j]*i]=-mu[i];//若mu[i]=0,则mu[p*i]=0,若mu[i]=1/-1，设mu[i]=(-1)^k，则mu[i*p]=(-1)^(k+1)=-mu[i] &#125; &#125; for(int i=1;i&lt;N;i++)&#123; sum[i]=sum[i-1]+mu[i]; &#125;&#125;int g(int k,int x)&#123; return k/(k/x);&#125;ll f(int a,int b,int k)&#123; a=a/k,b=b/k;//a-&gt;a&#x27;,b-&gt;b&#x27; ll res=0; int n=min(a,b); //整数分块 for(int l=1,r;l&lt;=n;l=r+1)&#123; r=min(n,min(g(a,l),g(b,l))); res+=1ll*(sum[r]-sum[l-1])*(a/l)*(b/l); &#125; return res;&#125;int main()&#123; init(); int T; cin &gt;&gt; T; while(T--)&#123; int a,b,c,d,k; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; k; cout &lt;&lt; f(b,d,k)-f(a-1,d,k)-f(b,c-1,k)+f(a-1,c-1,k) &lt;&lt; endl; &#125; return 0;&#125; 例题2：洛谷 P3327 [SDOI2015] 约数个数和&#x2F;AcWing 1358. 约数个数和 设 $ d(x) $ 为 $ x $ 的约数个数，给定 $ N,M $，求 $$\\sum_{i&#x3D;1}^N\\sum_{j&#x3D;1}^Md(ij)$$ 输入格式输入多组测试数据。 第一行，一个整数 $ T $，表示测试数据的组数。 接下来的 $ T $ 行，每行两个整数 $ N、M $。 输出格式$ T $ 行，每行一个整数，表示你所求的答案。 数据范围$ 1 \\le N,M,T \\le 50000 $ 输入样例：12327 45 6 输出样例：12110121 分析： 引理：$d(ij)&#x3D;\\sum_{x|i} \\sum_{y|j} [(x,y)&#x3D;1]$ 引理证明： 先考虑左边，设 $i&#x3D;p_1^{\\alpha_1}p_2^{\\alpha_2}\\cdots p_k^{\\alpha_k},j&#x3D;p_1^{\\beta_1}p_2^{\\beta_2}\\cdots p_k^{\\beta_k}$，则 $ij&#x3D;p_1^{\\alpha_1+\\beta_1}p_2^{\\alpha_2+\\beta_2}\\cdots p_k^{\\alpha_k+\\beta_k}$，$d(ij)&#x3D;(\\alpha_1+\\beta_1+1)(\\alpha_2+\\beta_2+1)\\cdots(\\alpha_k+\\beta_k+1)$ 再考虑右边，先考虑 $x,y$ 是 $p_1$ 的倍数的情况，当 $x&#x3D;1$ 时，$y$ 可以取 $1,p_1,p_1^2 ,\\cdots , p_1^{\\beta_1}$ ， $y&#x3D;1$ 时 $x$ 可以取 $1,p_1,p_1^2 ,\\cdots , p_1^{\\alpha_1}$，而 $x,y$ 均不为 $1$ 时 $(x,y)$ 一定不为 $1$，因此一共 $ \\alpha_1 +\\beta_1 +1$ 种取法，同理，对于 $p_i$ ，有 $\\alpha_i+\\beta_i+1$ 中取法，因此总的取法为 $(\\alpha_1+\\beta_1+1)(\\alpha_2+\\beta_2+1)\\cdots(\\alpha_k+\\beta_k+1)$ 综上，左边等于右边，引理得证 由引理得：$$\\sum_{i&#x3D;1}^N\\sum_{j&#x3D;1}^M d(ij)&#x3D;\\sum_{i&#x3D;1}^N\\sum_{j&#x3D;1}^M\\sum_{x|i} \\sum_{y|j} [(x,y)&#x3D;1]$$设 $F(n)&#x3D;\\sum_{i&#x3D;1}^N\\sum_{j&#x3D;1}^M\\sum_{x|i}\\sum_{y|j}[n|(x,y)]$，$f(n)&#x3D;\\sum_{i&#x3D;1}^N\\sum_{j&#x3D;1}^M\\sum_{x|i}\\sum_{y|j}[(x,y)&#x3D;n]$ 则 $F(n)&#x3D;\\sum_{n|d} f(d)$，所以 $f(n)&#x3D;\\sum_{n|d} \\mu(\\frac d n) F(d)$ 因此，问题转化为求 $f(1)$ $f(1)&#x3D;\\sum_{d&#x3D;1}^{\\min(N,M)} \\mu(d) F(d)$ 下面考虑如何求 $F(d)$$$F(n)&#x3D;\\sum_{i&#x3D;1}^N\\sum_{j&#x3D;1}^M\\sum_{x|i}\\sum_{y|j}[n|(x,y)]&#x3D;\\sum_{x&#x3D;1}^N\\sum_{y&#x3D;1}^M \\lfloor\\frac N x \\rfloor \\lfloor \\frac M y \\rfloor [n|(x,y)]$$由于 $n|(x,y)$，所以 $n|x,n|y$。设 $x’&#x3D;\\frac x n,y’&#x3D;\\frac y n$，则$$F(n)&#x3D;\\sum_{x&#x3D;1}^N\\sum_{y&#x3D;1}^M \\lfloor\\frac N x \\rfloor \\lfloor \\frac M y \\rfloor [n|(x,y)]&#x3D;\\sum_{x’&#x3D;1}^{\\frac N n}\\sum_{y’&#x3D;1}^{\\frac M n} \\lfloor\\frac N {nx’} \\rfloor \\lfloor \\frac M {ny’} \\rfloor$$记 $N’&#x3D;\\frac N n,M’&#x3D;\\frac M n$，则$$F(n)&#x3D;\\sum_{x’&#x3D;1}^{\\frac N n}\\sum_{y’&#x3D;1}^{\\frac M n} \\lfloor\\frac N {nx’} \\rfloor \\lfloor \\frac M {ny’} \\rfloor&#x3D;\\sum_{i&#x3D;1}^{N’}\\sum_{j&#x3D;1}^{M’} \\lfloor\\frac {N’} {x’} \\rfloor \\lfloor \\frac {M’} {y’} \\rfloor$$记 $a_i&#x3D;\\lfloor \\frac {N’} i \\rfloor,b_j&#x3D;\\lfloor \\frac{M’} j \\rfloor$，则$$F(n)&#x3D;\\sum_{i&#x3D;1}^{N’}\\sum_{j&#x3D;1}^{M’} \\lfloor\\frac {N’} {x’} \\rfloor \\lfloor \\frac {M’} {y’} \\rfloor&#x3D;\\sum_{i&#x3D;1}^{N’}\\sum_{j&#x3D;1}^{M’} a_i b_j&#x3D;(\\sum_{i&#x3D;1}^{N’}a_i)(\\sum_{j&#x3D;1}^{M’}b_j)$$记 $h(k)&#x3D;\\sum_{i&#x3D;1}^k \\lfloor \\frac k i \\rfloor$，则$$F(n)&#x3D;(\\sum_{i&#x3D;1}^{N’}a_i)(\\sum_{j&#x3D;1}^{M’}b_j)&#x3D;h(N’)\\cdot h(M’)$$所以$$f(1)&#x3D;\\sum_{d&#x3D;1}^{\\min(N,M)} \\mu(d) F(d)&#x3D;\\sum_{d&#x3D;1}^{\\min(N,M)} \\mu(d) \\cdot h(\\frac N d) \\cdot h(\\frac M d)$$由于 $h(x)$ 的取值完全取决于 $x$ ，因此可以使用整数分块预处理所有的 $h(i)$，时间复杂度 $O(n\\sqrt n)$ 计算 $f(1)$ 时，也可以用整数分块计算每一段的 $h(\\frac N d) \\cdot h(\\frac M d)$，使用前缀和计算每一段的 $\\mu(d)$，时间复杂度 $O(\\sqrt n)$ 总时间复杂度 $O(n+n\\sqrt n +q \\sqrt n)$。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N=5e4+5;int primes[N],cnt,mu[N],sum[N],h[N];bool st[N];int g(int k,int x)&#123; return k/(k/x);&#125;void init()&#123; mu[1]=1; for(int i=2;i&lt;N;i++)&#123; if(!st[i])primes[cnt++]=i,mu[i]=-1; for(int j=0;primes[j]*i&lt;N;j++)&#123; st[primes[j]*i]=true; if(i%primes[j]==0)break; mu[i*primes[j]]=-mu[i]; &#125; &#125; for(int i=1;i&lt;N;i++)&#123; sum[i]=sum[i-1]+mu[i]; &#125; for(int i=1;i&lt;N;i++)&#123; for(int l=1,r;l&lt;=i;l=r+1)&#123; r=min(i,g(i,l)); h[i]+=(r-l+1)*(i/l); &#125; &#125;&#125;int main()&#123; init(); int T; cin &gt;&gt; T; while(T--)&#123; int n,m; cin &gt;&gt; n &gt;&gt; m; ll res=0; int k=min(n,m); for(int l=1,r;l&lt;=k;l=r+1)&#123; r=min(k,min(g(n,l),g(m,l))); res+=1ll*(sum[r]-sum[l-1])*h[x/l]*h[m/l]; &#125; cout &lt;&lt; res &lt;&lt; endl; &#125; return 0;&#125;"},{"title":"置换群","path":"/2024/07/25/置换群/","content":"置换群置换群置换：把 $1,2,\\cdots,n$ 映射到一个 1 到 n 的排列 $p_1,p_2,\\cdots,p_n$ 称为置换，可记为 $f(x)&#x3D;p_x$ 循环置换：即把 $1,2,\\cdots,n-1,n$ 映射到 $2,3,\\cdots,n,1$ 置换的乘积：即复合函数，如有两个置换为 $f(x),g(x)$，则这两个置换的乘积为 $g(f(x))$ 性质：任意一个置换都可以拆成若干个循环置换的乘积 置换群：$1\\sim n$ 的置换共有 $n!$ 种，这 $n!$ 种置换称为一个置换群，且置换群的子集也是置换群 Burnside 引理和 Polya 定理求在 $n$ 个点的环上染色，共 $m$ 种颜色的方案数 Burnside引理：对于每个置换不动点个数的平均值就是不同的方案数 不动点：对于某种方案，经过置换之后若某个的的方案不变，则这个点称为这个置换的不动点。 Polya定理：将一个置换拆解成多个循环置换，共 $c$ 种颜色，由于每个循环内的颜色一定一样，每个循环之间相互独立，设循环数 $k$ ，则循环的不动点数为 $c^k$ 使用 Polya 定理，必须保证循环之间相互独立。 例题1：AcWing 3133. 串珠子(Polya 定理) 给定 $ M $ 种不同颜色的珠子，每种颜色的珠子的个数都足够多。 现在要从中挑选 $ N $ 个珠子，串成一个环形手链。 请问一共可以制作出多少种不同的手链。 注意，如果两个手链经旋转或翻转后能够完全重合在一起，对应位置的珠子颜色完全相同，则视为同一种手链。 输入格式输入包含多组测试数据。 每组测试数据占一行，包含两个整数 $ M,N $。 最后一行包含 0 0 表示输入结束。 输出格式每组数据输出一个占一行的整数表示结果。 数据范围$ N,M &gt; 0 $,$ N \\times M \\le 32 $ 输入样例：123456781 12 12 25 12 52 66 20 0 输出样例：1234567123581321 样例解释当 $ M&#x3D;2,N&#x3D;5 $ 时，一共可以制作出 $ 8 $ 种不同的手链，如下图。 分析： 一共两种操作：旋转和翻转。 先考虑旋转，可以旋转 $k&#x3D;0,1,\\cdots,n-1$ 次 对于每种方案 ，则找到循环等价于找到一个 $t$ ，满足 $x+kt\\equiv x \\pmod n$，即 $kt \\equiv 0 \\pmod n \\Longleftrightarrow kt+nr&#x3D;0$，其最小解为 $t&#x3D;\\frac n d,d&#x3D;(n,k)$。因此，每个循环的点数为 $\\frac n d$ ，所以循环数就是 $d&#x3D;(n,k)$，则不动点的个数就是 $m^d$，所以总不动点个数就是 $\\sum_{k&#x3D;0}^{n-1}m^{(n,i)}$ 再考虑翻转： 若 $n$ 为奇数，则对称轴共 $n$ 个，每个对称轴对应一组方案，其循环为对称点相互配对，对称轴穿过的点单独一个循环，共 $\\frac{n+1} 2$ 个，因此不动点个数为 $n\\cdot m^{\\frac{n+1}2}$ 若 $n$ 为偶数，则对称轴分为两类： 若对称轴穿过两个点，则这两个点各自一个循环，其余点两两配对，共 $\\frac n 2 +1$ 个循环，有 $\\frac n 2$ 个这种对称轴，因此不动点个数为 $\\frac n 2\\cdot m ^{\\frac n 2 +1} $ 若对称轴在两点之间，共 $\\frac n 2 $ 个对称轴，点两两配对，共 $\\frac n 2$ 个循环，因此不动点个数为 $\\frac n 2 \\cdot m^{\\frac n 2}$ 所以 $n$ 为偶数时，不动点个数为 $\\frac n 2\\cdot m ^{\\frac n 2 +1}+\\frac n 2 \\cdot m^{\\frac n 2} $ 由于一共有 $2n$ 种置换，因此将不动点个数相加除以 $2n$ 即为答案 1234567891011121314151617181920#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n,m; while(cin &gt;&gt; m &gt;&gt; n,n||m)&#123; int sum=0; for(int i=0;i&lt;n;i++)&#123; sum+=pow(m,__gcd(n,i)); &#125; if(n&amp;1)&#123; sum+=n*pow(m,(n+1)/2); &#125; else&#123; sum+=n/2*pow(m,n/2+1)+n/2*pow(m,n/2); &#125; cout &lt;&lt; sum/2/n &lt;&lt; endl; &#125; return 0;&#125; 第一个 for 循环可以使用欧拉定理+莫比乌斯反演优化 例题2：AcWing 3134. 魔法手链 给定 $ m $ 种不同颜色的魔法珠子，每种颜色的珠子的个数都足够多。 现在要从中挑选 $ n $ 个珠子，串成一个环形魔法手链。 魔法珠子之间存在 $ k $ 对排斥关系，互相排斥的两种颜色的珠子不能相邻，否则会发生爆炸。（同一种颜色的珠子之间也可能存在排斥） 请问一共可以制作出多少种不同的手链。 注意，如果两个手链经旋转后能够完全重合在一起，对应位置的珠子颜色完全相同，则视为同一种手链。 答案对 $ 9973 $ 取模。 输入格式第一行包含整数 $ T $，表示共有 $ T $ 组测试数据。 每组数据第一行包含三个整数 $ n,m,k $。 接下来 $ k $ 行，每行包含两个整数 $ a,b $，表示颜色 $ a $ 的珠子不能和颜色 $ b $ 的珠子相邻。 $ m $ 种颜色编号为 $ 1 \\sim m $。 输出格式每组数据输出一行一个整数，表示答案。 数据范围$ 1 \\le T \\le 10 $,$ 1 \\le n \\le 10^9 $,$ gcd(n, 9973) &#x3D; 1 $,$ 1 \\le m \\le 10 $,$ 0 \\le k \\le \\frac{m(m+1)}{2} $,$ 1 \\le a,b \\le m $ 输入样例：123456789101143 2 03 2 11 23 2 21 11 23 2 31 11 22 2 输出样例：12344210 分析： 只有一种操作：旋转。 由于环之间有限制，因此不能使用 Polya 定理。 设旋转了 $k&#x3D;0,1,2,\\cdots ,n-1$ 次，设 $d&#x3D;(n,k)$，则共有 $d$ 个循环，每个循环有 $\\frac n d$ 个点（理由同上题） 令 $k’&#x3D;\\frac k d,n’&#x3D;\\frac n d$，由于共 $\\frac n d$ 个点，每个点间的间隔为 $d$ ，因此每个点离起点的距离为 $d$ 的倍数，所以可以将 $0,d,2d,\\cdots$ 映射为 $0,1,2,\\cdots$，则原环变为一个长度为 $n’$ 的环，每次跳 $k’$ 步。由于 $(k’,n’)&#x3D;1$ ，所以每次走 $k’$ 步一定可以遍历环中的所有点，即 $k’\\cdot 0,k’\\cdot 1,k’\\cdot2 ,\\cdots,k’\\cdot (n’-1)$ 构成一个模 $n’$ 的简化剩余系（缩系） 由于每一段的起点为 $x,x+1,\\cdots,x+d-1$，所以从起点开始每个长度为 $d$ 的段的颜色与上一个长度为 $d$ 的段的颜色一定相同，因此整体的颜色就取决于第一段的颜色，因此求不动点的数量只需关注第一段即可。由于每一段的最后一个点与下一段的第一个点相邻，而下一段的第一个点与这一段的第一个点相同，因此可以看成每一段的最后一个点与第一个点相邻，因此只需关注长度为 $d$ 的环染色方案即可。 接下来可以暴力求出这个环的染色方案数，使用 dp ，$f_{i,j}$ 表示已经染完了 $i$ 个格子，第 $i$ 个点染 $j$ 种颜色的方案数。枚举第一个格子染的颜色，若当前枚举到第 $k$ 种颜色，则初始化 $f_{0,k}&#x3D;1$，$f_{i,j}&#x3D;\\sum_{k&#x3D;0}^{m} f_{i-1,k}$，可以使用矩阵乘法优化。 记 $F_i&#x3D;[f_{i,1},f_{i,2},\\cdots,f_{i,m}]$，则 $F_i&#x3D;F_{i-1}\\cdot M$，其中 $M$ 的 $(a_i,b_i)&#x3D;0$，其余项为 $1$ （$(a_i,b_i)$ 表示一组限制条件） 则 $F_d&#x3D;F_0\\cdot M^d$，使用矩阵快速幂优化。 由于 $n$ 很大，因此枚举步数 $k$ 时不能直接枚举，可以将所有的循环置换分类，由于每个循环置换的方案数只取决于 $d$ ，因此可以将所有的 $k$ 按照 $d$ 分类。枚举所有的 $d$ ，对于每个 $d$ ，枚举 $n$ 的约数，则只需找出 $k$ 使得 $(\\frac k d,\\frac n d)&#x3D;1$ 的个数即可，这个个数就是 $\\varphi(\\frac n d)$。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;bits/stdc++.h&gt;using namespace std;const int N=11,P=9973;int m;struct Matrix&#123; int a[N][N]; Matrix()&#123; memset(a,0,sizeof a); &#125; Matrix operator*(const Matrix x)const&#123; Matrix res; for(int i=1;i&lt;=m;i++)&#123; for(int j=1;j&lt;=m;j++)&#123; for(int k=1;k&lt;=m;k++)&#123; res.a[i][j]=(res.a[i][j]+a[i][k]*x.a[k][j])%P; &#125; &#125; &#125; return res; &#125;&#125;;int quick_pow(Matrix x,int k)&#123; Matrix res;//res.a[i]=F[i],同时算所有的m for(int i=1;i&lt;=m;i++)&#123; res.a[i][i]=1; &#125; while(k)&#123; if(k&amp;1)res=res*x; x=x*x; k&gt;&gt;=1; &#125; //求出方案总和 int sum=0; for(int i=1;i&lt;=m;i++)&#123; sum+=res.a[i][i]; &#125; return sum%P;&#125;int phi(int n)&#123;//欧拉函数 int res=n; for(int i=2;i*i&lt;=n;i++)&#123; if(n%i==0)&#123; res=res/i*(i-1); while(n%i==0)n/=i; &#125; &#125; if(n&gt;1)res=res/n*(n-1); return res%P;&#125;int inv(int n)&#123;//逆元 n%=P; for(int i=1;i&lt;P;i++)&#123; if(i*n%P==1)return i; &#125; return -1;&#125;int main()&#123; int T; cin &gt;&gt; T; while(T--)&#123; int n,k; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; Matrix tr;//转移矩阵 for(int i=1;i&lt;=m;i++)&#123; for(int j=1;j&lt;=m;j++)&#123; tr.a[i][j]=1; &#125; &#125; while(k--)&#123; int x,y; cin &gt;&gt; x &gt;&gt; y; tr.a[x][y]=tr.a[y][x]=0; &#125; int res=0; for(int i=1;i*i&lt;=n;i++)&#123; if(n%i==0)&#123; res=(res+quick_pow(tr,i)*phi(n/i))%P; if(i!=n/i)&#123; res=(res+quick_pow(tr,n/i)*phi(i))%P;//相配对的约数 &#125; &#125; &#125; cout &lt;&lt; res*inv(n)%P &lt;&lt; endl;//不动点数除以置换数，相当于乘逆元 &#125; return 0;&#125;"},{"title":"网络流","path":"/2024/07/25/网络流/","content":"网络流基本概念流网络 流网络中存在两个特殊点：源点和汇点；每条边存在一个容量，记作$c(u,v)$，若边不存在，则$c(u,v)&#x3D;0$；用$f(u,v)$表示每条边的流量，即实际流过的流量值。 可行流若一个可行流$f$满足： 容量限制：$0 \\le f(u,v) \\le c(u,v)$，即所有边的流量不超过边的容量 流量守恒：$v,x \\in V&#x2F; {s,t},\\sum_{(v,x)\\in E}f(v,x)&#x3D;\\sum_{(x,v)\\in E}f(x.v)$，即所有除了源点和汇点的点的流入总量等于流出总量 用$|f|$表示可行流$f$每秒从源点流出的流量，即$\\sum_{(s,v)\\in E}f(s,v)-\\sum_{(v.s)\\in E}f(v,s)$， 最大流最大流就是最大可行流，即所有可行流中的最大值。 残留网络对于每个可行流，都有对应的一个残留网络。 记可行流$f&#x3D;(V,E)$的残留网络为$G_f$，则残留网络的$V_f&#x3D;V,E_f&#x3D;E$和$E$的所有反向边，反向边的边权$c’(u,v)&#x3D;a \\begin{cases} c(u,v)-f(u,v) &amp; (u,v)\\in E \\ f(u,v) &amp; (v,u)\\in E\\end{cases}$ 定理：记原网络$G$的一个可行流为$f$，其残留网络$G_f$的一个可行流为$f’$，则$f+f’$也是$G$的一个可行流，且$|f+f’|&#x3D;|f|+|f’|$。 增广路径在残留网络中从源点出发沿着容量大于$0$的边如果能走到汇点，则这条路径为一条增广路径。 定理：若一个可行流$f$的残留网络中没有增广路径，则这个可行流一定是一个最大流。 割在一个流网络$G&#x3D;(V,E)$中选取两个点集$S,T$，满足$S\\cap T&#x3D;\\phi,S\\cup T&#x3D;V$，且源点$s \\in S$，汇点$t \\in T$，则这种划分方案称为流网络的一个割。 割的容量：所有从$S$连向$T$的边的容量之和，即$c(S,T)&#x3D;\\sum_{u \\in S} \\sum_{v \\in T} c(u,v)$。 最小割：所有割的割的容量最小的割。 割的流量：从$S$连向$T$的边的流量之和减去从$T$连向$S$的边的流量之和，即$f(S,T)&#x3D;\\sum_{u \\in S} \\sum_{v \\in T} f(u,v)-\\sum_{u \\in T} \\sum_{v \\in S} f(u,v)$ 性质： 对于任意一个割，割的流量小于等于割的容量，即$f(S,T)\\le c(S,T)$ $f(X,Y)&#x3D;-f(Y,X)$ $f(X,X)&#x3D;0$ 若$X\\cap Y&#x3D;\\phi$，则$f(Z,X\\cup Y)&#x3D;f(Z,X)+f(Z,Y),f(X\\cup Y,Z)&#x3D;f(X,Z)+f(Y,Z)$ 对于任意可行流$f$，任意割$[S,T]$，$|f| &#x3D; f(S,T) \\le c(S,T)$ 最大流最小割定理： 在$G&#x3D;(V,E)$中，$f$是最大流$\\iff$ $G_f$中不存在增广路径 $\\iff$ $\\exist [S,T] ,|f|&#x3D;c(S,T)$。 最大流题目：洛谷P3376 【模板】网络最大流 EK算法维护残留网络，使用 while 循环，每次循环进行以下操作： 找增广路径（BFS即可） 更新残留网络 设增广路径的流量为$k$，则将正向边的容量减去$k$，反向边的容量加上$k$ 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N=205,M=10005;const ll INF=0x3f3f3f3f3f3f3f3f;ll n,m,S,T;//点数，边数，源点，汇点ll h[N],to[M],ne[M],f[M],idx;//链式前向星，下标从0开始，01，23...存正反边，i^1即为第i条边的反向边，h初始为-1//f[i]表示第i条边的容量（即c(u,v)）ll d[N],pre[N];//d[i]表示第i个点的最大流量，pre数组记录找到的增广路径中每个点对应的前一条边bool st[N];//bfs判断是否入队void add(ll a,ll b,ll c)&#123; to[idx]=b,f[idx]=c,ne[idx]=h[a],h[a]=idx++; to[idx]=a,f[idx]=0,ne[idx]=h[b],h[b]=idx++;&#125;//加正反两条边bool bfs()&#123; queue&lt;ll&gt;q; memset(st,false,sizeof st); q.push(S); st[S]=true,d[S]=INF; while(!q.empty())&#123; ll t=q.front(); q.pop(); for(ll i=h[t];~i;i=ne[i])&#123; ll ver=to[i]; if(!st[ver]&amp;&amp;f[i])&#123; st[ver]=true; d[ver]=min(d[t],f[i]); pre[ver]=i; if(ver==T)return true; q.push(ver); &#125; &#125; &#125; return false;&#125;//bfs找增广路径ll EK()&#123; ll r=0;//记录总的流量 while(bfs())&#123; r+=d[T]; for(ll i=T;i!=S;i=to[pre[i]^1])&#123; f[pre[i]]-=d[T],f[pre[i]^1]+=d[T];//更新残留网络，通过找连向当前点的边的反向边找到上一个点 &#125; &#125; return r;&#125;//EK算法int main()&#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; S &gt;&gt; T; memset(h,-1,sizeof h); while(m--)&#123; ll a,b,c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; add(a,b,c); &#125; cout &lt;&lt; EK() &lt;&lt; endl; return 0;&#125; 时间复杂度$O(nm^2)$ Dinic算法优化思想：每次增广时把所有可以增广的边都枚举一遍。 由于图中可能有环，因此使用分层图的思想。每个点的层数就是这个点到起点的距离，具体地，从起点开始进行 BFS ，第一次遍历到一个点时记录即可。找增广路时，规定在分层图中每次只能向层数更深的点进行遍历，即可找出增广路径。 形式化流程： 进行BFS，建立分层图 进行DFS，找出所有能增广的路径 当前弧优化： 注意到如果我们已经访问过了一条边(即把这条边的流量耗尽了），那我们以后就不用再访问这条边了。于是我们考虑开一个数组$cur$表示当前考虑到了哪一条弧。每次重新 BFS 就把$cur[x]$设为$x$邻接表中的第一个元素。而 DFS 到这个点的时候就从$cur[x]$ 开始遍历后面的边。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N=1e4+5,M=2e5+5;const ll INF=0x3f3f3f3f3f3f3f3f;ll n,m,S,T;ll h[N],to[M],f[M],ne[M],idx;ll d[N],cur[N];//d:分层图层数 cur:当前弧优化void add(ll a,ll b,ll c)&#123; to[idx]=b,f[idx]=c,ne[idx]=h[a],h[a]=idx++; to[idx]=a,f[idx]=0,ne[idx]=h[b],h[b]=idx++;&#125;bool bfs()&#123; queue&lt;ll&gt;q; memset(d,-1,sizeof d); q.push(S),d[S]=0,cur[S]=h[S]; while(!q.empty())&#123; ll t=q.front(); q.pop(); for(ll i=h[t];~i;i=ne[i])&#123; ll ver=to[i]; if(d[ver]==-1&amp;&amp;f[i])&#123; d[ver]=d[t]+1;//记录层数 cur[ver]=h[ver];//初始化当前弧 if(ver==T)return true; q.push(ver); &#125; &#125; &#125; return false;&#125;ll find(ll u,ll limit)&#123;//表示从源点走到u，可以流过的最大流量为limit if(u==T)return limit; ll flow=0; for(ll i=cur[u];~i&amp;&amp;flow&lt;limit;i=ne[i])&#123;//一定要加上flow&lt;limit，防止错误 cur[u]=i;//流到的当前边，表示前面的边都被用完了，记录当前弧 ll ver=to[i]; if(d[ver]==d[u]+1&amp;&amp;f[i])&#123; ll t=find(ver,min(f[i],limit-flow)); if(!t)d[ver]=-1;//流不到，从图中删除 f[i]-=t,f[i^1]+=t,flow+=t; &#125; &#125; return flow;&#125;ll dinic()&#123; ll r=0,flow; while(bfs())&#123;//判断是否有增广路，建立分层图，初始化当前弧 while(flow=find(S,INF))&#123;//从源点开始找出所有的增广路 r+=flow; &#125; &#125; return r;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; S &gt;&gt; T; memset(h,-1,sizeof h); while(m--)&#123; ll a,b,c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; add(a,b,c); &#125; cout &lt;&lt; dinic() &lt;&lt; endl; return 0;&#125; 时间复杂度$O(n^2m)$ 思想要保证原问题的可行解与建立的流网络的可行流可以一一对应，这样原问题的最大值就等价于流网络中的最大可行流。 二分图匹配例题1：洛谷P2756 飞行员配对方案问题：网络流实现二分图 飞行员配对方案问题题目背景第二次世界大战期间，英国皇家空军从沦陷国征募了大量外籍飞行员。由皇家空军派出的每一架飞机都需要配备在航行技能和语言上能互相配合的两名飞行员，其中一名是英国飞行员，另一名是外籍飞行员。在众多的飞行员中，每一名外籍飞行员都可以与其他若干名英国飞行员很好地配合。 题目描述一共有 $n$ 个飞行员，其中有 $m$ 个外籍飞行员和 $(n - m)$ 个英国飞行员，外籍飞行员从 $1$ 到 $m$ 编号，英国飞行员从 $m + 1$ 到 $n$ 编号。 对于给定的外籍飞行员与英国飞行员的配合情况，试设计一个算法找出最佳飞行员配对方案，使皇家空军一次能派出最多的飞机。 输入格式输入的第一行是用空格隔开的两个正整数，分别代表外籍飞行员的个数 $m$ 和飞行员总数 $n$。从第二行起到倒数第二行，每行有两个整数 $u, v$，代表外籍飞行员 $u$ 可以和英国飞行员 $v$ 配合。输入的最后一行保证为 -1 -1，代表输入结束。 输出格式本题存在 Special Judge。请输出能派出最多的飞机数量，并给出一种可行的方案。输出的第一行是一个整数，代表一次能派出的最多飞机数量，设这个整数是 $k$。第 $2$ 行到第 $k + 1$ 行，每行输出两个整数 $u, v$，代表在你给出的方案中，外籍飞行员 $u$ 和英国飞行员 $v$ 配合。这 $k$ 行的 $u$ 与 $v$ 应该互不相同。 样例 #1样例输入 #11234567891011125 101 71 82 62 92 103 73 84 74 85 10-1 -1 样例输出 #11234541 72 93 85 10 提示【数据范围与约定】 对于 $100%$ 的数据，保证 $1 \\leq m \\leq n &lt; 100$，$1 \\leq u \\leq m &lt; v \\leq n$，同一组配对关系只会给出一次。 【提示】 请注意输入的第一行先读入 $m$，再读入 $n$。 分析： 由于每个外籍飞行员只能选一次，因此从源点向每个外籍飞行员连一条容量为1的边，同理从每个英国飞行员向汇点连一条容量为1的边，对于每一对可以配对的飞行员在他们之间连一条容量为1的边，直接求最大流即可。 通过模拟可以发现，求二分图用的匈牙利算法与EK算法相同，因此使用Dinic算法可以优化时间复杂度。 输出边时可以枚举所有中间的正向边，若容量为0，则输出这条边。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;bits/stdc++.h&gt;using namespace std;const int N=1e4+5,M=10005,INF=0x3f3f3f3f;int n,m,S,T;int h[N],to[M],ne[M],f[M],idx;int d[N],cur[N];void add(int a,int b)&#123; to[idx]=b,ne[idx]=h[a],f[idx]=1,h[a]=idx++; to[idx]=a,ne[idx]=h[b],f[idx]=0,h[b]=idx++;&#125;bool bfs()&#123; queue&lt;int&gt;q; memset(d,-1,sizeof d); q.push(S),d[S]=0,cur[S]=h[S]; while(!q.empty())&#123; int t=q.front(); q.pop(); cur[t]=h[t]; for(int i=h[t];~i;i=ne[i])&#123; int ver=to[i]; if(d[ver]==-1&amp;&amp;f[i])&#123; d[ver]=d[t]+1; cur[ver]=h[ver]; if(ver==T)return true; q.push(ver); &#125; &#125; &#125; return false;&#125;int find(int u,int limit)&#123; if(u==T)&#123; return limit; &#125; int flow=0; for(int i=cur[u];~i&amp;&amp;flow&lt;limit;i=ne[i])&#123; int ver=to[i]; cur[u]=i; if(d[ver]==d[u]+1&amp;&amp;f[i])&#123; int t=find(ver,min(f[i],limit-flow)); if(!t)d[ver]=-1; f[i]-=t,f[i^1]+=t,flow+=t; &#125; &#125; return flow;&#125;int dinic()&#123; int r=0,flow; while(bfs())&#123; while(flow=find(S,INF))&#123; r+=flow; &#125; &#125; return r;&#125;int main()&#123; memset(h,-1,sizeof h); cin &gt;&gt; m &gt;&gt; n; S=0,T=n+1; for(int i=1;i&lt;=m;i++)&#123; add(S,i); &#125; for(int i=m+1;i&lt;=n;i++)&#123; add(i,T); &#125; while(true)&#123; int a,b; cin &gt;&gt; a &gt;&gt; b; if(a==-1&amp;&amp;b==-1)break; add(a,b); &#125; cout &lt;&lt; dinic() &lt;&lt; endl; for(int i=1;i&lt;=m;i++)&#123; for(int j=h[i];~j;j=ne[j])&#123; if(f[j]==0&amp;&amp;j%2==0)cout &lt;&lt; i &lt;&lt; &#x27; &#x27; &lt;&lt; to[j] &lt;&lt; endl; &#125; &#125; /* 另一种方法： for(int i=0;i&lt;idx;i+=2)&#123; if(to[i]&gt;m&amp;&amp;to[i]&lt;=n&amp;&amp;f[i]==0)cout &lt;&lt; to[i^1] &lt;&lt; &#x27; &#x27; &lt;&lt; to[i] &lt;&lt; endl; &#125; */ return 0;&#125; 例题2：洛谷P3254 圆桌问题：二分图多重匹配 圆桌问题题目描述有来自 $m$ 个不同单位的代表参加一次国际会议。第 $i$ 个单位派出了 $r_i$ 个代表。 会议的餐厅共有 $n$ 张餐桌，第 $i$ 张餐桌可容纳 $c_i$ 个代表就餐。 为了使代表们充分交流，希望从同一个单位来的代表不在同一个餐桌就餐。请给出一个满足要求的代表就餐方案。 输入格式输入的第一行是用空格隔开的两个整数，分别代表单位的个数 $m$ 和餐桌的个数 $n$。第二行有 $m$ 个用空格隔开的整数，第 $i$ 个整数代表第 $i$ 个单位的代表人数 $r_i$。第三行有 $n$ 个用空格隔开的整数，第 $i$ 个整数代表第 $i$ 张餐桌能容纳的人数 $c_i$。 输出格式本题存在 Special Judge。请输出是否存在满足要求的就餐方案，若存在，请给出任意一种可行的方案。输出的第一行是一个非 $0$ 即 $1$ 的整数，若存在方案则输出 $1$，否则输出 $0$。若存在方案，则对于第 $2$ 到第 $(m + 1)$ 行，在第 $(i + 1)$ 行输出 $r_i$ 个整数，代表第 $i$ 个单位的代表就餐的餐桌编号。 样例 #1样例输入 #1123&gt;4 5&gt;4 5 3 5&gt;3 5 2 6 4 样例输出 #112345&gt;1&gt;1 2 4 5&gt;1 2 3 4 5&gt;2 4 5&gt;1 2 3 4 5 提示【数据规模与约定】 对于 $100%$ 的数据，保证 $1 \\leq m \\leq 150$，$1 \\leq n \\leq 270$，$1 \\leq r_i, c_i \\leq 10^3$。 【提示】 请注意输入的第一行先读入 $m$ 再读入 $n$。 分析： 从源点向每个单位连一条容量为单位人数的边，从每个圆桌向汇点连一条容量为餐桌容量的边，每个单位和每个圆桌之间连一条容量为1的边。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;bits/stdc++.h&gt;using namespace std;const int N=1e3+5,M=1e5+5,INF=0x3f3f3f3f;int n,m,S,T;int h[N],to[M],ne[M],f[M],idx;int d[N],cur[N];int tot;void add(int a,int b,int c)&#123; to[idx]=b,ne[idx]=h[a],f[idx]=c,h[a]=idx++; to[idx]=a,ne[idx]=h[b],f[idx]=0,h[b]=idx++;&#125;bool bfs()&#123; queue&lt;int&gt;q; memset(d,-1,sizeof d); q.push(S),d[S]=0,cur[S]=h[S]; while(!q.empty())&#123; int t=q.front(); q.pop(); cur[t]=h[t]; for(int i=h[t];~i;i=ne[i])&#123; int ver=to[i]; if(d[ver]==-1&amp;&amp;f[i])&#123; d[ver]=d[t]+1; cur[ver]=h[ver]; if(ver==T)return true; q.push(ver); &#125; &#125; &#125; return false;&#125;int find(int u,int limit)&#123; if(u==T)&#123; return limit; &#125; int flow=0; for(int i=cur[u];~i&amp;&amp;flow&lt;limit;i=ne[i])&#123; int ver=to[i]; cur[u]=i; if(d[ver]==d[u]+1&amp;&amp;f[i])&#123; int t=find(ver,min(f[i],limit-flow)); if(!t)d[ver]=-1; f[i]-=t,f[i^1]+=t,flow+=t; &#125; &#125; return flow;&#125;int dinic()&#123; int r=0,flow; while(bfs())&#123; while(flow=find(S,INF))&#123; r+=flow; &#125; &#125; return r;&#125;int main()&#123; memset(h,-1,sizeof h); cin &gt;&gt; m &gt;&gt; n; n+=m; S=0,T=n+1; for(int i=1;i&lt;=m;i++)&#123; int t; cin &gt;&gt; t; tot+=t; add(S,i,t); &#125; for(int i=m+1;i&lt;=n;i++)&#123; int t; cin &gt;&gt; t; add(i,T,t); &#125; for(int i=1;i&lt;=m;i++)&#123; for(int j=m+1;j&lt;=n;j++)&#123; add(i,j,1); &#125; &#125; if(dinic()==tot)&#123; cout &lt;&lt; 1 &lt;&lt; endl; for(int i=1;i&lt;=m;i++)&#123; for(int j=h[i];~j;j=ne[j])&#123; if(f[j]==0&amp;&amp;j%2==0)cout &lt;&lt; to[j]-m &lt;&lt; &#x27; &#x27;; &#125; cout &lt;&lt; endl; &#125; &#125; else&#123; cout &lt;&lt; 0 &lt;&lt; endl; &#125; return 0;&#125; 上下界可行流无源汇上下界可行流题目：洛谷U409413 无源汇上下界可行流 无源汇上下界可行流题目描述给定一个包含 $ n $ 个点 $ m $ 条边的有向图，每条边都有一个流量下界和流量上界。 求一种可行方案使得在所有点满足流量平衡条件的前提下，所有边满足流量限制。 输入格式第一行包含两个整数 $ n $ 和 $ m $。 接下来 $ m $ 行，每行包含四个整数 $ a,b,c,d $ 表示点 $ a $ 和 $ b $ 之间存在一条有向边，该边的流量下界为 $ c $，流量上界为 $ d $。 点编号从 $ 1 $ 到 $ n $。 输出格式如果存在可行方案，则第一行输出 YES，接下来 $ m $ 行，每行输出一个整数，其中第 $ i $ 行的整数表示输入的第 $ i $ 条边的流量。 如果不存在可行方案，直接输出一行 NO。 如果可行方案不唯一，则输出任意一种方案即可。 样例 #1样例输入 #112345674 61 2 1 32 3 1 33 4 1 34 1 1 31 3 1 34 2 1 3 样例输出 #11234567YES123211 样例 #2样例输入 #212345674 61 2 1 22 3 1 23 4 1 24 1 1 21 3 1 24 2 1 2 样例输出 #21NO 提示数据范围$ 1 \\le n \\le 200 $,$ 1 \\le m \\le 10200 $,$ 1 \\le a,b \\le n $,$ 0 \\le c \\le d \\le 10000 $ 满足每条边的流量在上下界之间，即$c_l(u,v) \\le f(u,v) \\le c_u(u,v)$。 设原网络$G$有可行流$f$，要把$(G,f)$变为$(G’,f’)$。 可以把原式转为$0 \\le f(u,v)-c_l(u,v) \\le c_u(u,v)-c_l(u,v)$，这样容量限制即可满足，但是流量守恒不一定满足。 设$c_入&#x3D;\\sum_{v \\in V}c_l(v,x)$，$c_出&#x3D;\\sum_{v \\in V}c_l(x,v)$，分别表示少进的流量和少出的流量，则增加流入$c_入-c_出$即可满足流量守恒，具体地，若$c_入-c_出&gt;0$，则从源点向当前点连一条容量为$c_入-c_出$的边，否则从当前点向汇点连一条容量为$c_出-c_入$的边。 具体步骤： 将可行流中所有边上的流量量减去流量下界，令新网络的容量变为流量上界减去流量下界 求新流网络中的最大流 将求出的可行流的边的流量加上流量下界 代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;bits/stdc++.h&gt;using namespace std;const int N=205,M=3e4+5,INF=0x3f3f3f3f;int n,m,S,T;int h[N],to[M],ne[M],f[M],l[M],idx;int d[N],cur[N],A[M];//A:表示每个点c入-c出void add(int a,int b,int c,int d)&#123; to[idx]=b,ne[idx]=h[a],f[idx]=d-c,l[idx]=c,h[a]=idx++; to[idx]=a,ne[idx]=h[b],f[idx]=0,h[b]=idx++;&#125;bool bfs()&#123; queue&lt;int&gt;q; memset(d,-1,sizeof d); q.push(S),d[S]=0,cur[S]=h[S]; while(!q.empty())&#123; int t=q.front(); q.pop(); cur[t]=h[t]; for(int i=h[t];~i;i=ne[i])&#123; int ver=to[i]; if(d[ver]==-1&amp;&amp;f[i])&#123; d[ver]=d[t]+1; cur[ver]=h[ver]; if(ver==T)return true; q.push(ver); &#125; &#125; &#125; return false;&#125;int find(int u,int limit)&#123; if(u==T)&#123; return limit; &#125; int flow=0; for(int i=cur[u];~i&amp;&amp;flow&lt;limit;i=ne[i])&#123; int ver=to[i]; cur[u]=i; if(d[ver]==d[u]+1&amp;&amp;f[i])&#123; int t=find(ver,min(f[i],limit-flow)); if(!t)d[ver]=-1; f[i]-=t,f[i^1]+=t,flow+=t; &#125; &#125; return flow;&#125;int dinic()&#123; int r=0,flow; while(bfs())&#123; while(flow=find(S,INF))&#123; r+=flow; &#125; &#125; return r;&#125;int main()&#123; memset(h,-1,sizeof h); cin &gt;&gt; n &gt;&gt; m; S=0,T=n+1; for(int i=0;i&lt;m;i++)&#123; int a,b,c,d; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d; add(a,b,c,d); A[a]-=c,A[b]+=c; &#125; int tot=0; for(int i=1;i&lt;=n;i++)&#123; if(A[i]&gt;0)add(S,i,0,A[i]),tot+=A[i]; else if(A[i]&lt;0)add(i,T,0,-A[i]); &#125; if(dinic()!=tot)cout &lt;&lt; &quot;NO &quot;; else&#123; cout &lt;&lt; &quot;YES &quot;; for(int i=0;i&lt;m*2;i+=2)&#123; cout &lt;&lt; f[i^1]+l[i] &lt;&lt; endl;//注意f[i^1]才是实际流量 &#125; &#125; return 0;&#125; 有源汇上下界最大&#x2F;最小流在无源汇上下界可行流的基础上增加了两个限制：有源点和汇点，求最大可行流。 首先考虑第一个限制，有源点和汇点，则可以从汇点向源点连一条容量为正无穷的边，这样原图转化为无源汇的图。 再考虑第二个限制，对于原图$G$的一个可行流$f_0$，可以将$(G,f_0)$变为新图$(G’,f_0’)$，在新流的残留网络$G’{f_0’}$中存在从$s$到$t$（原图的源点和汇点）流的量，也就是之前增加的从$t$到$s$的虚边的流量，记作$f’{0,s \\to t}$。在$s$到$t$中任取一个可行流$f’{s \\to t}$，可以发现，原图$G$的每一个答案对应一个$|f’{0,s \\to t}+f’{s \\to t}|$，而$|f’{0,s \\to t}+f’{s \\to t}|&#x3D;|f’{0,s \\to t}|+|f’{s \\to t}|$，其中$|f’{0,s \\to t}|$是固定的，因此只需$|f’_{s \\to t}|$最大&#x2F;最小即可。最大直接求即可，而最小等价于求$t$到$s$的最大流。 有源汇上下界最大流 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;bits/stdc++.h&gt;using namespace std;const int N=205,M=3e4+5,INF=0x3f3f3f3f;int n,m,S,T,s,t;int h[N],to[M],ne[M],f[M],idx;int d[N],cur[N],A[M];void add(int a,int b,int c,int d)&#123; to[idx]=b,ne[idx]=h[a],f[idx]=d-c,h[a]=idx++; to[idx]=a,ne[idx]=h[b],f[idx]=0,h[b]=idx++;&#125;bool bfs()&#123; queue&lt;int&gt;q; memset(d,-1,sizeof d); q.push(S),d[S]=0,cur[S]=h[S]; while(!q.empty())&#123; int t=q.front(); q.pop(); cur[t]=h[t]; for(int i=h[t];~i;i=ne[i])&#123; int ver=to[i]; if(d[ver]==-1&amp;&amp;f[i])&#123; d[ver]=d[t]+1; cur[ver]=h[ver]; if(ver==T)return true; q.push(ver); &#125; &#125; &#125; return false;&#125;int find(int u,int limit)&#123; if(u==T)&#123; return limit; &#125; int flow=0; for(int i=cur[u];~i&amp;&amp;flow&lt;limit;i=ne[i])&#123; int ver=to[i]; cur[u]=i; if(d[ver]==d[u]+1&amp;&amp;f[i])&#123; int t=find(ver,min(f[i],limit-flow)); if(!t)d[ver]=-1; f[i]-=t,f[i^1]+=t,flow+=t; &#125; &#125; return flow;&#125;int dinic()&#123; int r=0,flow; while(bfs())&#123; while(flow=find(S,INF))&#123; r+=flow; &#125; &#125; return r;&#125;int main()&#123; memset(h,-1,sizeof h); cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t; S=0,T=n+1; for(int i=0;i&lt;m;i++)&#123; int a,b,c,d; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d; add(a,b,c,d); A[a]-=c,A[b]+=c; &#125; int tot=0; for(int i=1;i&lt;=n;i++)&#123; if(A[i]&gt;0)add(S,i,0,A[i]),tot+=A[i]; else if(A[i]&lt;0)add(i,T,0,-A[i]); &#125; add(t,s,0,INF);//增加虚边，转化成无源汇图 if(dinic()&lt;tot)cout &lt;&lt; &quot;No Solution &quot;; else&#123; int res=f[idx-1];//f&#x27;_&#123;0,s -&gt; t&#125; S=s,T=t; f[idx-1]=f[idx-2]=0; cout &lt;&lt; dinic()+res; &#125; return 0;&#125; 有源汇上下界最小流 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;bits/stdc++.h&gt;using namespace std;const int N=5e4+5,M=5e5+5,INF=2147483647;int n,m,S,T,s,t;int h[N],to[M],ne[M],f[M],idx;int d[N],cur[N],A[M];void add(int a,int b,int c,int d)&#123; to[idx]=b,ne[idx]=h[a],f[idx]=d-c,h[a]=idx++; to[idx]=a,ne[idx]=h[b],f[idx]=0,h[b]=idx++;&#125;bool bfs()&#123; queue&lt;int&gt;q; memset(d,-1,sizeof d); q.push(S),d[S]=0,cur[S]=h[S]; while(!q.empty())&#123; int t=q.front(); q.pop(); cur[t]=h[t]; for(int i=h[t];~i;i=ne[i])&#123; int ver=to[i]; if(d[ver]==-1&amp;&amp;f[i])&#123; d[ver]=d[t]+1; cur[ver]=h[ver]; if(ver==T)return true; q.push(ver); &#125; &#125; &#125; return false;&#125;int find(int u,int limit)&#123; if(u==T)&#123; return limit; &#125; int flow=0; for(int i=cur[u];~i&amp;&amp;flow&lt;limit;i=ne[i])&#123; int ver=to[i]; cur[u]=i; if(d[ver]==d[u]+1&amp;&amp;f[i])&#123; int t=find(ver,min(f[i],limit-flow)); if(!t)d[ver]=-1; f[i]-=t,f[i^1]+=t,flow+=t; &#125; &#125; return flow;&#125;int dinic()&#123; int r=0,flow; while(bfs())&#123; while(flow=find(S,INF))&#123; r+=flow; &#125; &#125; return r;&#125;int main()&#123; memset(h,-1,sizeof h); cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t; S=0,T=n+1; for(int i=0;i&lt;m;i++)&#123; int a,b,c,d; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d; add(a,b,c,d); A[a]-=c,A[b]+=c; &#125; int tot=0; for(int i=1;i&lt;=n;i++)&#123; if(A[i]&gt;0)add(S,i,0,A[i]),tot+=A[i]; else if(A[i]&lt;0)add(i,T,0,-A[i]); &#125; add(t,s,0,INF); if(dinic()&lt;tot)cout &lt;&lt; &quot;No Solution &quot;; else&#123; int res=f[idx-1]; S=t,T=s;//不同点1:求t到s的最大流 f[idx-1]=f[idx-2]=0; cout &lt;&lt; res-dinic();//不同点2:由于t到s的最大流为负数，所以是减去(f_&#123;s-&gt;t&#125;=-f_&#123;t-&gt;s&#125;)) &#125; return 0;&#125; 多源汇最大流有多个源点和汇点，直接建立一个超级源点和一个超级汇点，从超级源点向每个源点连出一条容量为正无穷的边，从每个汇点向超级汇点连出一个容量为正无穷的边即可。 题目：U409708 多源汇最大流 多源汇最大流题目描述给定一个包含 $ n $ 个点 $ m $ 条边的有向图，并给定每条边的容量，边的容量非负。 其中有 $ S_c $ 个源点，$ T_c $ 个汇点。 图中可能存在重边和自环。 求整个网络的最大流。 输入格式第一行包含四个整数 $ n,m,S_c,T_c $。 第二行包含 $ S_c $ 个整数，表示所有源点的编号。 第三行包含 $ T_c $ 个整数，表示所有汇点的编号。 接下来 $ m $ 行，每行三个整数 $ u,v,c $，表示从点 $ u $ 到点 $ v $ 存在一条有向边，容量为 $ c $。 点的编号从 $ 1 $ 到 $ n $。 输出格式输出一个整数表示整个网络的最大流。 样例 #1样例输入 #1123456784 5 2 22 41 34 2 304 3 202 3 202 1 301 3 40 样例输出 #1170 提示数据范围$ 2 \\le n \\le 10000 $,$ 1 \\le m \\le 10^5 $,$ 0 \\le c \\le 10000 $,保证源点集合和汇点集合没有交集。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;bits/stdc++.h&gt;using namespace std;const int N=1e4+5,M=3e5+5,INF=0x3f3f3f3f;int n,m,S,T;int h[N],to[M],f[M],ne[M],idx;int d[N],cur[N];void add(int a,int b,int c)&#123; to[idx]=b,f[idx]=c,ne[idx]=h[a],h[a]=idx++; to[idx]=a,f[idx]=0,ne[idx]=h[b],h[b]=idx++;&#125;bool bfs()&#123; queue&lt;int&gt;q; memset(d,-1,sizeof d); q.push(S),d[S]=0,cur[S]=h[S]; while(!q.empty())&#123; int t=q.front(); q.pop(); for(int i=h[t];~i;i=ne[i])&#123; int ver=to[i]; if(d[ver]==-1&amp;&amp;f[i])&#123; d[ver]=d[t]+1; cur[ver]=h[ver]; if(ver==T)return true; q.push(ver); &#125; &#125; &#125; return false;&#125;int find(int u,int limit)&#123; if(u==T)return limit; int flow=0; for(int i=cur[u];~i&amp;&amp;flow&lt;limit;i=ne[i])&#123; cur[u]=i; int ver=to[i]; if(d[ver]==d[u]+1&amp;&amp;f[i])&#123; int t=find(ver,min(f[i],limit-flow)); if(!t)d[ver]=-1; f[i]-=t,f[i^1]+=t,flow+=t; &#125; &#125; return flow;&#125;int dinic()&#123; int r=0,flow; while(bfs())&#123; while(flow=find(S,INF))&#123; r+=flow; &#125; &#125; return r;&#125;int main()&#123; int sc,tc; cin &gt;&gt; n &gt;&gt; m &gt;&gt; sc &gt;&gt; tc; memset(h,-1,sizeof h); S=0,T=n+1; for(int i=1;i&lt;=sc;i++)&#123; int x; cin &gt;&gt; x; add(S,x,INF); &#125; for(int i=1;i&lt;=tc;i++)&#123; int x; cin &gt;&gt; x; add(x,T,INF); &#125; for(int i=1;i&lt;=m;i++)&#123; int a,b,c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; add(a,b,c); &#125; cout &lt;&lt; dinic() &lt;&lt; endl; return 0;&#125; 关键边关键边：当增加这条边的容量时网络流的最大流会增加。 当求出一个网络流的最大可行流时，不难看出只有当一条边的流量等于流量时，即$f(u,v)&#x3D;c(u,v)$时，这条边才有可能成为关键边，并且需要在图$G_f$中存在$s \\to u$和$v \\to t$的路径时这条边才是关键边。 具体做法： 求出原图的一个最大可行流 在残留网络中求出所有源点能到的点，从汇点反向搜索能反向到达的边 枚举所有边，判断是否满足要求 例题：洛谷U409910 伊基的故事 I - 道路重建 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;bits/stdc++.h&gt;using namespace std;const int N=505,M=1e4+5,INF=0x3f3f3f3f;int n,m,S,T;int h[N],to[M],f[M],ne[M],idx;int d[N],cur[N];bool vis_s[N],vis_t[N];void add(int a,int b,int c)&#123; to[idx]=b,f[idx]=c,ne[idx]=h[a],h[a]=idx++; to[idx]=a,f[idx]=0,ne[idx]=h[b],h[b]=idx++;&#125;bool bfs()&#123; queue&lt;int&gt;q; memset(d,-1,sizeof d); q.push(S),d[S]=0,cur[S]=h[S]; while(!q.empty())&#123; int t=q.front(); q.pop(); for(int i=h[t];~i;i=ne[i])&#123; int ver=to[i]; if(d[ver]==-1&amp;&amp;f[i])&#123; d[ver]=d[t]+1; cur[ver]=h[ver]; if(ver==T)return true; q.push(ver); &#125; &#125; &#125; return false;&#125;int find(int u,int limit)&#123; if(u==T)return limit; int flow=0; for(int i=cur[u];~i&amp;&amp;flow&lt;limit;i=ne[i])&#123; cur[u]=i; int ver=to[i]; if(d[ver]==d[u]+1&amp;&amp;f[i])&#123; int t=find(ver,min(f[i],limit-flow)); if(!t)d[ver]=-1; f[i]-=t,f[i^1]+=t,flow+=t; &#125; &#125; return flow;&#125;int dinic()&#123; int r=0,flow; while(bfs())&#123; while(flow=find(S,INF))&#123; r+=flow; &#125; &#125; return r;&#125;void dfs(int u,bool st[],int t)&#123; st[u]=true; for(int i=h[u];~i;i=ne[i])&#123; int j=i^t,ver=to[i]; if(f[j]&amp;&amp;!st[ver])&#123; dfs(ver,st,t); &#125; &#125;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; S=0,T=n-1; memset(h,-1,sizeof h); for(int i=1;i&lt;=m;i++)&#123; int a,b,c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; add(a,b,c); &#125; dinic(); dfs(S,vis_s,0); dfs(T,vis_t,1); int res=0; for(int i=0;i&lt;m*2;i+=2)&#123; if(!f[i]&amp;&amp;vis_s[to[i^1]]&amp;&amp;vis_t[to[i]])&#123; res++; &#125; &#125; cout &lt;&lt; res; return 0;&#125; 最小割由于任意的$|f|\\le c(S,T)$，即流小于等于割，因此 一定存在最大流等于最小割，直接求最大流即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;bits/stdc++.h&gt;using namespace std;#pragma GCC optimize(2)const int N=1e4+5,M=2e5+5,INF=0x3f3f3f3f;int n,m,S,T;int h[N],ne[M],to[M],f[M],idx;int d[N],cur[N];void add(int a,int b,int c)&#123; to[idx]=b,ne[idx]=h[a],f[idx]=c,h[a]=idx++; to[idx]=a,ne[idx]=h[b],f[idx]=0,h[b]=idx++;&#125;bool bfs()&#123; queue&lt;int&gt;q; memset(d,-1,sizeof d); q.push(S),d[S]=0,cur[S]=h[S]; while(!q.empty())&#123; int t=q.front(); q.pop(); for(int i=h[t];~i;i=ne[i])&#123; int ver=to[i]; if(d[ver]==-1&amp;&amp;f[i])&#123; d[ver]=d[t]+1; cur[ver]=h[ver]; if(ver==T)return true; q.push(ver); &#125; &#125; &#125; return false;&#125;int find(int u,int limit)&#123; if(u==T)return limit; int flow=0; for(int i=h[u];~i&amp;&amp;flow&lt;limit;i=ne[i])&#123; cur[u]=i; int ver=to[i]; if(d[ver]==d[u]+1&amp;&amp;f[i])&#123; int t=find(ver,min(f[i],limit-flow)); if(!t)d[ver]=-1; f[i]-=t,f[i^1]+=t,flow+=t; &#125; &#125; return flow;&#125;int dinic()&#123; int res=0,flow; while(bfs())&#123; while(flow=find(S,INF))res+=flow; &#125; return res;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0),cout.tie(0); cin &gt;&gt; n &gt;&gt; m &gt;&gt; S &gt;&gt; T; memset(h,-1,sizeof h); while(m--)&#123; int a,b,c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; add(a,b,c); &#125; cout &lt;&lt; dinic(); return 0;&#125; 费用流一种实现思路：把EK算法的bfs换成SPFA即可。 模板：最小费用最大流 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;bits/stdc++.h&gt;using namespace std;const int N=5005,M=1e5+5,INF=0x3f3f3f3f;int n,m,S,T;int h[N],ne[M],to[M],f[M],w[M],idx;int d[N],pre[N],incf[N];bool st[N];void add(int a,int b,int c,int d)&#123; to[idx]=b,ne[idx]=h[a],f[idx]=c,w[idx]=d,h[a]=idx++; to[idx]=a,ne[idx]=h[b],f[idx]=0,w[idx]=-d,h[b]=idx++;&#125;bool spfa()&#123; queue&lt;int&gt;q; memset(d,0x3f,sizeof d); incf[T]=0; q.push(S),d[S]=0,incf[S]=INF; while(!q.empty())&#123; int t=q.front(); q.pop(); st[t]=false; for(int i=h[t];~i;i=ne[i])&#123; int ver=to[i]; if(f[i]&amp;&amp;d[ver]&gt;d[t]+w[i])&#123; d[ver]=d[t]+w[i]; pre[ver]=i; incf[ver]=min(f[i],incf[t]); if(!st[ver])&#123; q.push(ver); st[ver]=true; &#125; &#125; &#125; &#125; return incf[T]&gt;0;&#125;void EK(int &amp;flow,int &amp;cost)&#123; flow=cost=0; while(spfa())&#123; int t=incf[T]; flow+=t,cost+=t*d[T]; for(int i=T;i!=S;i=to[pre[i]^1])&#123; f[pre[i]]-=t; f[pre[i]^1]+=t; &#125; &#125;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0),cout.tie(0); memset(h,-1,sizeof h); cin &gt;&gt; n &gt;&gt; m &gt;&gt; S &gt;&gt; T; for(int i=1;i&lt;=m;i++)&#123; int a,b,c,d; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d; add(a,b,c,d); &#125; int flow,cost; EK(flow,cost); cout &lt;&lt; flow &lt;&lt; &#x27; &#x27; &lt;&lt; cost &lt;&lt; endl; return 0;&#125; 注意：这种算法无法处理存在负环的情况"},{"title":"线段树","path":"/2024/07/25/线段树/","content":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e6+5;typedef long long ll;ll a[maxn],w[maxn*4];void pushup(const int u)&#123; w[u]=w[u*2]+w[u*2+1];&#125;//建立线段树void build(const int u,int L,int R)&#123; if(L==R)&#123; w[u]=a[L]; return; &#125; int M=(L+R)/2; build((u*2),L,M); build((u*2)+1,M+1,R); pushup(u);&#125;//懒标记ll lzy[maxn*4];void maketag(int u,int len,ll x)&#123; lzy[u]+=x; w[u]+=len*x;&#125;void pushdown(int u,int L,int R)&#123; int M=(L+R)/2; maketag(u*2,M-L+1,lzy[u]); maketag(u*2+1,R-M,lzy[u]); lzy[u]=0;&#125;//单点查询修改ll query1(int u,int L,int R,int p)&#123; pushdown(u,L,R); if(L==R)&#123; return w[u]; &#125; else &#123; int M=(L+R)/2; if(M&gt;=p) return query1((u*2),L,M,p); else return query1((u*2)+1,M+1,R,p); &#125; return 0;&#125;void update1(int u,int L,int R,int p,ll x)&#123; if(L==R)&#123; w[u]=x; &#125; else&#123; int M=(L+R)/2; if(M&gt;=p) update1((u*2),L,M,p,x); else update1((u*2)+1,M+1,R,p,x); pushup(u); &#125;&#125;//区间查询bool InRange(int L,int R,int l,int r)&#123; return (l&lt;=L)&amp;&amp;(R&lt;=r);&#125;bool OutofRange(int L,int R,int l,int r)&#123; return (L&gt;r)||(R&lt;l);&#125;ll query(int u,int L,int R,int l,int r)&#123; if(InRange(L,R,l,r))&#123; return w[u]; &#125; if(OutofRange(L,R,l,r)) return 0; else&#123; int M=(L+R)/2; pushdown(u,L,R); return query((u*2),L,M,l,r)+query((u*2)+1,M+1,R,l,r); &#125; return 0;&#125;//修改void update(int u,int L,int R,int l,int r,ll x)&#123; if(InRange(L,R,l,r))&#123; maketag(u,R-L+1,x); &#125; else if(!OutofRange(L,R,l,r))&#123; int M=(L+R)/2; pushdown(u,L,R); update((u*2),L,M,l,r,x); update((u*2)+1,M+1,R,l,r,x); pushup(u); &#125;&#125;int main()&#123; ios::sync_with_stdio(false); int n,m; cin &gt;&gt; n &gt;&gt; m; for(int i=1;i&lt;=n;i++)&#123; cin &gt;&gt; a[i];//输入每一项的值 &#125; build(1,1,n);//建立线段树 for(int t=1;t&lt;=m;t++)&#123; int op,x,y; ll k; cin &gt;&gt; op; if(op==1)&#123; cin &gt;&gt; x &gt;&gt; y &gt;&gt; k; update(1,1,n,x,y,k);//修改，x到y加k &#125; else&#123; cin &gt;&gt; x &gt;&gt; y; cout &lt;&lt; query(1,1,n,x,y) &lt;&lt; endl;//查询x到y &#125; &#125; return 0;&#125;"},{"title":"线性基","path":"/2024/07/25/线性基/","content":"线性基向量组：$x_1,x_2,\\cdots,x_k$ 线性空间：${a_1x_1+a_2x_2+\\cdots + a_kx_k| a_i \\in \\R }$ 线性空间是向量组的生成子空间，向量组是线性空间的生成子集 线性相关：$x_1$到$x_k$中某个向量$x_m$能被其他向量表示出来，即$x_m&#x3D;a_1x_1+a_2x_2+\\cdots+a_kx_k$，则向量组是线性相关的。 线性无关：$x_1$到$x_k$中任一向量不能能被其他向量表示出来，则向量组是线性无关的。 若一个向量组是线性无关的，则这个向量组是对应线性空间的基底，简称基，向量组的向量数量称为线性空间的维数。 若两个向量组${x_1,x_2,\\cdots,x_n},{y_1,y_2,\\cdots,y_m}$是等价的，则其中一个向量组的所有向量可以被另一个向量组表示出来，即$x_i&#x3D;a_{i,1} y_1+a_{i,2}y_2+\\cdots+a_{i,m}y_m,y_i&#x3D;b_{i,1} x_1+b_{i,2}x_2+\\cdots+b_{i,n}x_n$。 若要找出向量组 ${x_1,x_2,\\cdots ,x_k}$ （不一定线性无关）的生成子空间的基，则可以使用高斯消元。 需要找出向量组的极大线性无关组，即找出最多的元素使得它们组成的向量组线性无关。通过高斯消元可以将向量组组成的矩阵消成上三角矩阵，则这些向量构成一组基，可以证明，基的数量一定小于等于 $d$ 个（ $d$ 表示向量的维度），因此查询时可以优化时间复杂度。 模板题：洛谷 P3812 【模板】线性基&#x2F;AcWing 3164. 线性基 给定 $ n $ 个整数（可能重复），现在需要从中挑选任意个整数，使得选出整数的异或和最大。 请问，这个异或和的最大可能值是多少。 输入格式第一行一个整数 $ n $。 第二行包含 $ n $ 个整数。 输出格式输出一个整数，表示所选整数的异或和的最大可能值。 数据范围$ 1 \\le n \\le 10^5 $,$ 0 \\le S_i \\le 2^{63}-1 $ 输入样例：1235 2 8 输出样例：115 分析： 首先按位使用高斯消元求出基底，并使得基底的每个向量只有除了最高位都为零，则答案就是所有基底的异或和 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N=1e5+5;int n;ll a[N];int main()&#123; cin &gt;&gt; n; for(int i=1;i&lt;=n;i++)&#123; cin &gt;&gt; a[i]; &#125; int k=1;//高斯消元 for(int i=62;i&gt;=0;i--)&#123; for(int j=k;j&lt;=n;j++)&#123; if(a[j]&gt;&gt;i&amp;1)&#123; swap(a[j],a[k]); break; &#125; &#125; if(!(a[k]&gt;&gt;i&amp;1))continue; for(int j=1;j&lt;=n;j++)&#123; if(j!=k&amp;&amp;(a[j]&gt;&gt;i&amp;1))&#123; a[j]^=a[k]; &#125; &#125; k++; if(k&gt;n) break; &#125; ll res=0; for(int i=1;i&lt;=k;i++)&#123; res^=a[i]; &#125; cout &lt;&lt; res; return 0;&#125; 例题：AcWing 210. 异或运算 给定你由 $ N $ 个整数构成的整数序列，你可以从中选取一些（至少一个）进行异或（$ \\operatorname{xor} $）运算，从而得到很多不同的结果。 请问，所有能得到的不同的结果中第 $ k $ 小的结果是多少。 输入格式第一行包含整数 $ T $，表示共有 $ T $ 组测试数据。 对于每组测试数据，第一行包含整数 $ N $。 第二行包含 $ N $ 个整数(均在 $ 1 $ 至 $ 10^{18} $ 之间)，表示完整的整数序列。 第三行包含整数 $ Q $，表示询问的次数。 第四行包含 $ Q $ 个整数 $ k_1,k_2,…,k_Q $，表示 $ Q $ 个询问对应的 $ k $。 输出格式对于每组测试数据，第一行输出 Case #C:，其中 $ C $ 为顺序编号（从 $ 1 $ 开始）。 接下来 $ Q $ 行描述 $ Q $ 次询问的结果，每行输出一个整数，表示第 $ i $ 次询问中第 $ k_i $ 小的结果。 如果能得到的不同结果的总数少于 $ k_i $，则输出 $ -1 $。 数据范围$ 1 \\le N,Q \\le 10000 $,$ 1 \\le k_i \\le 10^{18} $ 输入样例：123456789221 241 2 3 431 2 351 2 3 4 5 输出样例：1234567891011Case #1:123-1Case #2:0123-1 注意:只选取一个数字进行运算，则结果为该数字本身。"},{"title":"约数","path":"/2024/07/25/约数/","content":"约数试除法求约数只需枚举小于$\\sqrt{n}$的约数就可求出所有约数 1234567891011vector&lt;int&gt;res;void get_div(int n)&#123; res.clear(); for(int i=1;i&lt;=n/i;i++)&#123; if(n%i==0)&#123; res.push_back(i); if(i!=n/i)res.push_back(n/i);//判断平方 &#125; &#125; sort(res.begin(),res.end());&#125; 约数个数若$n&#x3D;p_1^{\\alpha_1}\\cdot p_2^{\\alpha_2}\\cdot… \\cdot p_k^{\\alpha_k}$ 则约数个数$d(n)&#x3D;(\\alpha_1+1)\\cdot(\\alpha_2+1)\\cdot…\\cdot(\\alpha_k+1)$ int范围内约数个数最多的数约有1600个约数。 约数之和若$n&#x3D;p_1^{\\alpha_1}\\cdot p_2^{\\alpha_2}\\cdot… \\cdot p_k^{\\alpha_k}$ 约数之和$\\sigma(n)&#x3D;(p_1^0+p_1^1+…+p_1^{\\alpha_1})\\cdot…\\cdot(p_k^0+p_k^1+…+p_k^{\\alpha_k})$ 欧几里得算法（辗转相除法）性质：若$d|a，d|b$,则$d|ax+by$ 定理：$(a,b)&#x3D;(b,a$ $mod$ $b)$ 证明：$(a,b) $$&#x3D; (b,a-\\lfloor \\frac a b\\rfloor \\cdot b)&#x3D;(b,a-c\\cdot b)$$&#x3D;(b,a$ $mod$ $b)$ 实现：若$b&#x3D;0$则$a$为最大公约数，否则返回$gcd(b,a%b)$ 123int gcd(int a,int b)&#123; return b?gcd(b,a%b):a;&#125;"},{"title":"积性函数","path":"/2024/07/25/积性函数/","content":"积性函数定义$\\forall (a,b)&#x3D;1,f(ab)&#x3D;f(a)f(b)$ 常见的积性函数欧拉函数 $\\varphi(x)$，莫比乌斯函数 $\\mu(x)$，最大公因数 $\\gcd(x,k)$($k$固定)，正因子数目 $d(x)$ ，正因子之和 $\\sigma(x)$，常函数，单位函数 $Id(x)&#x3D;x$，幂函数 $Idk(x) &#x3D;n ^ k$，等 下面以莫比乌斯函数和欧拉函数为例证明积性函数： 莫比乌斯函数证明： 设$a&#x3D;p_1^{\\alpha_1} p_2^{\\alpha_2} \\cdots p_k^{\\alpha_k}$，$b&#x3D;q_1^{\\beta_1} q_2^{\\beta_2} \\cdots q_k^{\\beta_t}$ ，$ab&#x3D;p_1^{\\alpha_1} p_2^{\\alpha_2} \\cdots p_k^{\\alpha_k}q_1^{\\beta_1} \\cdots q_k^{\\beta_t}$若 $ \\exists \\alpha_i \\ge 2$，则$\\mu(a)&#x3D;\\mu(ab)&#x3D;0$，成立，同理，若 $\\exists \\beta_i \\ge 2$ 也成立。 若 $\\forall \\alpha_i,\\beta_i&#x3D;1$，则$\\mu(a)&#x3D;(-1)^k,\\mu(b)&#x3D;(-1)^t,\\mu(ab)&#x3D;(-1)^{k+t}$，满足 $\\mu(ab)&#x3D;\\mu(a)\\mu(b)$。 综上，莫比乌斯函数是积性函数。 欧拉函数证明： $\\varphi(n)&#x3D;n\\prod_{i&#x3D;1}^k(1-\\frac 1 {p_i})$ 设$a&#x3D;p_1^{\\alpha_1} p_2^{\\alpha_2} \\cdots p_k^{\\alpha_k}$，$b&#x3D;q_1^{\\beta_1} q_2^{\\beta_2} \\cdots q_k^{\\beta_t}$ ，$ab&#x3D;p_1^{\\alpha_1} p_2^{\\alpha_2} \\cdots p_k^{\\alpha_k}q_1^{\\beta_1} \\cdots q_k^{\\beta_t}$ $\\varphi(a)&#x3D;a\\prod_{i&#x3D;1}^k(1-\\frac 1 {p_i})$，$\\varphi(b)&#x3D;b\\prod_{i&#x3D;1}^t(1-\\frac 1 {q_i})$ $\\varphi(ab)&#x3D;ab\\prod_{i&#x3D;1}^k(1-\\frac 1 {p_i})\\prod_{i&#x3D;1}^t(1-\\frac 1 {q_i})&#x3D;[a\\prod_{i&#x3D;1}^k(1-\\frac 1 {p_i})][b\\prod_{i&#x3D;1}^t(1-\\frac 1 {q_i})]&#x3D;\\varphi(a)\\varphi(b)$ 所以，欧拉函数是积性函数。 例题：洛谷 P2303 [SDOI2012] Longge 的问题&#x2F;AcWing 221. 龙哥的问题 龙哥现在有一道题，要考考大家。 给定一个整数 $ N $，请你求出 $ \\sum_{1 \\le i \\le N} gcd(i，N) $的值。 输入格式一个整数 $ N $。 输出格式一个整数表示结果。 数据范围$ 1 &lt; N &lt; 2^{31} $ 输入样例：16 输出样例：115 分析： 考虑满足 $(i,n)&#x3D;d$ 的 $i$ 共多少种。 $(i,n)&#x3D;d \\Longleftrightarrow (\\frac i d,\\frac n d)&#x3D;1$ 记 $i’&#x3D; \\frac i d,n’&#x3D;\\frac n d$，则原式等价于 $(i’,n’)&#x3D;1$，因此满足条件的 $i$ 有 $\\varphi(n’)&#x3D;\\varphi(\\frac n d)$ 种，所以： $\\sum_{i&#x3D;1}^n(i,n)&#x3D;\\sum_{d|n} d\\cdot \\varphi(\\frac n d) $ $d,\\frac n d$ 两两配对，记 $d’&#x3D;\\frac n d$ $\\sum_{d|n} d\\cdot \\varphi(\\frac n d)&#x3D;\\sum_{d’|n} \\frac n d’ \\cdot \\varphi(d’)&#x3D;\\sum_{d|n} \\frac n d d \\prod_{i&#x3D;1}^{k}(1-\\frac 1 {p_i})&#x3D;n\\sum_{d|n}\\prod_{i&#x3D;1}^k(1-\\frac 1 {p_i})$ 设 $n&#x3D;p_1^{\\alpha_1}p_2^{\\alpha_2}\\cdots p_k^{\\alpha_k},d&#x3D;p_1^{\\beta_1}p_2^{\\beta_2}\\cdots p_k^{\\beta_k}$ 则所有约数就是 $(p_1^0+p_1^1+\\cdots + p_1^{\\alpha_1})(p_2^0+p_2^1+\\cdots + p_2^{\\alpha_2})\\cdots(p_k^0+p_k^1+\\cdots + p_k^{\\alpha_k})$ 展开的每一项，$[1+(1-\\frac 1 {p_1})+(1-\\frac 1 {p_1})+\\cdots][1+(1-\\frac 1 {p_2})+\\cdots]\\cdots[1+(1-\\frac 1 {p_k})+\\cdots]$ 展开的每一项就是前一个式子每一项对应约数对应的 $\\prod_{i&#x3D;1}^k(1-\\frac 1 {p_i})$ 的值，而 $\\sum_{d|n}\\prod_{i&#x3D;1}^k(1-\\frac 1 {p_i})$ 对应的就是所有约数的对应 $\\prod_{i&#x3D;1}^k(1-\\frac 1 {p_i})$ 之和，也就是 $[1+(1-\\frac 1 {p_1})+(1-\\frac 1 {p_1})+\\cdots][1+(1-\\frac 1 {p_2})+\\cdots]\\cdots[1+(1-\\frac 1 {p_k})+\\cdots]$ $[1+(1-\\frac 1 {p_1})+(1-\\frac 1 {p_1})+\\cdots][1+(1-\\frac 1 {p_2})+\\cdots]\\cdots[1+(1-\\frac 1 {p_k})+\\cdots]&#x3D;\\prod_{i&#x3D;1}^k (1+\\alpha_i(1-\\frac 1 {p_i}))$ 所以原式就是 $n\\prod_{i&#x3D;1}^k (1+\\alpha_i(1-\\frac 1 {p_i}))&#x3D;n\\prod_{i&#x3D;1}^k \\frac{p_i+p_i\\alpha_i-\\alpha_i}{p_i}$ 1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main()&#123; ll n; cin &gt;&gt; n; ll res=n; for(ll i=2;i&lt;=n/i;i++)&#123; if(n%i==0)&#123; ll a=0,p=i; while(n%p==0)a++,n/=p; res=res*(p+1ll*a*p-a)/p; &#125; &#125; if(n&gt;1)&#123; res=res*(n+n-1)/n; &#125; cout &lt;&lt; res &lt;&lt; endl; return 0;&#125;"},{"title":"离散化","path":"/2024/07/25/离散化/","content":"离散化整数，有序数列的离散化 作用：将值域很大，个数很少的$n$个数映射到$[1,n]$ 问题： 原数组$a$中可能有重复元素：去重 如何算出$a[i]$离散化后的值：二分(原数组有序) 代码实现： 1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;const int N=1e5+5;int n,a[N];int find(int x)&#123; int l=1,r=n; while(l&lt;r)&#123; int mid=l+r&gt;&gt;1; if(a[mid]&gt;=x)r=mid; else l=mid+1; &#125; if(a[l]==x)return l; return -1;&#125;int main()&#123; cin &gt;&gt; n; for(int i=1;i&lt;=n;i++)&#123; cin &gt;&gt; a[i]; &#125; sort(a+1,a+n+1); n=unique(a+1,a+n+1)-(a+1); return 0;&#125; 例题：共$n$次修改，每次把位置$x$加上$c$，$m$次询问，每次求出区间$[l,r]$的和。其中$-10^9\\le x,l,r\\le 10^9,1\\le n,m \\le 10^5$ 分析：观察到值域非常大，而数的个数较小，于是使用离散化。输入时记录所有用的的数，并进行离散化，记录所有的操作，离散化后用$find$函数在新数组中修改，又因为题目要求区间和，可以用前缀和，于是在离散化后的数组中进行前缀和，输出时求离散化完的前缀和。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int,int&gt;PII;const int N=3e5+5;int n,m;int a[N],s[N];int alls[N];int sz;PII add[N],query[N];int find(int x)&#123; int l=1,r=sz; while(l&lt;r)&#123; int mid=l+r&gt;&gt;1; if(alls[mid]&gt;=x)r=mid; else l=mid+1; &#125; return l;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i=1;i&lt;=n;i++)&#123; int x,c; cin &gt;&gt; x &gt;&gt; c; add[i]=&#123;x,c&#125;; alls[i]=x; sz++; &#125; for(int i=1;i&lt;=m;i++)&#123; int l,r; cin &gt;&gt; l &gt;&gt; r; query[i]=&#123;l,r&#125;; alls[n+i*2-1]=l; alls[n+i*2]=r; sz+=2; &#125; sort(alls+1,alls+n+m*2+1); sz=unique(alls+1,alls+n+m*2+1)-(alls+1); for(int i=1;i&lt;=n;i++)&#123; int x=find(add[i].first); a[x]+=add[i].second; &#125; for(int i=1;i&lt;=alls[sz];i++)&#123; s[i]=s[i-1]+a[i]; cout &lt;&lt; s[i] &lt;&lt; &#x27; &#x27;; &#125; for(int i=1;i&lt;=m;i++)&#123; cout &lt;&lt; s[find(query[i].second)]-s[find(query[i].first)-1] &lt;&lt; endl; &#125; return 0;&#125;"},{"title":"生成函数","path":"/2024/07/25/生成函数/","content":"生成函数给定一个无穷序列 $a_0,a_1,a_2,\\cdots,a_n,\\cdots$ 定义一个函数 $g(x)&#x3D;a_0+a_1x+a_2x^2+\\cdots+a_nx^n+\\cdots ,-1&lt;x&lt;1$ ，则 $g(x)$ 称为序列的一个生成函数 生成函数就是将序列映射到多项式上，这样就可以用函数和多项式的相关方法计算序列 例：有三个砝码，重量分别为 1g,2g,3g ，问一共可以凑出那些重量，每个重量有多少种凑出方式 乘法原理 $\\Longleftrightarrow$ 多项式乘法 对于第一个砝码，重量为 0 有一种选择，重量为 1 有一种选择，其余为零种选择，因此其对应的序列中 $a_0&#x3D;1,a_1&#x3D;1,a_2&#x3D;a_3&#x3D;\\cdots&#x3D;0$，其对应的生成函数 $f_1(x)&#x3D;1+x$ 对于第二个砝码 $a_0&#x3D;a_2&#x3D;1$，其对应的生成函数 $f_2(x)&#x3D;1+x^2$ 对于第三个砝码 $a_0&#x3D;a_3&#x3D;1$，其对应的生成函数 $f_3(x)&#x3D;1+x^3$ 整体的生成函数 $f(x)&#x3D;f_1(x)f_2(x)f_3(x)&#x3D;(1+x)(1+x^2)(1+x^3)&#x3D;1+x+x^2+2x^3+x^4+x^5+x^6$ $a_0&#x3D;1,a_1&#x3D;1,a_2&#x3D;1,a_3&#x3D;2,a_4&#x3D;1,a_5&#x3D;1,a_6&#x3D;1$，因此凑出来 0,1,2,4,5,6 的方案数为 1，凑出来 3 的方案数为 2 生成函数求解思路：原问题 $\\to$ 若干个子问题 $\\to$ 子问题序列 $\\to$ 子问题生成函数 $\\to$ 原问题生成函数 $\\to$ 原问题序列 例：1g 的砝码有两个，2g 的砝码有无限个，3g 的砝码有一个，问一共可以凑出那些重量，每个重量有多少种凑出方式 $f_1(x)&#x3D;1+x+x^2$ $f_2(x)&#x3D;1+x^2+x^4+\\cdots$ $f_3(x)&#x3D;1+x^3$ $f(x)&#x3D;f_1(x)f_2(x)f_3(x)$ 例：有 $n$ 种苹果，每种苹果有无限个，问选出来 $k$ 个苹果的方案数 $f_i(x)&#x3D;1+x+x^2+x^3+\\cdots&#x3D;\\frac{1-x^n} {1-x}$ 由于 $-1&lt;x&lt;1$，则 $\\lim_{x \\to \\infty} x^n&#x3D;0$，则$f_i(x)&#x3D;\\frac 1 {1-x}$ $f(x)&#x3D;\\frac 1 {(1-x)^n}&#x3D;a_0+a_1x+x_2x^2+\\cdots+a_nx^n+\\cdots$ 其中$a_k&#x3D;C_{k+n-1}^{n-1} $ 以下证明 $f(x)&#x3D;\\frac 1 {(1-x)^n}&#x3D;a_0+a_1x+a_2x^2+\\cdots +a_nx^n$，其中 $a_k&#x3D;C_{k+n-1}^{n-1}$ $f(x)&#x3D;\\frac 1 {(1-x)^n}&#x3D;(\\frac 1 {1-x})^n$ 由泰勒级数，$\\frac 1 {1-x}&#x3D;1+x+x^2+\\cdots$，$f(x)&#x3D;(\\frac 1 {1-x})^n&#x3D;(1+x+x^2+x^3+\\cdots)^n$ 由组合计数，$x^k$ 的系数 $a^k&#x3D;\\sum_{i&#x3D;1}^{k} C_n^iC_{k-1}^{i-1}$（即选择 1~k 个括号内的取值不为 1，对于 $i&#x3D;t$ ，在 $n$ 个括号中选 $t$ 个，将幂次 $k$ 分到这 $t$ 个括号中，保证每个括号取值不为 1 的方案数） $\\sum_{i&#x3D;1}^{k} C_n^iC_{k-1}^{i-1}&#x3D;\\sum_{i&#x3D;1}^{k} C_n^iC_{k-1}^{k-i}$ 由于 $C_n^iC_{k-1}^{k}&#x3D;0$，因此 $\\sum_{i&#x3D;1}^{k} C_n^iC_{k-1}^{k-i}&#x3D;\\sum_{i&#x3D;0}^kC_n^iC_{k-1}^{k-i}$ 则由范德蒙恒等式 $\\sum_{i&#x3D;0}^kC_m^iC_{n}^{k-i}&#x3D;C_{m+n}^{k}$，$a_k&#x3D;\\sum_{i&#x3D;0}^kC_n^iC_{k-1}^{k-i}&#x3D;C_{n+k-1}^{k-i}$ 例题：AcWing 3132. 食物 明明这次又要出去旅游了，和上次不同的是，他这次要去宇宙探险！ 我们暂且不讨论他有多么睿智，他又幻想了他应该带一些什么东西。 理所当然的，你当然要帮他计算携带 $ N $ 件物品的方案数。 他这次又准备带一些受欢迎的食物，如：蜜桃多啦，鸡块啦，承德汉堡等等 当然，他又有一些稀奇古怪的限制，每种食物的限制如下： 承德汉堡：偶数个。 可乐：$ 0 $ 个或 $ 1 $ 个。 鸡腿：$ 0 $ 个，$ 1 $ 个或 $ 2 $ 个。 蜜桃多：奇数个。 鸡块：$ 4 $ 的倍数个。 包子：$ 0 $ 个，$ 1 $ 个，$ 2 $ 个或 $ 3 $ 个。 土豆片炒肉：不超过一个。 面包：$ 3 $ 的倍数个。 注意，这里我们懒得考虑明明对于带的食物该怎么搭配着吃，也认为每种食物都是以‘个’为单位（反正是幻想嘛），只要总数加起来是 $ N $ 就算一种方案。 因此，对于给出的 $ N $，你需要计算出方案数，并对 $ 10007 $ 取模。 输入格式一个整数 $ N $。 输出格式一个整数，表示方案数对 $ 10007 $ 取模后的结果。 数据范围$ 1 \\le N \\le 10^{500} $ 输入样例1：11 输出样例1：11 输入样例2：15 输出样例2：135 分析： $f_1(x)&#x3D;1+x^2+x^4+\\cdots&#x3D;\\frac 1 {1-x^2}$ $f_2(x)&#x3D;1+x&#x3D;\\frac {1-x^2} {1-x}$ $f_3(x)&#x3D;1+x+x^2&#x3D;\\frac {1-x^3} {1-x}$ $f_4(x)&#x3D;x+x^3+x^5+\\cdots&#x3D;x\\frac 1 {1-x^2} &#x3D; \\frac x {1-x^2}$ $f_5(x)&#x3D;1+x^6+x^8+\\cdots&#x3D;\\frac 1 {1-x^4}$ $f_6(x)&#x3D;1+x+x^2+x^3&#x3D;\\frac{1-x^4}{1-x}$ $f_7(x)&#x3D;1+x&#x3D;\\frac{1-x^2}{1-x}$ $f_8(x)&#x3D;1+x^3+x^6+\\cdots&#x3D;\\frac 1 {1-x^3}$$$\\begin{array}{l}f(x)\\&#x3D;f_1(x)f_2(x)f_3(x)f_4(x)f_5(x)f_6(x)f_7(x)f_8(x)\\&#x3D;\\frac 1 {\\bcancel{1-x^2}}\\frac {\\bcancel{1-x^2}} {1-x}\\frac {\\bcancel{1-x^3}} {1-x}\\frac x {\\bcancel{1-x^2}}\\frac 1 {\\bcancel{1-x^4}}\\frac{\\bcancel{1-x^4}}{1-x}\\frac{\\bcancel{1-x^2}}{1-x}\\frac 1 {\\bcancel{1-x^3}}\\&#x3D;\\frac x {(1-x)^4}\\end{array}$$因此要求 $f(x)$ 展开式中 $x^N$ 项的系数$$\\begin{array}{l}f(x)\\&#x3D;\\frac x {(1-x)^4}\\&#x3D;x\\frac 1 {(1-x)^4}\\&#x3D;x(\\sum_{i&#x3D;0}^\\infty a_ix^i) &amp;a_i&#x3D;C_{i+4-1}^{4-1}\\&#x3D;\\sum_{i&#x3D;0}^{\\infty} C_{i+4-1}^{4-1} x^{i+1}\\end{array}$$因此 $x^N$ 的系数为 $C_{(N-1)+4-1}^{4-1}&#x3D;C_{N+2}^3&#x3D;\\frac{(N+2)(N+1)N} {1\\times 2\\times 3}$ 12345678910111213#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n; char x; while(cin &gt;&gt; x)&#123; n=10*n+x-&#x27;0&#x27;; n%=10007; &#125; cout &lt;&lt; 1ll*(n+2)*(n+1)*n/6%10007; return 0;&#125;"},{"title":"浮点数二分","path":"/2024/07/25/浮点数二分/","content":"浮点数二分1234567891011double l=0,r=n;while(r-l&gt;1e-6)&#123;//若要求n位小数，最好为1e-(n+2) double mid=(l+r)/2; if(check(mid))&#123;//判断mid是否属于右区间 r=mid; &#125; else&#123; l=mid; &#125;&#125;return l;//l=r,返回l,r均可 例题：给定$a,b,c,d$,求$ax^3+bx^2+cx+d&#x3D;0$ 的三个根(保证$-100\\le x_1&lt;x_1+1\\le x_2&lt;x_2+1\\le x_3\\le100$),保留两位小数 分析：题目保证每两个根之差大于等于$1$，则可以从$-100$枚举到$100$，每次判断长度为$1$的区间，若端点的函数值之积小于$0$，则此区间必有一个根，二分求根($check:mid,r$的函数值之积小于$0$) 代码实现： 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;double a,b,c,d;double count(double x)&#123; return a*x*x*x+b*x*x+c*x+d;&#125;void find(double l,double r)&#123; while(r-l&gt;1e-4)&#123; double mid=(l+r)/2; if(count(mid)*count(r)&lt;=0)&#123; l=mid; &#125; else&#123; r=mid; &#125; &#125; cout &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; l &lt;&lt; &#x27; &#x27;;&#125;int main()&#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d; for(int i=-100;i&lt;100;i++)&#123; if(count(i)==0)&#123; cout &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; 1.0*i &lt;&lt; &#x27; &#x27;; &#125; else if(count(i)*count(i+1)&lt;0)find(i,i+1); &#125; return 0;&#125;"},{"title":"欧拉路径和欧拉回路","path":"/2024/07/25/欧拉路径和欧拉回路/","content":"欧拉路径和欧拉回路欧拉路径即每条边只走一次且能遍历所有边的路径（一笔画） 欧拉回路即起点和终点为同一点的欧拉路径 对于无向图，所有边都是连通的。 存在欧拉路径的充分必要条件：度数为奇数的点只能有0或2个。 存在欧拉回路的充分必要条件：度数为奇数的点只能有0个。 对于有向图，所有边都是连通的。 存在欧拉路径的充分必要条件：要么所有点的入度都等于出度；要么除了两个点之外，其余所有点的出度等于入度，剩余的两个点，一个满足出度比入度多1（起点），另一个满足入度比出度多1（终点）。 存在欧拉回路的充分必要条件：所有点的出度均等于入度。"},{"title":"欧拉函数","path":"/2024/07/25/欧拉函数/","content":"欧拉函数定义： $1∼N$ 中与 $N$ 互质的数的个数被称为欧拉函数，记为 $\\phi(N)$。若在算数基本定理中，$N&#x3D;p^{a_1}_1p^{a_2}_2…p^{a_m}_m$，则：$\\phi(N) &#x3D; N×\\frac {p_1−1}{p_1}×\\frac {p_2−1}{p_2}×…×\\frac {p_m−1}{p_m}$ 求法：线性筛 phi[1]&#x3D;1，若筛到当前数为素数，则phi[i]&#x3D;i-1，"},{"title":"概率与数学期望","path":"/2024/07/25/概率与数学期望/","content":"概率与数学期望性质： $E(aX+bY)&#x3D;aE(x)+bE(y)$"},{"title":"树与图的搜索","path":"/2024/07/25/树与图的搜索/","content":"树与图的搜索有向图存储： 邻接矩阵：$g[a][b]&#x3D;x$表示从$a$到$b$的一条长度为$x$的边 邻接表：在每个节点上开一个单链表表示当前点到链表中的点有一条边 对于无向图，每一条边$(u,v)$可以看作有向图中的$(u,v),(v,u)$两条边 邻接矩阵： 1234int g[N][N];void addedge(int u,int v,int w)&#123; g[u][v]=w;&#125; 邻接表： 12345678int h[N],ne[N],to[N],e[N];int cnt;void addedge(int u,int v,int w)&#123; ne[++cnt]=h[u]; to[cnt]=v; e[cnt]=w; h[u]=cnt;&#125; 树的搜索： 深度优先搜索以邻接表存图为例： 1234567int st[N];//记录当前点是否被搜过void dfs(int u)&#123; st[u]=true; for(int i=h[u];i;i=ne[i])&#123; if(!st[to[i]])dfs(to[i]); &#125;&#125; 应用：求子树的大小 例： 树的重心：重心是指树中的一个结点，如果将这个点删除后，剩余各个连通块中点数的最大值最小，那么这个节点被称为树的重心。 输入一个$n$，表示节点个数，输入$n-1$条边，求树的重心 分析：可以发现删除点后连通块的大小就等于这个点所有的子树大小和所有点减去这棵树及其子树大小的最大值（$max(sz[v],n-sz[u])$） 因此在遍历时求出所有子树大小，每次遍历完子树时求出每个点删除后的最大连通块大小即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;using namespace std;const int N=1e5+5;int n,ans=1e9;int h[N],ne[N*2],to[N*2];int cnt;void addedge(int u,int v)&#123; ne[++cnt]=h[u]; to[cnt]=v; h[u]=cnt;&#125;int sz[N];bool st[N];void dfs(int u)&#123; int mx=0; st[u]=1; sz[u]=1; for(int i=h[u];i;i=ne[i])&#123; if(!st[to[i]])&#123; dfs(to[i]); sz[u]+=sz[to[i]]; mx=max(mx,sz[to[i]]); &#125; &#125; mx=max(mx,n-sz[u]); ans=min(ans,mx);&#125;int main()&#123; cin &gt;&gt; n; for(int i=1;i&lt;n;i++)&#123; int u,v; cin &gt;&gt; u &gt;&gt; v; addedge(u,v); addedge(v,u); &#125; dfs(1); cout &lt;&lt; ans; return 0;&#125; 广度优先搜索例：给定点数$n$，$m$条边，求$1$到$n$的距离 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;using namespace std;const int N=1e5+5;int n,m;int h[N],ne[N*2],to[N*2];int cnt;void addedge(int u,int v)&#123; ne[++cnt]=h[u]; to[cnt]=v; h[u]=cnt;&#125;int d[N];void bfs()&#123; queue&lt;int&gt;q; q.push(1); memset(d,-1,sizeof d); d[1]=0; while(!q.empty())&#123; int t=q.front(); q.pop(); for(int i=h[t];i;i=ne[i])&#123; if(d[to[i]]==-1)&#123; d[to[i]]=d[t]+1; q.push(to[i]); &#125; &#125; &#125;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i=1;i&lt;=m;i++)&#123; int u,v; cin &gt;&gt; u &gt;&gt; v; addedge(u,v); &#125; bfs(); cout &lt;&lt; d[n]; return 0;&#125;"},{"title":"有向图的强连通分量","path":"/2024/07/25/有向图的强连通分量/","content":"有向图的强连通分量一个强连通分量中的点都可以互相到达 作用：有向图$\\xRightarrow{缩点}$ 有向无环图(DAG) Tarjan算法求强连通分量(SCC) 那么如何判断一个点是否在一个SCC中？ 情况1：存在一条后向边指向祖先节点 情况2：先走过横插边，后走到祖先节点 若按照dfs搜索的顺序给每个点一个编号，可以发现： 若当前边为树枝边或前向边，则y&gt;x 若当前边为后向边或横叉边，则y&lt;x 因此，对于每个点定义两个时间戳： dfn[u]表示遍历到$u$的时间戳 low[u]表示从$u$开始走，所能遍历到的最小时间戳 若存在一个点$u$，dfn[u]=low[u]，则$u$是其所在强连通分量的最高点 由此可以得到Tarjan算法: 顺序遍历每个节点，若没被遍历过，则进行搜索。首先记录当前点的时间戳并将这个点入栈，然后枚举每条边。 若这条边的终点没有被遍历过，则遍历终点，更新当前点的low（由于终点是可以被当前点遍历到的，因此当前点的low就等于两个点low的最小值。 若终点被遍历过，但终点仍然在栈里，则表示这条边是一个横插边，因此可以用终点的dfn更新当前点的low 枚举完所有边后，若当前点的low&#x3D;dfn，则表示当前点是其所处强连通分量的最高点，因此从栈顶一直到当前点均为这个强连通分量的点，记录即可。 12345678910111213141516171819202122232425void tarjan(int u)&#123; dfn[u]=low[u]=++timestamp; stk[++top]=u,in_stk[u]=true; for(int i=h[u];i;i=ne[i])&#123; int j=to[i]; if(!dfn[j])&#123; tarjan(j); low[u]=min(low[u],low[j]); &#125; else if(in_stk[j])&#123; low[u]=min(low[u],dfn[j]); &#125; &#125; if(dfn[u]==low[u])&#123; int y; ++scc_cnt; do&#123; y=stk[top--]; in_stk[y]=false; id[y]=scc_cnt; &#125;while(y!=u); &#125;&#125; 时间复杂度$O(n+m)$ 连通分量递减的顺序一定是拓扑序 求完强连通分量后，即可进行缩点，将原图转化为一个拓扑图： 1234567for(int i=1;i&lt;=n;i++)&#123; for(int j=h[i];j;j=ne[j])&#123; if(id[i]!=id[to[j]])&#123; addedge(id[i],id[to[j]]); &#125; &#125;&#125; 模板题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;using namespace std;const int N=5e5+5,M=4e6+5;int n,m;int h[N],ne[M],to[M],idx;int id[N],scc_cnt,timestamp;vector&lt;int&gt;scc[N];int dfn[N],low[N];stack&lt;int&gt;s;bool in_stk[N];void addedge(int u,int v)&#123; ne[++idx]=h[u]; h[u]=idx; to[idx]=v;&#125;void tarjan(int u)&#123; dfn[u]=low[u]=++timestamp; s.push(u),in_stk[u]=true; for(int i=h[u];i;i=ne[i])&#123; if(!dfn[to[i]])&#123; tarjan(to[i]); low[u]=min(low[u],low[to[i]]); &#125; else if(in_stk[to[i]])&#123; low[u]=min(low[u],dfn[to[i]]); &#125; &#125; if(dfn[u]==low[u])&#123; ++scc_cnt; int k; do&#123; k=s.top(); s.pop(); in_stk[k]=false; id[k]=scc_cnt; scc[scc_cnt].push_back(k); &#125;while(k!=u); &#125;&#125;bool out[N];int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i=1;i&lt;=m;i++)&#123; int u,v; cin &gt;&gt; u &gt;&gt; v; addedge(u,v); &#125; for(int i=1;i&lt;=n;i++)&#123; if(!dfn[i])tarjan(i); &#125; cout &lt;&lt; scc_cnt &lt;&lt; endl; for(int i=1;i&lt;=n;i++)&#123; int k=id[i]; if(out[k])continue; out[k]=1; sort(scc[k].begin(),scc[k].end()); for(auto x:scc[k])&#123; cout &lt;&lt; x &lt;&lt; &#x27; &#x27;; &#125; cout &lt;&lt; endl; &#125; return 0;&#125;"},{"title":"最近公共祖先（LCA）","path":"/2024/07/25/最近公共祖先（LCA）/","content":"最近公共祖先（LCA）最近公共祖先就是多叉树上根节点到两点路径重复部分的深度最低的点 朴素先让两点深度相同，然后同时向上找知道两点相同 123456int lca(int x,int y)&#123; if(d[x]&lt;d[y])swap(x,y); while(d[x]!=d[y])x=f[x]; while(x!=y)x=f[x],y=f[y]; return x;&#125; 倍增可以发现，上面的算法时间复杂度为 $O(n)$，可以用倍增优化向上找祖先的过程 首先预处理倍增数组，f[x][i] 表示 x 的第 $2^i$ 个祖先节点 12345678910111213141516171819int d[N];int f[N][22];void dfs(int u,int fa)&#123; d[u]=d[fa]+1; f[u][0]=fa; for(int i=h[u];~i;i=ne[i])&#123; if(to[i]!=fa)&#123; dfs(to[i],u); &#125; &#125;&#125;void init()&#123; for(int i=1;i&lt;22;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; f[j][i]=f[f[j][i-1]][i-1]; &#125; &#125;&#125; 然后就可以优化查询，首先让两点同深度，然后让两点同时向上跳（注意，这里是跳到不是公共祖先的节点上），最后得到的点的祖先节点就是答案。 1234567891011int lca(int x,int y)&#123; if(d[x]&lt;d[y])swap(x,y); for(int i=21;i&gt;=0;i--)&#123; if(d[f[x][i]]&gt;=d[y])x=f[x][i]; &#125; if(x==y)return x; for(int i=21;i&gt;=0;i--)&#123; if(f[x][i]!=f[y][i])x=f[x][i],y=f[y][i]; &#125; return f[x][0];&#125;"},{"title":"最短路","path":"/2024/07/25/最短路/","content":"最短路 单源最短路一个点到其他所有点的长度 Dijkstra稠密图 存储：邻接矩阵 做法： 初始化：$dis[1]&#x3D;0,dis[i]&#x3D;+\\infty$ 循环$n$次，每次选取没有被确定的距离最近的点$t$，则$t$的值被确定，用$t$更新其他未被确定的点。 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;using namespace std;const int N=505;int n,m;int g[N][N];int d[N];bool vis[N];int dijkstra()&#123; memset(d,0x3f,sizeof d); d[1]=0; for(int i=1;i&lt;=n;i++)&#123; int t=0; for(int j=1;j&lt;=n;j++)&#123; if(d[j]&lt;d[t]&amp;&amp;vis[j]==0)t=j; &#125; vis[t]=1; for(int j=1;j&lt;=n;j++)&#123; if(vis[j]==0)&#123; d[j]=min(d[j],d[t]+g[t][j]); &#125; &#125; &#125; if(d[n]==0x3f3f3f3f)return -1; return d[n];&#125;int main()&#123; memset(g,0x3f,sizeof g); cin &gt;&gt; n &gt;&gt; m; for(int i=1;i&lt;=m;i++)&#123; int u,v,w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; g[u][v]=min(g[u][v],w); &#125; cout &lt;&lt; dijkstra(); return 0;&#125; 堆优化Dijkstra稀疏图 存储：邻接表 做法： 初始化：$dis[1]&#x3D;0,dis[i]&#x3D;+\\infty$，将${0,1}$插入优先队列。 重复至队列为空：取出队首元素，若当前点已被确定，则进行下一次循环，否则当前点确定，用当前点更新其他点，若有点$v$被更新，则将${d[v],v}$插入队列。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;using namespace std;const int N=2e5+5;int n,m;int h[N],ne[N],to[N],e[N];int cnt;void addedge(int u,int v,int w)&#123; ne[++cnt]=h[u]; to[cnt]=v; e[cnt]=w; h[u]=cnt;&#125;int d[N];bool vis[N];int dijkstra()&#123; priority_queue&lt;pair&lt;int,int&gt;,vector&lt;pair&lt;int,int&gt;&gt;,greater&lt;pair&lt;int,int&gt;&gt;&gt;q; memset(d,0x3f,sizeof d); d[1]=0; q.push(&#123;0,1&#125;); while(!q.empty())&#123; auto t=q.top(); q.pop(); int u=t.second; if(vis[u])continue; vis[u]=1; for(int i=h[u];i;i=ne[i])&#123; if(d[to[i]]&gt;d[u]+e[i])&#123; d[to[i]]=d[u]+e[i]; q.push(&#123;d[to[i]],to[i]&#125;); &#125; &#125; &#125; if(d[n]==0x3f3f3f3f)return -1; return d[n];&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i=1;i&lt;=m;i++)&#123; int u,v,w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; addedge(u,v,w); &#125; cout &lt;&lt; dijkstra(); return 0;&#125; Bellman-Ford存边：结构体 做法： 循环$n$次，每次先备份数组，再通过备份遍历所有边，更新所有点 若限制走$k$条边，则循环$k$次 注意： 更新时$d[v]&#x3D;min(d[v],backup[u]+w)$ 负权边可能会把$d[n]$更新，但到不了第$n$个点，所以不能判断$d[n]&#x3D;&#x3D;inf$，而是大于一个较大的数 应用：求$1$到$n$经过最多$k$条边的最短长度 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std;const int N=505,M=1e4+5;int n,m,k;struct edge&#123; int u,v,w; edge():u(),v(),w()&#123;&#125; edge(int a,int b,int c):u(a),v(b),w(c)&#123;&#125;&#125;e[M];int d[N];int bellman_ford()&#123; memset(d,0x3f,sizeof d); d[1]=0; for(int i=1;i&lt;=k;i++)&#123; int backup[N]; memcpy(backup,d,sizeof d); for(int j=1;j&lt;=m;j++)&#123; auto t=e[j]; int u=t.u,v=t.v,w=t.w; d[v]=min(d[v],backup[u]+w); &#125; &#125; if(d[n]&gt;=5000000)return -1e9; return d[n];&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for(int i=1;i&lt;=m;i++)&#123; int u,v,w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; e[i]=&#123;u,v,w&#125;; &#125; int ans=bellman_ford(); if(ans==-1e9)cout &lt;&lt; &quot;impossible&quot;; else cout &lt;&lt; ans; return 0;&#125; SPFA稀疏图 存边：邻接表 考虑Bellman-Ford 的优化 每次更新边时只有当前节点的$dist$变小了，从当前点出发的边才会更新其他边，所以每次记录变小的点，更新变小的点所连的边 做法： 把$1$入队 循环直到队列为空：取出队首，更新以当前点为起点的边，若某个点被修改，且这个点不在队列里，将这个点入队 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;using namespace std;const int N=1e5+5;int n,m;int h[N],ne[N],to[N],e[N];int cnt;void addedge(int u,int v,int w)&#123; ne[++cnt]=h[u]; to[cnt]=v; e[cnt]=w; h[u]=cnt;&#125;int d[N];bool inq[N];int spfa()&#123; queue&lt;int&gt;q; memset(d,0x3f,sizeof d); d[1]=0; q.push(1); inq[1]=1; while(!q.empty())&#123; int u=q.front(); q.pop(); inq[u]=0; for(int i=h[u];i;i=ne[i])&#123; if(d[to[i]]&gt;d[u]+e[i])&#123; d[to[i]]=d[u]+e[i]; if(!inq[to[i]])&#123; q.push(to[i]); inq[to[i]]=1; &#125; &#125; &#125; &#125; return d[n];&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i=1;i&lt;=m;i++)&#123; int u,v,w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; addedge(u,v,w); &#125; int ans=spfa(); if(ans==0x3f3f3f3f)cout &lt;&lt; &quot;impossible&quot;; else cout &lt;&lt; ans; return 0;&#125; 判断负环原理：若最短路经过了$\\ge n$条边，则必定有一个点走过了两次及以上，则一定存在负环 做法：用$idx$数组记录当前最短路走过的边数，当当前点的$idx$大于等于$n$时则存在负环 因为不需要求具体数值，所以可以不初始化 因为图可能不连通，所以刚开始要全部入队 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;using namespace std;const int N=2e5+5;int n,m;int h[N],ne[N],to[N],e[N];int cnt;void addedge(int u,int v,int w)&#123; ne[++cnt]=h[u]; to[cnt]=v; e[cnt]=w; h[u]=cnt;&#125;int d[N];bool inq[N];int idx[N];bool spfa()&#123; queue&lt;int&gt;q; for(int i=1;i&lt;=n;i++)&#123; q.push(i); inq[i]=1; &#125; while(!q.empty())&#123; int u=q.front(); q.pop(); inq[u]=0; for(int i=h[u];i;i=ne[i])&#123; if(d[to[i]]&gt;d[u]+e[i])&#123; d[to[i]]=d[u]+e[i]; idx[to[i]]=idx[u]+1; if(idx[to[i]]&gt;n)return 1; if(!inq[to[i]])&#123; q.push(to[i]); inq[to[i]]=1; &#125; &#125; &#125; &#125; return 0;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i=1;i&lt;=n;i++)&#123; addedge(0,i,0); &#125; for(int i=1;i&lt;=m;i++)&#123; int u,v,w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; addedge(u,v,w); &#125; if(spfa())cout &lt;&lt; &quot;Yes&quot;; else cout &lt;&lt; &quot;No&quot;; return 0;&#125; 差分约束应用：求不等式组的可行解，其中每个不等式形如 $x_i \\le x_j+c_k$ 思路： 根据最短路的三角不等式，点$j$ 向点 $i$ 连一条长度为 $c$ 的边，那么如果 $dist_i&gt;dist_j+c$ ，则 $dist_i$ 会被更新为 $dist_j+c$ ，因此最短路算法结束后，一定有 $dist_i \\le dist_j+c$。 因此，可以把不等式 $x_i \\le x_j+c_k$ 看做一条 $x_j$ 到 $x_i$ 长度为 $x_k$ 的一条边 ，这样可以把原不等式组转化为图论问题。 由于需要满足所有的不等式，因此最短路的源点必须满足从这个点出发可以走到所有的边。可以建立一个超级源点，使这个点可以遍历到所有边。 可以发现，建成的图可能存在负环，则容易看出若出现负环，则原不等式组无解。 这样求出来的解是最大解，如果要求最小解，可以转化为求最长路，判断正环即可。 如果出现形如 $x_i \\le c$ 的不等式，则建立一个超级源点 $S$ ，则可以转化为 $x_i \\le S + c$ ，即建立一个 $S$ 到 $x_i$，长度为 $c$ 的边。 多源汇最短路任意两点之间的长度 Floyd存储：邻接矩阵 做法：初始化，枚举中间节点，起点，终点，更新 注意：负权边可能会把$d[n]$更新，但到不了第$n$个点，所以不能判断$d[n]&#x3D;&#x3D;inf$，而是大于一个较大的数 123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;using namespace std;const int N=205;int n,m,q;int g[N][N];void floyd()&#123; for(int k=1;k&lt;=n;k++)&#123; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; g[i][j]=min(g[i][j],g[i][k]+g[k][j]); &#125; &#125; &#125;&#125;int main()&#123; memset(g,0x3f,sizeof g); cin &gt;&gt; n &gt;&gt; m &gt;&gt; q; for(int i=1;i&lt;=m;i++)&#123; int u,v,w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; g[u][v]=min(g[u][v],w); &#125; for(int i=1;i&lt;=n;i++)&#123; g[i][i]=0; &#125; floyd(); for(int i=1;i&lt;=q;i++)&#123; int u,v; cin &gt;&gt; u &gt;&gt; v; if(g[u][v]&gt;1e9)cout &lt;&lt; &quot;impossible &quot;; else cout &lt;&lt; g[u][v] &lt;&lt; endl; &#125; return 0;&#125;"},{"title":"最小生成树","path":"/2024/07/25/最小生成树/","content":"最小生成树 Prim朴素版Prim稠密图 存储：邻接矩阵 做法： 初始化距离 循环$n$次，每次找到距离集合最近的点，加入集合，用这个点更新其他点到集合的距离 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;using namespace std;const int N=505;int n,m;int g[N][N];int d[N];bool st[N];int prim()&#123; memset(d,0x3f,sizeof d); int len=0; d[1]=0; for(int i=1;i&lt;=n;i++)&#123; int u=-1; for(int j=1;j&lt;=n;j++)&#123; if(!st[j]&amp;&amp;(d[u]&gt;d[j]||u==-1))u=j; &#125; if(d[u]==0x3f3f3f3f)return 0x3f3f3f3f; len+=d[u]; st[u]=1; d[u]=0; for(int j=1;j&lt;=n;j++)&#123; d[j]=min(d[j],d[u]+g[u][j]); &#125; &#125; return len;&#125;int main()&#123; memset(g,0x3f,sizeof g); cin &gt;&gt; n &gt;&gt; m; for(int i=1;i&lt;=m;i++)&#123; int u,v,w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; g[u][v]=g[v][u]=min(g[u][v],w); &#125; for(int i=1;i&lt;=n;i++)&#123; g[i][i]=0; &#125; int ans=prim(); if(ans==0x3f3f3f3f)cout &lt;&lt; &quot;impossible&quot;; else cout &lt;&lt; ans; return 0;&#125; 堆优化Prim类似$Dijkstra$的堆优化，不常用，可用$Kruskal$替代 Kruskal稀疏图 存储：结构体 做法： 排序所有边 每次选择最短的边，若这条边的两点不在同一集合(并查集)，则加入这条边，直到所有的点都在同一集合内 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;using namespace std;const int N=1e5+5,M=2e5+5;struct Edge&#123; int u,v,w; Edge():u(),v(),w()&#123;&#125; Edge(int a,int b,int c):u(a),v(b),w(c)&#123;&#125; bool operator&lt;(const Edge &amp;a)const&#123; return w&lt;a.w; &#125;&#125;edge[M];int n,m;int fa[N];int find(int x)&#123; return fa[x]==x?x:fa[x]=find(fa[x]);&#125;void merge(int x,int y)&#123; x=find(x),y=find(y); fa[x]=y;&#125;int idx;int kruskal()&#123; int len=0; for(int i=1;i&lt;=m;i++)&#123; auto t=edge[i]; if(find(t.u)!=find(t.v))&#123; merge(t.u,t.v); idx++; len+=t.w; if(idx==n-1)return len; &#125; &#125; return 0x3f3f3f3f;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i=1;i&lt;=n;i++)&#123; fa[i]=i; &#125; for(int i=1;i&lt;=m;i++)&#123; int u,v,w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; edge[i]=&#123;u,v,w&#125;; &#125; sort(edge+1,edge+m+1); int ans=kruskal(); if(ans==0x3f3f3f3f)cout &lt;&lt; &quot;impossible&quot;; else cout &lt;&lt; ans; return 0;&#125;"},{"title":"最小树形图(朱刘算法)","path":"/2024/07/25/最小树形图（朱刘算法）/","content":"最小树形图（朱刘算法）树形图：有向图中无环，每个点的入度为1（根节点除外）的图 最小树形图：边权和最小的树形图，可以认为是有向图的最小生成树 朱刘算法步骤： 对于每个点（除了根节点），找出所有入边中权值最小的边 判断选出的边中是否存在环。若不存在环，则这些边构成最小树形图，答案加上选出的边的权值，算法结束；若存在环，则进行下一步。 将所有的环缩点，得到新图$G$。 删去环内部的边，把终点在环内部的边的权值减去其终点在环内部的入边的权值，其他边不变。 进行步骤2。 时间复杂度$O(nm)$ 模板题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include&lt;bits/stdc++.h&gt;using namespace std;const int N=105;const int INF=0x3f3f3f3f;int n,m,r;int d[N][N],bd[N][N];int pre[N],bpre[N];int dfn[N],low[N],timestamp;stack&lt;int&gt;s;bool st[N],ins[N];int id[N],cnt;void dfs(int u)&#123; st[u]=true; for(int i=1;i&lt;=n;i++)&#123; if(d[u][i]!=INF&amp;&amp;!st[i])dfs(i); &#125;&#125;bool check_con()&#123; memset(st,0,sizeof st); dfs(r); for(int i=1;i&lt;=n;i++)&#123; if(!st[i])return false; &#125; return true;&#125;void tarjan(int u)&#123; dfn[u]=low[u]=++timestamp; s.push(u),ins[u]=true; int j=pre[u]; if(!dfn[j])&#123; tarjan(j); low[u]=min(low[u],low[j]); &#125; else if(ins[j])&#123; low[u]=min(low[u],dfn[j]); &#125; if(low[u]==dfn[u])&#123; int y; ++cnt; do&#123; y=s.top(); s.pop(); ins[y]=false; id[y]=cnt; &#125;while(y!=u); &#125;&#125;int work()&#123; int res=0; while(true)&#123; for(int i=1;i&lt;=n;i++)&#123; pre[i]=i; for(int j=1;j&lt;=n;j++)&#123; if(d[pre[i]][i]&gt;d[j][i])&#123; pre[i]=j; &#125; &#125; &#125; memset(dfn,0,sizeof dfn); timestamp=cnt=0; for(int i=1;i&lt;=n;i++)&#123; if(!dfn[i])&#123; tarjan(i); &#125; &#125; if(cnt==n)&#123; for(int i=1;i&lt;=n;i++)&#123; if(i!=r)&#123; res+=d[pre[i]][i]; &#125; &#125; break; &#125; for(int i=1;i&lt;=n;i++)&#123; if(i!=r)&#123; if(id[pre[i]]==id[i])&#123; res+=d[pre[i]][i]; &#125; &#125; &#125; for(int i=1;i&lt;=cnt;i++)&#123; for(int j=1;j&lt;=cnt;j++)&#123; bd[i][j]=INF; &#125; &#125; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; if(d[i][j]&lt;INF&amp;&amp;id[i]!=id[j])&#123; int a=id[i],b=id[j]; if(id[pre[j]]==id[j])bd[a][b]=min(bd[a][b],d[i][j]-d[pre[j]][j]); else bd[a][b]=min(bd[a][b],d[i][j]); &#125; &#125; &#125; n=cnt; r=id[r]; memcpy(d,bd,sizeof d); &#125; return res;&#125;int main()&#123; memset(d,0x3f,sizeof d); cin &gt;&gt; n &gt;&gt; m &gt;&gt; r; for(int i=1;i&lt;=m;i++)&#123; int a,b,c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; if(a!=b&amp;&amp;b!=r)d[a][b]=min(d[a][b],c); &#125; if(!check_con())cout &lt;&lt; &quot;-1 &quot;; else cout &lt;&lt; work() &lt;&lt; endl; return 0;&#125;"},{"title":"无向图的双连通分量","path":"/2024/07/25/无向图的双连通分量/","content":"无向图的双连通分量边双连通分量(e-DCC)桥：若被删去，则其相连的两个部分不连通 边双连通分量：极大的不包含桥的连通块 如何找到桥 若dfn[x]&lt;low[y]，则边(x,y)是桥（即y无论如何都走不到x） 如何找所有边的双连通分量 方法一：将所有桥删掉，则剩余的每个连通块就是一个边双连通分量。 方法二：类似有向图的强连通分量，使用一个stack，若搜索完一个点的所有邻接点后dfn[x]=low[x]，则这个点与其父节点构成的边为一个桥。 123456789101112131415161718192021222324252627void tarjan(int u,int from)&#123; dfn[u]=low[u]=++timestamp; s.push(u); for(int i=h[u];~i;i=ne[i])&#123; int j=to[i]; if(!dfn[j])&#123; tarjan(j,i); low[u]=min(low[u],low[j]); if(dfn[u]&lt;low[j])&#123;//是桥 is_bridge[i]=is_bridge[i^1];//正反都要标记 &#125; &#125; else if(i!=(from^1))&#123;//不是反向边 low[u]=min(low[u],dfn[j]); &#125; &#125; if(dfn[u]==low[u])&#123; ++dcc_cnt; int k; do&#123; k=s.top(); s.pop(); id[k]=dcc_cnt; dcc[dcc_cnt].push_back(k); &#125;while(k!=u); &#125;&#125; 模板题 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;bits/stdc++.h&gt;using namespace std;const int N=5e5+5,M=4e6+5;int n,m;int h[N],ne[M],to[M],idx;int dfn[N],low[N],timestamp;stack&lt;int&gt;s;int id[N],dcc_cnt;vector&lt;int&gt;dcc[N];bool is_bridge[M];void add(int a,int b)&#123; to[idx]=b,ne[idx]=h[a],h[a]=idx++;&#125;void tarjan(int u,int from)&#123; dfn[u]=low[u]=++timestamp; s.push(u); for(int i=h[u];~i;i=ne[i])&#123; int j=to[i]; if(!dfn[j])&#123; tarjan(j,i); low[u]=min(low[u],low[j]); if(dfn[u]&lt;low[j])&#123; is_bridge[i]=is_bridge[i^1]; &#125; &#125; else if(i!=(from^1))&#123; low[u]=min(low[u],dfn[j]); &#125; &#125; if(dfn[u]==low[u])&#123; ++dcc_cnt; int k; do&#123; k=s.top(); s.pop(); id[k]=dcc_cnt; dcc[dcc_cnt].push_back(k); &#125;while(k!=u); &#125;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; memset(h,-1,sizeof h); for(int i=1;i&lt;=m;i++)&#123; int a,b; cin &gt;&gt; a &gt;&gt; b; add(a,b),add(b,a); &#125; for(int i=1;i&lt;=n;i++)&#123; if(!dfn[i])tarjan(i,-1); &#125; cout &lt;&lt; dcc_cnt &lt;&lt; endl; for(int i=1;i&lt;=dcc_cnt;i++)&#123; cout &lt;&lt; dcc[i].size() &lt;&lt; &#x27; &#x27;; for(auto x:dcc[i])&#123; cout &lt;&lt; x &lt;&lt; &#x27; &#x27;; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 点双连通分量(v-DCC)割点：若被删去，则其相连的两部分不连通 点双连通分量：极大的不包含割点的连通块 每个割点都至少属于两个点双连通分量 如何求割点 low[y]$\\ge$dfn[x](y搜不到x上面) （1）若$x$不是根节点，则$x$是割点 （2）若$x$是根节点，则若还有至少一个$y_i$满足low[$y_i$]$\\ge$dfn[x]，则$x$是割点 如何求点双连通分量 stack，若low[y]$\\ge$dfn[x] ，则子树个数$cnt$++，若$x$不是根节点或还有至少一个$y_i$满足low[$y_i$]$\\ge$dfn[x]，即cnt&gt;1，则$x$为割点，将栈中元素弹出直至$y$为止，这些点和$x$都属于这个点双连通分量 模板题 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;bits/stdc++.h&gt;using namespace std;const int N=5e5+5,M=4e6+5;int n,m;int h[N],to[M],ne[M],idx;int dfn[N],low[N],timestamp;stack&lt;int&gt;s;int dcc_cnt;vector&lt;int&gt;dcc[N];int root;void add(int a,int b)&#123; to[idx]=b,ne[idx]=h[a],h[a]=idx++;&#125;void tarjan(int u)&#123; dfn[u]=low[u]=++timestamp; s.push(u); if(u==root&amp;&amp;h[u]==-1)&#123; //孤立点 dcc_cnt++; dcc[dcc_cnt].push_back(u); s.pop(); return; &#125; int cnt=0; for(int i=h[u];~i;i=ne[i])&#123; int j=to[i]; if(!dfn[j])&#123; tarjan(j); low[u]=min(low[u],low[j]); if(dfn[u]&lt;=low[j])&#123; cnt++; ++dcc_cnt; int y; do&#123; y=s.top(); s.pop(); dcc[dcc_cnt].push_back(y); &#125;while(y!=j); dcc[dcc_cnt].push_back(u); &#125; &#125; else&#123; low[u]=min(low[u],dfn[j]); &#125; &#125;&#125;int main()&#123; memset(h,-1,sizeof h); cin &gt;&gt; n &gt;&gt; m; for(int i=1;i&lt;=m;i++)&#123; int a,b; cin &gt;&gt; a &gt;&gt; b; if(a!=b)add(a,b),add(b,a);//自环 &#125; for(root=1;root&lt;=n;root++)&#123; if(!dfn[root])&#123; tarjan(root); &#125; &#125; cout &lt;&lt; dcc_cnt &lt;&lt; endl; for(int i=1;i&lt;=dcc_cnt;i++)&#123; cout &lt;&lt; dcc[i].size() &lt;&lt; &#x27; &#x27;; for(auto x:dcc[i])&#123; cout &lt;&lt; x &lt;&lt; &#x27; &#x27;; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 例题：洛谷P3225 [HNOI2012] 矿场搭建 题目大意：给定一个无向图，问最少在几个点上设置出口，可以使得不管哪个点坍塌，其余所有点都可以与某个出口连通，并求出方案数。 分析： 首先不难发现，如果只有一个出口的话，那么如果这个出口坍塌，则其余点一定无法与出口连通，因此，至少有两个出口。 可以把整个无向图分成若干个连通块，对于每个连通块单独求出答案。 若当前连通块中没有割点，则直接设置两个出口即可，方案数为$C_{size}^{2}&#x3D;\\frac{size \\times (size-1)}{2}$。 若当前连通块中有割点，则可以进行缩点，将所有割点建一个新点，点双连通分量中除了割点外的其他点建一个点，并连向点双连通分量中的割点，形成一个新图，则可以发现，只需在所有度数为1的点，即这个对应的连通块除了割点以外的任意点上建立一个出口就能保证所有点可以和出口连通，方案数为$size-1$。 不难发现，缩点后点的度数就等于点双连通分量中割点个数。 注意特判连通块只有一个点的情况。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include&lt;bits/stdc++.h&gt;using namespace std;typedef unsigned long long ll;//2^64const int N=1e3+5,M=1e3+5;int n,m;int h[N],to[M],ne[M],idx;int dfn[N],low[N],timestamp;stack&lt;int&gt;s;int dcc_cnt;vector&lt;int&gt;dcc[N];bool cut[N];int root;void add(int a,int b)&#123; to[idx]=b,ne[idx]=h[a],h[a]=idx++;&#125;void tarjan(int u)&#123; //记录时间戳 dfn[u]=low[u]=++timestamp; s.push(u); //判断如果连通块只有一个点 if(u==root&amp;&amp;h[u]==-1)&#123; dcc_cnt++; dcc[dcc_cnt].push_back(u); s.pop(); return; &#125; int cnt=0;//记录当前点有多少个分支 for(int i=h[u];~i;i=ne[i])&#123; int j=to[i]; if(!dfn[j])&#123; tarjan(j); low[u]=min(low[u],low[j]); if(dfn[u]&lt;=low[j])&#123;//j到不了i之上 cnt++; if(u!=root||cnt&gt;1)cut[u]=true;//判断是否为割点 ++dcc_cnt; int y; do&#123; y=s.top(); s.pop(); dcc[dcc_cnt].push_back(y); &#125;while(y!=j);//注意，因为u可能是割点，所以会在其他连通分量中，因此到j结束，u单独加 dcc[dcc_cnt].push_back(u); &#125; &#125; else&#123; low[u]=min(low[u],dfn[j]); &#125; &#125;&#125;int main()&#123; int T=1; while(cin &gt;&gt; m,m)&#123; //清空 while(!s.empty())s.pop(); for(int i=1;i&lt;=dcc_cnt;i++)&#123; dcc[i].clear(); &#125; idx=n=timestamp=dcc_cnt=0; memset(h,-1,sizeof h); memset(dfn,0,sizeof dfn); memset(cut,0,sizeof cut); //输入 for(int i=1;i&lt;=m;i++)&#123; int a,b; cin &gt;&gt; a &gt;&gt; b; n=max(n,max(a,b)); add(a,b),add(b,a); &#125; //遍历所有的点 for(root=1;root&lt;=n;root++)&#123; if(!dfn[root])&#123; tarjan(root); &#125; &#125; //计算答案 int res=0; ll num=1; for(int i=1;i&lt;=dcc_cnt;i++)&#123; int cnt=0;//求割点个数 for(int j=0;j&lt;dcc[i].size();j++)&#123; if(cut[dcc[i][j]])cnt++; &#125; //计算 if(cnt==0)&#123; if(dcc[i].size()&gt;1)res+=2,num*=dcc[i].size()*(dcc[i].size()-1)/2; else res++; &#125; else if(cnt==1)&#123; res++,num*=dcc[i].size()-1; &#125; &#125; cout &lt;&lt; &quot;Case &quot; &lt;&lt; T++ &lt;&lt; &quot;: &quot; &lt;&lt; res &lt;&lt; &#x27; &#x27; &lt;&lt; num &lt;&lt; endl; &#125; return 0;&#125;"},{"title":"斯特林数","path":"/2024/07/25/斯特林数/","content":"斯特林数第一类斯特林数将 $1 \\sim n$ 划分为 $k$ 个圆排列的方案数，记作 $s(n,k)$ 或 $\\begin{bmatrix} n\\ k\\end{bmatrix}$ 求法： $\\begin{bmatrix} n\\ k\\end{bmatrix}&#x3D;\\begin{bmatrix} n-1\\ k-1\\end{bmatrix}+(n-1)\\cdot \\begin{bmatrix} n-1\\ k\\end{bmatrix}$ 即将第 $n$ 个数单独作为一个圆排列和放到原有的圆排列的方案数之和。第二种放法相当于先枚举每个排列，放到每个排列的每个数之后的方案数，也就是所有点数的总和，因此为 $n-1$ 。 性质： $\\begin{bmatrix} 0\\ 0\\end{bmatrix}&#x3D;1$ $\\begin{bmatrix} n\\ 0\\end{bmatrix}&#x3D;0$ $\\begin{bmatrix} n\\ n\\end{bmatrix}&#x3D;1$ $\\begin{bmatrix} n\\ 1\\end{bmatrix}&#x3D;(n-1)!$，即 $1\\sim n$ 的圆排列数 $\\begin{bmatrix} n\\ n-1\\end{bmatrix}&#x3D;C_n^2$，即从 $n$ 个数里选出两个数组成一个圆排列，其余的数单独为圆排列 $\\begin{bmatrix} n\\ 2\\end{bmatrix}&#x3D;(n-1)!\\cdot \\sum_{i&#x3D;1}^{n-1}\\frac 1 i$ 相当于将 $n$ 个点划分为大小为 $i$ 和 $n-i$ 的两个圆排列，方案数为 $C_n^i$，两个圆排列内部的方案数 为 $(i-1)!$ 和 $(n-i-1)!$，由于两个圆交换方案相同，但会被算两次。由于每个圆的点数不为零，因此 $i$ 从 $1$ 循环到 $n-1$ ，所以方案数就为 $\\sum_{i&#x3D;1}^{n-1}\\frac 1 2 C_n^i (i-1)!(n-i-1)!$$$\\begin{array}{l}\\sum_{i&#x3D;1}^{n-1} \\frac 1 2 C_n^i (i-1)!(n-i-1)!\\&#x3D; \\frac 1 2\\sum_{i&#x3D;1}^{n-1} \\frac{n!}{(n-i)!i!} (i-1)!(n-i-1)!\\&#x3D;\\frac 1 2 \\sum_{i-1}^{n-1} \\frac {n!} {(n-i)i}\\&#x3D;\\frac 1 2 \\sum_{i&#x3D;1}^{n-1} (n-1)! \\frac {n}{i(n-i)}\\&#x3D;\\frac 1 2 (n-1)! \\sum_{i&#x3D;1}^{n-1} (\\frac 1 i +\\frac 1 {n-i})\\end{array}$$ 由于从 $1$ 到 $n-1$ ，$\\frac 1 i$ 和 $\\frac 1 {n-i}$ 都会出现 $1 \\sim \\frac 1 {n-1}$ ，因此$$\\begin{array}{l}\\sum_{i&#x3D;1}^{n-1} \\frac 1 2 C_n^i (i-1)!(n-i-1)!\\&#x3D;\\frac 1 2 (n-1)! \\sum_{i&#x3D;1}^{n-1} (\\frac 1 i +\\frac 1 {n-i})\\&#x3D;\\frac 1 2 (n-1)! \\cdot 2\\sum_{i&#x3D;1}^{n-1} \\frac 1 i\\&#x3D;(n-1)! \\sum_{i-1}^{n-1}\\frac 1 i\\end{array}$$ $\\begin{bmatrix} n\\ n-2\\end{bmatrix}&#x3D;2\\cdot C_n^3+3\\cdot C_n^4$ 相当于 将 $n$ 个点划分成 $n-3$ 个 1 个点的圆排列和 1 个 3 个点的圆排列 或 将 $n$ 个点划分成 $n-4$ 个 1 个点的圆排列和 2 个 2 个点的圆排列 的方案数之和，即 $C_n^3 \\cdot 2!+ C_n^2 \\cdot C_{n-2}^2$ $$ \\begin{array}{l} C_n^3 \\cdot 2!+ C_n^2 \\cdot C_{n-2}^2\\ &#x3D;2\\cdot C_n^3+\\frac{n!}{(n-2)! 2!}\\cdot \\frac{(n-2)!}{(n-4)!2!}\\ &#x3D;2\\cdot C_n^3+\\frac{n!}{4\\cdot(n-4)!}\\ &#x3D;2\\cdot C_n^3+3\\cdot \\frac{n!}{(n-4)!4!}\\ &#x3D;2\\cdot C_n^3+3\\cdot C_n^4 \\end{array} $$ $\\sum_{k&#x3D;0}^n \\begin{bmatrix} n\\ k\\end{bmatrix}&#x3D;n!$ 记升阶函数 $x^{n\\uparrow}&#x3D;x(x+1)\\cdots (x+n-1)$，则其展开式的 $x^k$ 项系数 $a_k$ 为 $\\begin{bmatrix} n\\ k\\end{bmatrix}$，下面用数学归纳法证明 $k&#x3D;1,a_1&#x3D;1\\cdot 2\\cdots(n-1)&#x3D;(n-1)!&#x3D;\\begin{bmatrix} n\\ 1\\end{bmatrix}$ 设 $k&#x3D;t$ 时，$a_t&#x3D;\\begin{bmatrix} n\\ t\\end{bmatrix}$ 则 $t+1$ 时，$a_{t+1}&#x3D;\\begin{bmatrix} n\\ t+1\\end{bmatrix}&#x3D;\\begin{bmatrix} n-1\\ k-1\\end{bmatrix}+(n-1)\\begin{bmatrix} n-1\\ k\\end{bmatrix}$ 综上，归纳假设成立，命题得证。 取 $x&#x3D;1$ ，则得到 $1^{n\\uparrow}&#x3D;1\\cdot 2\\cdots n&#x3D;n!&#x3D;\\begin{bmatrix} n\\ 0\\end{bmatrix}+\\begin{bmatrix} n\\ 1\\end{bmatrix}+\\begin{bmatrix} n\\ 2\\end{bmatrix}+\\cdots+\\begin{bmatrix} n\\ n\\end{bmatrix}$ 求第一类斯特林数 AcWing 3165. 第一类斯特林数 1234567891011121314151617181920#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int N=1005,mod=1e9+7;int n,m;int f[N][N];int main()&#123; cin &gt;&gt; n &gt;&gt; m; f[0][0]=1; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++)&#123; f[i][j]=(f[i-1][j-1]+1ll*(i-1)*f[i-1][j])%mod; &#125; &#125; cout &lt;&lt; f[n][m]; return 0;&#125; 第二类斯特林数将 $1\\sim n $ 划分成 $k$ 个子集的方案数，记作 $S(n,k)$ 或 $\\begin{Bmatrix} n \\ k\\end{Bmatrix}$ $\\begin{Bmatrix} n \\ k\\end{Bmatrix}&#x3D;\\begin{Bmatrix} n-1 \\ k-1\\end{Bmatrix}+k\\cdot\\begin{Bmatrix} n-1 \\ k\\end{Bmatrix}$ 即 第 $n$ 个数单独放到一个子集里 或 第 $n$ 个数放到前面的子集中的一个里 的方案数之和 性质： $\\begin{Bmatrix} n \\ 0\\end{Bmatrix}&#x3D;0^n$ （$n&#x3D;0$ 时 $0^0&#x3D;1$，$n&gt;0$ 时 $0^n &#x3D;0$ ） $\\begin{Bmatrix} n \\ 1\\end{Bmatrix}&#x3D;1$ $\\begin{Bmatrix} n \\ n\\end{Bmatrix}&#x3D;1$ $\\begin{Bmatrix} n \\ 2\\end{Bmatrix}&#x3D;2^{n-1}-1$ $n$ 个数每个数可以划分到第一个子集或第二个子集，因此方案数为 $2^n$，每个子集不能为空，减去 $2$ 个存在子集为空的方案数，集合之间没有顺序，减去重复的，即方案数除以 $2$ ，因此方案数为 $\\frac {2^n-2} 2&#x3D;2^{n-1}-1$ $\\begin{Bmatrix} n \\ n-1\\end{Bmatrix}&#x3D;C_n^2$ 只有一种划分方案，即有 $n-2$ 个集合为 1 个数，1 个集合为 2 个数，因此方案数就是从 $n$ 个数里选两个，即 $C_n^2$ $\\begin{Bmatrix} n \\ n-2\\end{Bmatrix}&#x3D;C_n^3+3\\cdot C_n^4$ 共两种方案，即 有 $n-3$ 个集合为 1 个数，1 个集合为 3 个数 和 有 $n-4$ 个集合为 1 个数，2 个集合为 2 个数，方案数为 $C_n^3+C_n^2\\cdot C_{n-2}^2&#x3D;C_n^3+2\\cdot C_n^4$（推导过程同第一类斯特林数性质7） $\\begin{Bmatrix} n \\ 3 \\end{Bmatrix}&#x3D;\\frac 1 2(3^{n-1}+1)-2^{n-1}$ $\\begin{Bmatrix} n \\ n-3\\end{Bmatrix}&#x3D;C_n^4+10\\cdot C_n^5+15\\cdot C_n^6$ $\\sum_{k&#x3D;0}^n \\begin{Bmatrix} n \\ k\\end{Bmatrix}&#x3D;B_n$，其中 $B_n$ 是贝尔数，$B_{n+1}&#x3D;\\sum_{k&#x3D;0}^n C_n^k B_k$，$B_n&#x3D;\\frac 1 e \\sum_{k&#x3D;0}^{\\infty} \\frac{k^n}{k!}$ 通项公式：$\\begin{Bmatrix} n \\ m\\end{Bmatrix}&#x3D;\\frac 1 {m!} \\sum_{k&#x3D;0}^m (-1)^k C_m^k(m-k)^n $ $m^n&#x3D;\\sum_{i&#x3D;0}^m \\matrix{}\\begin{Bmatrix} n \\ i\\end{Bmatrix} m^{\\underline i}$ 其中 $m^{\\underline n}&#x3D;\\Pi_{i&#x3D;m-n+1}^{m}&#x3D;\\frac {m!}{(m-n)!}&#x3D;C_m^n\\cdot n!$ 第一类斯特林数和第二类斯特林数满足：$\\sum_{k&#x3D;0}^n \\begin{bmatrix} n \\ k\\end{bmatrix} \\begin{Bmatrix} k \\ m\\end{Bmatrix}&#x3D;\\sum_{k&#x3D;0}^n \\begin{Bmatrix} n \\ k\\end{Bmatrix}\\begin{bmatrix} k \\ m\\end{bmatrix}$ 求第二类斯特林数 AcWing 3166. 第二类斯特林数 1234567891011121314151617181920#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N=1005,mod=1e9+7;int n,m;int f[N][N];int main()&#123; cin &gt;&gt; n &gt;&gt; m; f[0][0]=1; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++)&#123; f[i][j]=(f[i-1][j-1]+1ll*j*f[i-1][j])%mod; &#125; &#125; cout &lt;&lt; f[n][m]; return 0;&#125; 例题：洛谷 P4609 [FJOI2016] 建筑师&#x2F;AcWing 3020. 建筑师 小 $ Z $ 是一个很有名的建筑师，有一天他接到了一个很奇怪的任务：在数轴上建 $ n $ 个建筑，每个建筑的高度是 $ 1 $ 到 $ n $ 之间的一个整数。 小 $ Z $ 有很严重的强迫症，他不喜欢有两个建筑的高度相同。 另外小 $ Z $ 觉得如果从最左边（所有建筑都在右边）看能看到 $ A $ 个建筑，从最右边（所有建筑都在左边）看能看到 $ B $ 个建筑，这样的建筑群有着独特的美感。 现在，小 $ Z $ 想知道满足上述所有条件的建筑方案有多少种？ 如果建筑 $ i $ 的左(右)边没有任何建造比它高，则建筑 $ i $ 可以从左(右)边看到。 两种方案不同，当且仅当存在某个建筑在两种方案下的高度不同。 输入格式第一行一个整数 $ T $，代表 $ T $ 组数据。 接下来 $ T $ 行，每行三个整数 $ n,A,B $。 输出格式对于每组数据输出一行答案 $ \\bmod 10^9+7 $。 数据范围$ 1 \\le n \\le 50000 $,$ 1 \\le A,B \\le 100 $,$ 1 \\le T \\le 200000 $ 输入样例：12323 2 23 1 2 输出样例：1221 分析： 用高度为 $n$ 的建筑物将序列分为两半，则从左看一定看不到右边，从右看一定看不到左边，两边完全独立。 然后题目转化为 左半部分可以看到 $A-1$ 个建筑，右半部分可以看到 $B-1$ 个建筑 将每个建筑物和被它挡住的建筑物作为一个整体，则要求左边有 $A-1$ 个部分，右边有 $B-1 $ 个部分，因此将 $1\\sim n-1$ 划分成 $A+B-2$ 个部分，并考虑每一部分的排列数（设这个部分有 $k$ 个数，则第一个数必须是最大的，其余数可以随便选，方案数为 $(k-1)!$ ）其实也就是将 $1\\sim n-1$ 划分成 $A+B-2$ 个圆排列的方案数，所以就是第一类斯特林数 ，方案数为 $\\begin{bmatrix} n-1\\ A+B-2\\end{bmatrix}$ 接下来将这些圆排列划分到两边，即 $C_{A+B-2}^{A-1}$ 中方案 最后，将左右两边排序，只有 1 中排法 因此，总共的方案数就是 $\\begin{bmatrix} n-1\\ A+B-2\\end{bmatrix} \\cdot C_{A+B-2}^{A-1}$ 123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int N=50005,M=205,mod=1e9+7;int n,A,B;int f[N][M];int c[M][M];int main()&#123; f[0][0]=1; for(int i=1;i&lt;N;i++)&#123; for(int j=1;j&lt;M;j++)&#123; f[i][j]=(f[i-1][j-1]+1ll*(i-1)*f[i-1][j])%mod; &#125; &#125; for(int i=0;i&lt;M;i++)&#123; c[i][0]=1; for(int j=1;j&lt;=i;j++)&#123; c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod; &#125; &#125; int T; cin &gt;&gt; T; while(T--)&#123; cin &gt;&gt; n &gt;&gt; A &gt;&gt; B; cout &lt;&lt; 1ll*f[n-1][A+B-2]*c[A+B-2][A-1]%mod &lt;&lt; endl; &#125; return 0;&#125;"},{"title":"整数二分","path":"/2024/07/25/整数二分/","content":"整数二分本质:可以使区间被分为两部分，其中一部分满足性质A,另一部分不满足性质A，即可使用二分 模板一:取左部分的右端点 1234567mid=(l+r+1)&gt;&gt;1;//若mid=l+r&gt;&gt;1，则当l=r-1时，mid=l，此时若check(mid)成立，则l,r不会变化，出现死循环if(check(mid))&#123;//判断mid是否满足左侧的要求 l=mid;//如果满足，则分界一定在mid及其右侧(可能是mid，所以l=mid)&#125;else&#123; r=mid-1;//如果不满足，则分界一定在mid左侧(一定不是mid，所以r=mid-1)&#125; 模板二:取右部分的左端点 1234567mid=l+r&gt;&gt;1;if(check(mid))&#123;//判断mid是否满足右侧的要求 r=mid;//如果满足，则分界一定在mid及其左侧(可能是mid，所以r=mid)&#125;else&#123; l=mid+1;//如果不满足，则分界一定在mid右侧(一定不是mid，所以l=mid+1)&#125; 例题：输入一个排好序的数组，求给定数的起始位置和终止位置 分析：求起始位置可以把区间分为$&lt;x,\\ge x$两部分，取右部分的左端点； ​ 求终止位置可以把区间分为$\\le x,&gt;x$两部分，取左部分的右端点。 代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;using namespace std;const int N=1e6;int n,Q;int q[N];int find_l(int k)&#123;//求左端点 int l=1,r=n; while(l&lt;r)&#123; int mid=l+r&gt;&gt;1; if(q[mid]&gt;=k)&#123; r=mid; &#125; else&#123; l=mid+1; &#125; &#125; if(q[l]!=k)return 0;//若端点上的数不为要求的数，则这个数不存在 return l;//此时l=r，返回l,r均可&#125;int find_r(int k)&#123;//求右端点 int l=1,r=n; while(l&lt;r)&#123; int mid=l+r+1&gt;&gt;1; if(q[mid]&lt;=k)&#123; l=mid; &#125; else&#123; r=mid-1; &#125; &#125; if(q[r]!=k)return 0;//若端点上的数不为要求的数，则这个数不存在 return r;//此时l=r，返回l,r均可&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; Q; for(int i=1;i&lt;=n;i++)&#123; cin &gt;&gt; q[i]; &#125; for(int i=1;i&lt;=Q;i++)&#123; int x; cin &gt;&gt; x; cout &lt;&lt; find_l(x)-1 &lt;&lt; &#x27; &#x27; &lt;&lt; find_r(x)-1 &lt;&lt; endl; &#125; return 0;&#125;"},{"title":"数据结构","path":"/2024/07/25/数据结构/","content":"数据结构目录树状数组$lowbit(x)$：$x$二进制下第一个1 123int lowbit(x)&#123; return x&amp;-x;&#125; 支配区间：$[i-lowbit(i)+1,i]$ 引理1：对于任意x,y，其支配区间要么相离，要么呈包含与被包含关系 这说明，支配区间的关系构成一棵树，这棵树就是树状数组 引理2：对于点x，其在树上的父节点为$x+lowbit(x)$ 由此可以得到单点修改和前缀查询的方法 单点修改：假设我们将$a_x$增加了$k$，考虑其对${c_n}$的影响。注意到，所有支配区间包含$x$的点，对应一条从$x$到根的链，于是，我们不断将$c_x$加上$k$，并令$x&#x3D;x+lowbit(x)$即可。 前缀查询：令$S(r)&#x3D;\\sum_{i&#x3D;1}^{r}a_i$，则有$$S(r)&#x3D;S(r-lowbit(r))+\\sum_{i&#x3D;r-lowbit(r)+1}^{r}a_i$$因此，$S(r)&#x3D;S(r-lowbit(r))+b_r$。我们不断将答案加上$b_r$，并令$r&#x3D;r-lowbit(r)$，直到$r&#x3D;0$即可。 对于区间查询，其可拆为两个前缀和相减的形式。 线性建树：先将所有 $c_i$ 赋值为 $a_i$，再枚举 $i &#x3D; 1, 2, · · · , n$，若 $i + lowbit(i) \\le n$， 将 $c_{i+lowbit(i)}$ 加上 $c_i$ 即可。 12345for(int i=1;i&lt;=n;i++)&#123;\tc[i]+=a[i]; int j=i+lowbit(i); if(j&lt;=n)c[j]+=c[i];&#125; 模板： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;const int N=500010;int n,m;int a[N];long long tr[N];int lowbit(int x)&#123; return x&amp;-x;&#125;void add(int x,int c)&#123; for(int i=x;i&lt;=n;i+=lowbit(i))&#123; tr[i]+=c; &#125;&#125;long long sum(int x)&#123; long long res=0; for(int i=x;i;i-=lowbit(i))&#123; res+=tr[i]; &#125; return res;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i=1;i&lt;=n;i++)&#123; cin &gt;&gt; a[i]; &#125; for(int i=1;i&lt;=n;i++)&#123; tr[i]+=a[i]; int j=i+lowbit(i); if(j&lt;=n)tr[j]+=tr[i]; &#125; while(m--)&#123; int op; int l,d,r; cin &gt;&gt; op &gt;&gt; l; if(op==1)&#123; cin &gt;&gt; d; add(l,d); &#125; else&#123; cin &gt;&gt; r; cout &lt;&lt; sum(r)-sum(l-1) &lt;&lt; endl; &#125; &#125; return 0;&#125; 例题1：洛谷P6225 [eJOI2019] 异或橙子 [eJOI2019] 异或橙子题目描述Janez 喜欢橙子！他制造了一个橙子扫描仪，但是这个扫描仪对于扫描的每个橙子的图像只能输出一个 $32$ 位整数。 他一共扫描了 $n$ 个橙子，但有时他也会重新扫描一个橙子，导致这个橙子的 $32$ 位整数发生更新。 Janez 想要分析这些橙子，他觉得异或操作非常有趣，他每次选取一个区间从 $l$ 至 $u$，他想要得到这个区间内所有子区间的异或和的异或和。 例如 $l&#x3D;2,u&#x3D;4$ 的情况，记橙子序列 $A$ 中第 $i$ 个橙子的整数是 ，那么他要求的就是： $$a_2 \\oplus a_3 \\oplus a_4 \\oplus (a_2\\oplus a_3)\\oplus(a_3\\oplus a_4)\\oplus(a_2\\oplus a_3 \\oplus a_4)$$ 注：式子中的 $\\oplus$ 代表按位异或运算。异或的运算规则如下。 对于两个数的第 $i$ 位，记为 $x,y$，那么： $x$ $y$ $x\\oplus y$ $0$ $1$ $1$ $1$ $0$ $1$ $0$ $0$ $0$ $1$ $1$ $0$ 例：$13\\oplus 23&#x3D;26$ $13&#x3D;$ $0\\cdots 001101$ $23&#x3D;$ $0\\cdots 010111$ $13\\oplus 23&#x3D;$ $0\\cdots 011010$ 输入格式第一行输入两个正整数 $n,q$，表示橙子数量和操作次数。 接下来一行 $n$ 个非负整数，表示每个橙子扫描得到的数值 ，从 $1$ 开始编号。 接下来 $q$ 行，每行三个数： 如果第一个数是 $1$，接下来输入一个正整数 $i$ 与非负整数 $j$，表示将第 $i$ 个橙子的扫描值 $a_i$ 修改为 $j$。 如果第一个数是 $2$，接下来输入两个正整数 $u,l$ 表示询问这个区间的答案。 输出格式对于每组询问，输出一行一个非负整数，表示所求的总异或和。 样例 #1样例输入 #1123453 31 2 32 1 31 1 32 1 3 样例输出 #11220 样例 #2样例输入 #2123456785 61 2 3 4 52 1 31 1 32 1 52 4 41 1 12 4 4 样例输出 #212342544 提示输入输出样例 1 解释 最初，$A&#x3D;[1,2,3]$，询问结果为 $1\\oplus 2\\oplus 3\\oplus(1\\oplus 2)\\oplus (2\\oplus 3)\\oplus(1\\oplus 2\\oplus 3)&#x3D;2$ 修改后，第一个位置被修改为 $3$ ，询问的结果是 $3\\oplus 2\\oplus 3\\oplus(3\\oplus 2)\\oplus (2\\oplus 3)\\oplus(3\\oplus 2\\oplus 3)&#x3D;0$。 数据规模与约定：本题采用多测试点捆绑测试，共有 5 个子任务。 Subtask 1(12 points)：$1\\le n,q\\le 10^2$，无特殊限制 Subtask 2(18 points)：$1\\le n,q\\le 5\\times 10^2$，且没有修改操作。 Subtask 3(25 points)：$1\\le n,q\\le 5\\times 10^3$，无特殊限制 Subtask 4(20 points)：$1\\le n,q\\le 2\\times 10^5$，且没有修改操作。 Subtask 5(25 points)：$1\\le n,q\\le 2\\times 10^5$，无特殊限制 对于所有数据，$0\\le a_i\\le 10^9,1\\le n,q\\le 2\\times 10^5$ 说明原题来自：eJOI2019 Problem A. XORanges 题面&amp;数据来自：LibreOJ 形式化题面： 给定$n,q(1\\le n,q \\le 2\\times 10^5)$及长度为$n$的序列${a_1,a_2,\\cdots,a_n}$，支持以下两种命令 单点修改 查询一段区间所有子区间的异或和的异或和 分析： 性质：$x \\oplus 0&#x3D;x,x\\oplus x &#x3D;0$ 通过手动模拟可以发现：当区间长度为偶数，即$l,u$奇偶性不同时，所有数的贡献都为偶数次，因此答案为$0$；当区间长度为奇数，即$l,u$奇偶性相同时，所有与$l$奇偶性相同的数的贡献为奇数次，其它数的贡献为偶数，所以答案为$a_l\\oplus a_{l+2}\\oplus \\cdot\\cdot\\cdot \\oplus a_u$ 由于是单点修改区间的异或和查询的问题，故可以用树状数组，用两个树状数组分别存储奇数位置和偶数位置的异或值，修改和查询时分别在两个数组中查询即可。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;bits/stdc++.h&gt;using namespace std;const int N=2e5+5;int n,q;int a[N];int tr1[N],tr2[N];int lowbit(int x)&#123; return x&amp;-x;&#125;void add(int x,int c)&#123; if(x%2)for(int i=x;i&lt;=n;i+=lowbit(i))tr1[i]^=c; else for(int i=x;i&lt;=n;i+=lowbit(i))tr2[i]^=c;&#125;int sum1(int x)&#123; int res=0; for(int i=x;i;i-=lowbit(i))res^=tr1[i]; return res;&#125;int sum2(int x)&#123; int res=0; for(int i=x;i;i-=lowbit(i))res^=tr2[i]; return res;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; q; for(int i=1;i&lt;=n;i++)&#123; cin &gt;&gt; a[i]; add(i,a[i]); &#125; for(int i=1;i&lt;=q;i++)&#123; int op,x,y; cin &gt;&gt; op &gt;&gt; x &gt;&gt; y; if(op==1)&#123; add(x,a[x]^y); a[x]=y; &#125; else&#123; if((y-x+1)%2==0)cout &lt;&lt; 0; else&#123; if(x%2==1)&#123; cout &lt;&lt; (sum1(y)^sum1(x-1)); &#125; else&#123; cout &lt;&lt; (sum2(y)^sum2(x-1)); &#125; &#125; cout &lt;&lt; endl; &#125; &#125; return 0;&#125; 例题2：洛谷P3372 【模板】线段树 1（树状数组实现区间操作） 【模板】线段树 1题目描述如题，已知一个数列，你需要进行下面两种操作： 将某区间每一个数加上 $k$。 求出某区间每一个数的和。 输入格式第一行包含两个整数 $n, m$，分别表示该数列数字的个数和操作的总个数。 第二行包含 $n$ 个用空格分隔的整数，其中第 $i$ 个数字表示数列第 $i$ 项的初始值。 接下来 $m$ 行每行包含 $3$ 或 $4$ 个整数，表示一个操作，具体如下： 1 x y k：将区间 $[x, y]$ 内每个数加上 $k$。 2 x y：输出区间 $[x, y]$ 内每个数的和。 输出格式输出包含若干行整数，即为所有操作 2 的结果。 样例 #1样例输入 #112345675 51 5 4 2 32 2 41 2 3 22 3 41 1 5 12 1 4 样例输出 #112311820 提示对于 $30%$ 的数据：$n \\le 8$，$m \\le 10$。对于 $70%$ 的数据：$n \\le {10}^3$，$m \\le {10}^4$。对于 $100%$ 的数据：$1 \\le n, m \\le {10}^5$。 保证任意时刻数列中所有元素的绝对值之和 $\\le {10}^{18}$。 【样例解释】 形式化题面： 给定$n,q(1\\le n,q \\le 10^5)$及长度为$n$的序列，支持区间加，区间查询总和。 分析： 需要实现树状数组的区间修改，可以考虑差分。 先考虑区间加：定义树状数组$b$的每个元素$b_i&#x3D;a_i-a_{i-1}$，则在$[l,r]$区间加$x$即为$b_l+x,b_{r+1}-x$。 在考虑区间查询：此时区间$[l,r]$的和为$\\sum_{i&#x3D;l}^r\\sum_{j&#x3D;1}^ib_j$，考虑每个数的贡献，可以得出：$$\\sum_{i&#x3D;l}^r\\sum_{j&#x3D;1}^ib_j&#x3D;\\sum_{j&#x3D;1}^{l-1}b_j\\times(r-l+1)+\\sum_{j&#x3D;l}^rb_j\\times(r-j+1)$$可以发现，第一部分就是树状数组的前缀和，直接求即可，而第二部分无法直接求出，展开后可以得出：$$\\sum_{j&#x3D;l}^rb_j\\times(r-j+1)&#x3D;\\sum_{j&#x3D;l}^rb_j\\times(r+1)-\\sum_{j&#x3D;l}^rb_j\\times j$$可以发现，第一部分也可以直接求出，而第二部分可以新建一个树状数组$c$，令$c_i&#x3D;b_i\\times i$，即可求出。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;bits/stdc++.h&gt;using namespace std;const int N=1e5+5;typedef long long ll;int n,m;ll a[N];ll b[N],c[N];ll lowbit(ll x)&#123; return x&amp;-x;&#125;ll sum1(ll x)&#123; ll sum=0; for(int i=x;i;i-=lowbit(i))&#123; sum+=b[i]; &#125; return sum;&#125;ll sum2(ll x)&#123; ll sum=0; for(int i=x;i;i-=lowbit(i))&#123; sum+=c[i]; &#125; return sum;&#125;void add1(ll x,ll k)&#123; for(int i=x;i&lt;=n;i+=lowbit(i))&#123; b[i]+=k; &#125;&#125;void add2(ll x,ll k)&#123; for(int i=x;i&lt;=n;i+=lowbit(i))&#123; c[i]+=x*k; &#125;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i=1;i&lt;=n;i++)&#123; cin &gt;&gt; a[i]; &#125; for(int i=1;i&lt;=n;i++)&#123; b[i]+=a[i]-a[i-1]; int j=i+lowbit(i); if(j&lt;=n)b[j]+=b[i]; &#125; for(int i=1;i&lt;=n;i++)&#123; c[i]+=(a[i]-a[i-1])*i; int j=i+lowbit(i); if(j&lt;=n)c[j]+=c[i]; &#125; for(int i=1;i&lt;=m;i++)&#123; int op; cin &gt;&gt; op; if(op==1)&#123; ll l,r,x; cin &gt;&gt; l &gt;&gt; r &gt;&gt; x; add1(l,x),add1(r+1,-x); add2(l,x),add2(r+1,-x); &#125; else&#123; ll l,r; cin &gt;&gt; l &gt;&gt; r; cout &lt;&lt; sum1(l-1)*(r-l+1)+(sum1(r)-sum1(l-1))*(r+1)-(sum2(r)-sum2(l-1)) &lt;&lt; endl; &#125; &#125; return 0;&#125; 例题3：树状数组上倍增形式化题面： 给定长度为 $n(n \\le 10^5 )$ 的序列 $a$ 和$ q(q \\le 10^5 ) $次命令，每次命令形如$ x, y, k$，表示将 $a_x$ 改为 $y$，并立即查询序列中第 $k$ 小的数。 保证任意时刻 $a$ 中的任意元素均不超过 $10^5$。 分析： 先考虑暴力做法，考虑二分答案，建立一个存储每个数的出现次数的树状数组，每次二分并查询前缀和，复杂度为$O(n\\log^2n)$。 考虑优化，使用倍增，令$d&#x3D;\\lceil \\log_2n\\rceil,\\cdots,1,0$，将初始为$0$的$ans$每次加上$2^d$，判断是否合法即可。可以发现新增的区间为$[ans+1,ans+2^d]$，而这刚好对应树状数组中第$2^d$位的值($ans$在二进制下的最低位一定为$2^d$，而树状数组每个点对应的区间，即支配区间为$[x-lowbit(x)+1,x]$，刚好就是新增的区间)，因此可以使用倍增。 注意：倍增时为了防止出现当加上当前位个数超过$k$，不加当前位个数少于$k$的情况，可以判断个数小于$k$，最后的答案加$1$即可。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;using namespace std;const int N=1e5+5;int n,q;int inc[20];int a[N],cnt[N],b[N];int last[20];int lowbit(int x)&#123; return x&amp;-x;&#125;void change(int x,int k)&#123; for(int i=a[x];i&lt;N;i+=lowbit(i))&#123; b[i]--; &#125; for(int i=k;i&lt;N;i+=lowbit(i))&#123; b[i]++; &#125; a[x]=k;&#125;int main()&#123; for(int i=0,j=1;i&lt;=17;i++)&#123; inc[i]=j; j&lt;&lt;=1; &#125; cin &gt;&gt; n &gt;&gt; q; for(int i=1;i&lt;=n;i++)&#123; cin &gt;&gt; a[i]; cnt[a[i]]++; &#125; for(int i=1;i&lt;N;i++)&#123; b[i]+=cnt[i]; int j=i+lowbit(i); if(j&lt;N)b[j]+=b[i]; &#125; for(int i=1;i&lt;=q;i++)&#123; int x,y,k; cin &gt;&gt; x &gt;&gt; y &gt;&gt; k; change(x,y); int cnt=0,ans=0; for(int j=17;j&gt;=0;j--)&#123; ans+=1&lt;&lt;j; if(ans&gt;=N||cnt+b[ans]&gt;=k)ans-=1&lt;&lt;j; else cnt+=b[ans]; &#125; cout &lt;&lt; ans+1 &lt;&lt; endl; &#125; return 0;&#125; 线段树线段树是一种分治型结构，每个结点维护一个区间的信息。线段树的根为$[1,n]$。对于每个节点$[l,r]$，令$mid&#x3D;\\lfloor\\frac{l+r}{2}\\rfloor$，则其左儿子为$[l,m]$，右儿子为$[m+1,r]$。 线段树的基础操作包括单点修改查询，区间修改（懒标记），区间查询。 模板： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e6+5;typedef long long ll;ll a[maxn],w[maxn*4];void pushup(const int u)&#123; w[u]=w[u*2]+w[u*2+1];&#125;//建立线段树void build(const int u,int L,int R)&#123; if(L==R)&#123; w[u]=a[L]; return; &#125; int M=(L+R)/2; build((u*2),L,M); build((u*2)+1,M+1,R); pushup(u);&#125;//懒标记ll lzy[maxn*4];void maketag(int u,int len,ll x)&#123; lzy[u]+=x; w[u]+=len*x;&#125;void pushdown(int u,int L,int R)&#123; int M=(L+R)/2; maketag(u*2,M-L+1,lzy[u]); maketag(u*2+1,R-M,lzy[u]); lzy[u]=0;&#125;//单点查询修改ll query1(int u,int L,int R,int p)&#123; pushdown(u,L,R); if(L==R)&#123; return w[u]; &#125; else &#123; int M=(L+R)/2; if(M&gt;=p) return query1((u*2),L,M,p); else return query1((u*2)+1,M+1,R,p); &#125; return 0;&#125;void update1(int u,int L,int R,int p,ll x)&#123; if(L==R)&#123; w[u]=x; &#125; else&#123; int M=(L+R)/2; if(M&gt;=p) update1((u*2),L,M,p,x); else update1((u*2)+1,M+1,R,p,x); pushup(u); &#125;&#125;//区间查询bool InRange(int L,int R,int l,int r)&#123; return (l&lt;=L)&amp;&amp;(R&lt;=r);&#125;bool OutofRange(int L,int R,int l,int r)&#123; return (L&gt;r)||(R&lt;l);&#125;ll query(int u,int L,int R,int l,int r)&#123; if(InRange(L,R,l,r))&#123; return w[u]; &#125; if(OutofRange(L,R,l,r)) return 0; else&#123; int M=(L+R)/2; pushdown(u,L,R); return query((u*2),L,M,l,r)+query((u*2)+1,M+1,R,l,r); &#125; return 0;&#125;//修改void update(int u,int L,int R,int l,int r,ll x)&#123; if(InRange(L,R,l,r))&#123; maketag(u,R-L+1,x); &#125; else if(!OutofRange(L,R,l,r))&#123; int M=(L+R)/2; pushdown(u,L,R); update((u*2),L,M,l,r,x); update((u*2)+1,M+1,R,l,r,x); pushup(u); &#125;&#125;int main()&#123; ios::sync_with_stdio(false); int n,m; cin &gt;&gt; n &gt;&gt; m; for(int i=1;i&lt;=n;i++)&#123; cin &gt;&gt; a[i];//输入每一项的值 &#125; build(1,1,n);//建立线段树 for(int t=1;t&lt;=m;t++)&#123; int op,x,y; ll k; cin &gt;&gt; op; if(op==1)&#123; cin &gt;&gt; x &gt;&gt; y &gt;&gt; k; update(1,1,n,x,y,k);//修改，x到y加k &#125; else&#123; cin &gt;&gt; x &gt;&gt; y; cout &lt;&lt; query(1,1,n,x,y) &lt;&lt; endl;//查询x到y &#125; &#125; return 0;&#125; 线段树的使用条件： 对于一个操作含区间修改，区间查询的问题，什么时候可以使用线段树？ 对于一次区间修改，若要对某个节点打上标记，能够快速更新该节点的信息(update &amp; pushdown) 标记在知晓前后顺序时能够合并(pushdown) 对于所有无标记的节点，能够根据两个子节点的信息，推出当前节点的信息(pushup) 综上，可以实现update，pushdown，pushup就可以使用线段树 线段树标记永久化： 什么时候可以不下传标记？ 有些时候是可以的，例如： 区间加，区间查询和问题。对于一次查询，设目前查询区间为$[l,r]$，查询区间为$[L,R]$，设该点处的懒标记为$ v$，则能产生$[l,r],[L,R]$交的长度$\\times v$的贡献，额外加上即可。 有些时候并不可以的，例如： 区间赋值，区间查询和问题。 维护若干个等长向量，每次将一段区间发向量乘上某个矩阵、区间查询向量和问题。 综上，线段树能够实现标记永久化，必须满足懒标记的合并具有交换律，即懒标记合并的结果与它们的先后顺序无关。 例题1：洛谷P3401改编（线段树维护复杂信息）形式化题面： 给定$n,q(1 \\le n,q \\le 10^5)$及长度为$n$的序列，支持单点修改，查询一个区间的所有子区间的异或和的总和。保证序列中的每个元素$\\le 1023$ 分析： 可以考虑拆位维护。 对于二进制下的第$d$位，建立一个线段树维护区间的异或和为$1$的子区间个数，最后将答案加上个数乘上$2^d$即可。 考虑如何维护节点信息，即通过两个子节点得到当前节点的异或和为$1$的子区间个数，可以发现这个值就是左右儿子自己的异或和为$1$的子区间个数与跨越中点的异或和为$1$的子区间个数之和，因此可以在每个点上维护$p0,p1,q0,q1$，分别表示前缀异或和为$0,1$，后缀异或和为$0,1$的个数，设一个节点的左右儿子为$L,R$，则这个节点的跨越中点的异或和为$1$的子区间个数为$q0(L)\\times p1(R)+q1(L)\\times p0(R)$。 考虑如何维护$p0,p1,q0,q1$。 若左子区间的异或和为$0$，则$p0&#x3D;p0(L)+p0(R),p1&#x3D;p1(L)+p1(R)$ 若左子区间的异或和为$1$，则$p0&#x3D;p0(L)+p1(R),p1&#x3D;p1(L)+p0(R)$ 若右子区间的异或和为$0$，则$q0&#x3D;q0(R)+q0(L),q1&#x3D;q1(R)+q1(L)$ 若右子区间的异或和为$1$，则$q0&#x3D;q0(R)+q1(L),q1&#x3D;q1(R)+q0(L)$ 因此还需维护$sum$，表示区间的异或和。 考虑如何查询，可以重载$+$号，当区间合并时按照上面的步骤计算出新的区间即可。 总的时间复杂度为$O(n\\log^2n)$ 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll N=1e5+5;struct node&#123; ll cnt; bool sum; ll p0,p1,q0,q1; ll len; friend node operator+(node a,node b)&#123; node c; if(a.len==0&amp;&amp;b.len)return b; if(a.len&amp;&amp;b.len==0)return a; if(a.len==0&amp;&amp;b.len==0)return c; c.len=a.len+b.len; c.sum=a.sum^b.sum; c.cnt=a.cnt+b.cnt+a.q0*b.p1+a.q1*b.p0; if(a.sum==0)&#123; c.p0=a.p0+b.p0; c.p1=a.p1+b.p1; &#125; else&#123; c.p0=a.p0+b.p1; c.p1=a.p1+b.p0; &#125; if(b.sum==0)&#123; c.q0=b.q0+a.q0; c.q1=b.q1+a.q1; &#125; else&#123; c.q0=b.q0+a.q1; c.q1=b.q1+a.q0; &#125; return c; &#125;&#125;tr[12][4*N],empty;ll n,q;void init(int k,int u,int l,int r)&#123;\tif(l&gt;r)return;\ttr[k][u].len=r-l+1;\tif(l&lt;r)&#123; int mid=l+r&gt;&gt;1; init(k,u&lt;&lt;1,l,mid); init(k,u&lt;&lt;1|1,mid+1,r);\t&#125;&#125;void pushup(ll k,ll u)&#123; tr[k][u]=tr[k][u&lt;&lt;1]+tr[k][u&lt;&lt;1|1];&#125;void change(ll k,ll to,ll u,ll l,ll r,ll x)&#123; if(l==r)&#123; node &amp;t=tr[k][u]; t.sum=x; if(x)&#123; t.cnt=1; t.p0=0; t.p1=1; t.q0=0; t.q1=1; &#125; else&#123; t.cnt=0; t.p0=1; t.p1=0; t.q0=1; t.q1=0; &#125; return; &#125; ll mid=l+r&gt;&gt;1; if(to&lt;=mid)change(k,to,u&lt;&lt;1,l,mid,x); else change(k,to,u&lt;&lt;1|1,mid+1,r,x); pushup(k,u);&#125;void modify(ll x,ll k)&#123; ll wei=0; while(k)&#123; ll t=k%2; change(wei,x,1,1,n,t); k&gt;&gt;=1; wei++; &#125; for(int i=wei;i&lt;10;i++)&#123; change(i,x,1,1,n,0);//清空高位 &#125;&#125;node query(ll k,ll u,ll l,ll r,ll L,ll R)&#123;\tif(R&lt;l||L&gt;r)&#123; return empty; &#125; if(L&lt;=l&amp;&amp;R&gt;=r)&#123; return tr[k][u]; &#125; ll mid=l+r&gt;&gt;1; return query(k,u&lt;&lt;1,l,mid,L,R)+query(k,u&lt;&lt;1|1,mid+1,r,L,R);&#125;ll find(ll l,ll r)&#123; ll res=0; for(ll i=0;i&lt;=10;i++)&#123; node t=query(i,1,1,n,l,r); res+=t.cnt*(1&lt;&lt;i); &#125; return res;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; q;\tfor(int i=0;i&lt;=10;i++)&#123; init(i,1,1,n); &#125; for(ll i=1;i&lt;=n;i++)&#123; ll x; cin &gt;&gt; x; modify(i,x); &#125; for(ll i=1;i&lt;=q;i++)&#123; ll op,a,b; cin &gt;&gt; op &gt;&gt; a &gt;&gt; b; if(op==1)&#123; modify(a,b); &#125; else&#123; cout &lt;&lt; find(a,b) &lt;&lt; endl; &#125; &#125; return 0;&#125; 例题2：洛谷P4198 楼房重建（线段树维护前缀最值） 楼房重建题目描述小 A 的楼房外有一大片施工工地，工地上有 $N$ 栋待建的楼房。每天，这片工地上的房子拆了又建、建了又拆。他经常无聊地看着窗外发呆，数自己能够看到多少栋房子。 为了简化问题，我们考虑这些事件发生在一个二维平面上。小 A 在平面上 $(0,0)$ 点的位置，第 $i$ 栋楼房可以用一条连接 $(i,0)$ 和 $(i,H_i)$ 的线段表示，其中 $H_i$ 为第 $i$ 栋楼房的高度。如果这栋楼房上任何一个高度大于 $0$ 的点与 $(0,0)$ 的连线没有与之前的线段相交，那么这栋楼房就被认为是可见的。 施工队的建造总共进行了 $M$ 天。初始时，所有楼房都还没有开始建造，它们的高度均为 $0$。在第 $i$ 天，建筑队将会将横坐标为 $X_i$ 的房屋的高度变为 $Y_i$（高度可以比原来大—修建，也可以比原来小—拆除，甚至可以保持不变—建筑队这天什么事也没做）。请你帮小 A 数数每天在建筑队完工之后，他能看到多少栋楼房？ 输入格式第一行两个正整数 $N,M$。 接下来 $M$ 行，每行两个正整数 $X_i,Y_i$。 输出格式$M$ 行，第 $i$ 行一个整数表示第 $i$ 天过后小 A 能看到的楼房有多少栋。 样例 #1样例输入 #1123453 42 43 61 10000000001 1 样例输出 #112341112 提示对于 $100%$ 的数据，$1 \\le X_i \\le N$，$1 \\le Y_i \\le 10^9$，$1\\le N,M \\le 10^5$。 分析： 使用线段树维护区间内可以被看见的楼房数，考虑如何维护信息。 用线段树记录每个点的斜率，若这个点前面的所有点的斜率均小于这个点的斜率，则当前楼房可以被看见。 设左儿子为$L$，右儿子为$R$，右儿子的左右儿子为$R_L,R_R$，下面分情况考虑： 当$L$的最大值$M$大于等于$R_L$的最大值$m$时，$R_L$产生不了任何贡献，递归求$R_R$的贡献即可。 当$L$的最大值$M$小于$R_L$的最大值$m$时，$L$对于$R_R$产生不了影响，而$R_R$的贡献在计算$R$时已经求出，因此只需递归求$R_L$的贡献即可。 因此需维护可以被看见的楼房数$cnt$，区间最大值$max$和右子区间的贡献$conribution$即可。 记$solve(R,M)$为右儿子的贡献，则当$M\\ge m$时，$solve(R,M)&#x3D;solve(R_R,M)$，当$M&lt;m$时，$solve(R,M)&#x3D;solve(R_L,M)+contribution_{R_R}$。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;using namespace std;const int N=4e5+5;int n,m;double tr_max[N];int len[N];double a[N];int solve(int u,int l,int r,double maxh)&#123; if(l==r)&#123; if(a[l]&gt;maxh)return 1; return 0; &#125; if(tr_max[u]&lt;=maxh)return 0; if(a[l]&gt;maxh)return len[u]; int mid=l+r&gt;&gt;1; if(tr_max[u&lt;&lt;1]&lt;=maxh)return solve(u&lt;&lt;1|1,mid+1,r,maxh); return solve(u&lt;&lt;1,l,mid,maxh)+len[u]-len[u&lt;&lt;1];&#125;void pushup(int u)&#123; tr_max[u]=max((double)tr_max[u&lt;&lt;1],(double)tr_max[u&lt;&lt;1|1]);&#125;void change(int u,int l,int r,int x,int k)&#123; if(l==r&amp;&amp;l==x)&#123; tr_max[u]=(double)k/(double)x; len[u]=1; return; &#125; int mid=l+r&gt;&gt;1; if(x&lt;=mid)change(u&lt;&lt;1,l,mid,x,k); else change(u&lt;&lt;1|1,mid+1,r,x,k); pushup(u); len[u]=len[u&lt;&lt;1]+solve(u&lt;&lt;1|1,mid+1,r,tr_max[u&lt;&lt;1]);&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i=1;i&lt;=m;i++)&#123; int x,y; cin &gt;&gt; x &gt;&gt; y; a[x]=(double)y/(double)x; change(1,1,n,x,y); cout &lt;&lt; len[1] &lt;&lt; endl; &#125; return 0;&#125; 例题3：洛谷P7453（线段树维护矩阵） [THUSCH2017] 大魔法师题目描述大魔法师小 L 制作了 $n$ 个魔力水晶球，每个水晶球有水、火、土三个属性的能量值。小 L 把这 $n$ 个水晶球在地上从前向后排成一行，然后开始今天的魔法表演。 我们用 $A_i,B_i,C_i$ 分别表示从前向后第 $i$ 个水晶球（下标从 $1$ 开始）的水、火、土的能量值。 小 L 计划施展 $m$ 次魔法。每次，他会选择一个区间 $[l,r]$，然后施展以下 $3$ 大类、$7$ 种魔法之一： 魔力激发：令区间里每个水晶球中特定属性的能量爆发，从而使另一个特定属性的能量增强。具体来说，有以下三种可能的表现形式： 火元素激发水元素能量：令 $A_i&#x3D;A_i+B_i$。 土元素激发火元素能量：令 $B_i&#x3D;B_i+C_i$。 水元素激发土元素能量：令 $C_i&#x3D;C_i+A_i$。 需要注意的是，增强一种属性的能量并不会改变另一种属性的能量，例如 $A_i&#x3D;A_i+B_i$ 并不会使 $B_i$ 增加或减少。 魔力增强：小 L 挥舞法杖，消耗自身 $v$ 点法力值，来改变区间里每个水晶球的特定属性的能量。具体来说，有以下三种可能的表现形式： 火元素能量定值增强：令 $A_i&#x3D;A_i+v$。 水元素能量翻倍增强：令 $B_i&#x3D;B_i\\times v$。 土元素能量吸收融合：令 $C_i&#x3D;v$。 魔力释放：小 L 将区间里所有水晶球的能量聚集在一起，融合成一个新的水晶球，然后送给场外观众。生成的水晶球每种属性的能量值等于区间内所有水晶球对应能量值的代数和。需要注意的是，魔力释放的过程不会真正改变区间内水晶球的能量。 值得一提的是，小 L 制造和融合的水晶球的原材料都是定制版的 OI 工厂水晶，所以这些水晶球有一个能量阈值 $998244353$。当水晶球中某种属性的能量值大于等于这个阈值时，能量值会自动对阈值取模，从而避免水晶球爆炸。 小 W 为小 L（唯一的）观众，围观了整个表演，并且收到了小 L 在表演中融合的每个水晶球。小 W 想知道，这些水晶球蕴涵的三种属性的能量值分别是多少。 输入格式从标准输入读入数据。 我们将上述的 $7$ 种魔法，从上到下依次标号为 $1\\sim7$。 输入的第一行包含一个整数 $n$（$1\\le n\\le 2.5\\times 10^5$），表示水晶球个数。 接下来 $n$ 行，每行空格隔开的 $3$ 个整数，其中第 $i$ 行的三个数依次表示 $A_i,B_i,C_i$。 接下来一行包含一个整数 $m$（$1\\le m\\le2.5\\times 10^5$），表示施展魔法的次数。 接下来 $m$ 行，每行 $3$ 或 $4$ 个数，格式为 opt l r (v)。其中 opt 表示魔法的编号，$l,r$ 表示施展魔法的区间（保证有 $l\\le r$）。特别地，如果施展 $4\\sim6$ 号魔法（魔力增强），则还有一个整数 $v$，表示小 L 消耗的法力值。 输出格式输出到标准输出。 对每个 $7$ 号魔法（魔力释放），输出一行、空格隔开的 $3$ 个整数 a b c，分别表示此次融合得到的水晶球的水、火、土元素能量值。 样例 #1样例输入 #11234567822 3 36 6 647 1 21 1 24 1 2 37 1 2 样例输出 #1128 9 923 9 9 提示$100%$ 的数据，$n,m\\le2.5\\times 10^5,0\\le A_i,B_i,C_i,v&lt;998244353$ $10%$ 的数据，$n\\times m\\le10^7$。 另外 $10%$ 的数据，每次魔法的区间均为 $[1,n]$。 另外 $10%$ 的数据，每次非询问魔法的影响区间均为 $[1,n]$，所有修改在询问之前。 另外 $10%$ 的数据，$\\operatorname{opt}\\in{4,5,6,7}$。 另外 $15%$ 的数据，$\\operatorname{opt}\\in{1,2,7}$。 另外 $15%$ 的数据，$\\operatorname{opt}\\in{1,2,3,5,7}$。 另外 $15%$ 的数据，$n,m\\le 10^5$。 其他数据，无特殊约定。 样例解释以下展示每次施展魔法后，两个水晶球内的能量： 1234(2, 3, 3) (6, 6, 6)(5, 3, 3) (12, 6, 6)(8, 3, 3) (15, 6, 6)(8, 3, 3) (15, 6, 6) 分析：可以把$a_i,b_i,b_i$看作一个向量$\\begin{vmatrix}a_i &amp; b_i &amp; c_i\\end{vmatrix}$，则对于第一种操作，只需乘上$$\\begin{vmatrix}1 &amp; 0 &amp; 0\\1 &amp; 1 &amp; 0\\0 &amp; 0 &amp; 1\\end{vmatrix},\\begin{vmatrix}1 &amp; 0 &amp; 0\\0 &amp; 1 &amp; 0\\0 &amp; 1 &amp; 1\\end{vmatrix},\\begin{vmatrix}1 &amp; 0 &amp; 1\\0 &amp; 1 &amp; 0\\0 &amp; 0 &amp; 1\\end{vmatrix}$$即可。而对于第二种操作，可以令把向量加上一个元素变为：$\\begin{vmatrix}a_i &amp; b_i &amp; c_i &amp; 1\\end{vmatrix}$，则对于第二种操作，只需乘上$$\\begin{vmatrix}1 &amp; 0 &amp; 0 &amp; 0\\0 &amp; 1 &amp; 0 &amp; 0\\0 &amp; 0 &amp; 1 &amp; 0\\v &amp; 0 &amp; 0 &amp; 1\\end{vmatrix},\\begin{vmatrix} 1 &amp; 0 &amp; 0 &amp; 0\\ 0 &amp; v &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 1 &amp; 0\\ 0 &amp; 0 &amp; 0 &amp; 1\\end{vmatrix},\\begin{vmatrix} 1 &amp; 0 &amp; 0 &amp; 0\\ 0 &amp; 1 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; v &amp; 1\\end{vmatrix}$$即可。因此，所有的操作乘上的矩阵为$$\\begin{vmatrix}1 &amp; 0 &amp; 0 &amp; 0\\1 &amp; 1 &amp; 0 &amp; 0\\0 &amp; 0 &amp; 1 &amp; 0\\0 &amp; 0 &amp; 0 &amp; 1\\end{vmatrix},\\begin{vmatrix}1 &amp; 0 &amp; 0 &amp; 0\\0 &amp; 1 &amp; 0 &amp; 0\\0 &amp; 1 &amp; 1 &amp; 0\\0 &amp; 0 &amp; 0 &amp; 1\\end{vmatrix},\\begin{vmatrix}1 &amp; 0 &amp; 1 &amp; 0\\0 &amp; 1 &amp; 0 &amp; 0\\0 &amp; 0 &amp; 1 &amp; 0\\0 &amp; 0 &amp; 0 &amp; 1\\end{vmatrix},\\begin{vmatrix}1 &amp; 0 &amp; 0 &amp; 0\\0 &amp; 1 &amp; 0 &amp; 0\\0 &amp; 0 &amp; 1 &amp; 0\\v &amp; 0 &amp; 0 &amp; 1\\end{vmatrix},\\begin{vmatrix} 1 &amp; 0 &amp; 0 &amp; 0\\ 0 &amp; v &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 1 &amp; 0\\ 0 &amp; 0 &amp; 0 &amp; 1\\end{vmatrix},\\begin{vmatrix} 1 &amp; 0 &amp; 0 &amp; 0\\ 0 &amp; 1 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; v &amp; 1\\end{vmatrix}$$其余操作与普通线段树相同，但要注意卡常。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204#include&lt;bits/stdc++.h&gt;using namespace std;const int N=250005,mod=998244353;struct matrix&#123; int sum[4][4]; matrix()&#123; for(int i=0;i&lt;4;i++)&#123; for(int j=0;j&lt;4;j++)&#123; sum[i][j]=0; &#125; &#125; &#125; matrix(int t[4][4])&#123; for(int i=0;i&lt;4;i++)&#123; for(int j=0;j&lt;4;j++)&#123; sum[i][j]=t[i][j]; &#125; &#125; &#125; inline void operator=(matrix x)&#123; for(int i=0;i&lt;4;i++)&#123; for(int j=0;j&lt;4;j++)&#123; sum[i][j]=x.sum[i][j]; &#125; &#125; &#125; friend matrix operator+(matrix x,matrix y)&#123; matrix a; for(int i=0;i&lt;4;i++)&#123; for(int j=0;j&lt;4;j++)&#123; a.sum[i][j]=x.sum[i][j]+y.sum[i][j]; if(a.sum[i][j]&gt;=mod)a.sum[i][j]-=mod; &#125; &#125; return a; &#125; friend matrix operator*(matrix x,matrix y)&#123; matrix a; for(int i=0;i&lt;4;i++)&#123; for(int j=0;j&lt;4;j++)&#123; a.sum[i][j]=a.sum[i][j]+(1ll*x.sum[i][0]*y.sum[0][j])%mod; if(a.sum[i][j]&gt;=mod)a.sum[i][j]-=mod; a.sum[i][j]=a.sum[i][j]+(1ll*x.sum[i][1]*y.sum[1][j])%mod; if(a.sum[i][j]&gt;=mod)a.sum[i][j]-=mod; a.sum[i][j]=a.sum[i][j]+(1ll*x.sum[i][2]*y.sum[2][j])%mod; if(a.sum[i][j]&gt;=mod)a.sum[i][j]-=mod; a.sum[i][j]=a.sum[i][j]+(1ll*x.sum[i][3]*y.sum[3][j])%mod; if(a.sum[i][j]&gt;=mod)a.sum[i][j]-=mod; &#125; &#125; return a; &#125; friend bool operator==(matrix x,matrix y)&#123; for(int i=0;i&lt;4;i++)&#123; for(int j=0;j&lt;4;j++)&#123; if(x.sum[i][j]!=y.sum[i][j])return 0; &#125; &#125; return 1; &#125;&#125;;int n,m;matrix a[N];matrix tr[4*N];matrix lazy[4*N];matrix type[7];int typed[7][4][4]=&#123; &#123; &#123;1,0,0,0&#125;, &#123;0,1,0,0&#125;, &#123;0,0,1,0&#125;, &#123;0,0,0,1&#125; &#125;, &#123; &#123;1,0,0,0&#125;, &#123;1,1,0,0&#125;, &#123;0,0,1,0&#125;, &#123;0,0,0,1&#125; &#125;, &#123; &#123;1,0,0,0&#125;, &#123;0,1,0,0&#125;, &#123;0,1,1,0&#125;, &#123;0,0,0,1&#125; &#125;, &#123; &#123;1,0,1,0&#125;, &#123;0,1,0,0&#125;, &#123;0,0,1,0&#125;, &#123;0,0,0,1&#125; &#125;, &#123; &#123;1,0,0,0&#125;, &#123;0,1,0,0&#125;, &#123;0,0,1,0&#125;, &#123;-1,0,0,1&#125; &#125;, &#123; &#123;1,0,0,0&#125;, &#123;0,-1,0,0&#125;, &#123;0,0,1,0&#125;, &#123;0,0,0,1&#125; &#125;, &#123; &#123;1,0,0,0&#125;, &#123;0,1,0,0&#125;, &#123;0,0,0,0&#125;, &#123;0,0,-1,1&#125; &#125;&#125;;void init()&#123; type[0]=matrix(typed[0]); type[1]=matrix(typed[1]); type[2]=matrix(typed[2]); type[3]=matrix(typed[3]); type[4]=matrix(typed[4]); type[5]=matrix(typed[5]); type[6]=matrix(typed[6]);&#125;void pushup(int u)&#123; tr[u]=tr[u&lt;&lt;1]+tr[u&lt;&lt;1|1];&#125;void build(int u,int l,int r)&#123; lazy[u]=type[0]; if(l==r)&#123; tr[u]=a[l]; return; &#125; int mid=l+r&gt;&gt;1; build(u&lt;&lt;1,l,mid); build(u&lt;&lt;1|1,mid+1,r); pushup(u);&#125;void pushdown(int u,int l,int r)&#123; if(lazy[u]==type[0])return; int mid=l+r&gt;&gt;1; lazy[u&lt;&lt;1]=lazy[u&lt;&lt;1]*lazy[u]; lazy[u&lt;&lt;1|1]=lazy[u&lt;&lt;1|1]*lazy[u]; tr[u&lt;&lt;1]=tr[u&lt;&lt;1]*lazy[u]; tr[u&lt;&lt;1|1]=tr[u&lt;&lt;1|1]*lazy[u]; lazy[u]=type[0];&#125;void modify(int u,int l,int r,int L,int R,int x)&#123; if(l&gt;=L&amp;&amp;r&lt;=R)&#123; tr[u]=tr[u]*type[x]; lazy[u]=lazy[u]*type[x]; return; &#125; pushdown(u,l,r); int mid=l+r&gt;&gt;1; if(L&lt;=mid)modify(u&lt;&lt;1,l,mid,L,R,x); if(R&gt;mid)modify(u&lt;&lt;1|1,mid+1,r,L,R,x); pushup(u);&#125;matrix query(int u,int l,int r,int L,int R)&#123; if(l&gt;=L&amp;&amp;r&lt;=R)&#123; return tr[u]; &#125; pushdown(u,l,r); int mid=l+r&gt;&gt;1; if(L&lt;=mid&amp;&amp;R&gt;mid)return query(u&lt;&lt;1,l,mid,L,R)+query(u&lt;&lt;1|1,mid+1,r,L,R); else if(L&lt;=mid)return query(u&lt;&lt;1,l,mid,L,R); else if(R&gt;mid)return query(u&lt;&lt;1|1,mid+1,r,L,R);&#125;int main()&#123; init(); cin &gt;&gt; n ; for(int i=1;i&lt;=n;i++)&#123; cin &gt;&gt; a[i].sum[0][0] &gt;&gt; a[i].sum[0][1] &gt;&gt; a[i].sum[0][2]; a[i].sum[0][3]=1; &#125; build(1,1,n); cin &gt;&gt; m; for(int i=1;i&lt;=m;i++)&#123; int opt,l,r; cin &gt;&gt; opt &gt;&gt; l &gt;&gt; r; if(opt&lt;=3)&#123; modify(1,1,n,l,r,opt); &#125; else if(opt&lt;=6)&#123; int v; cin &gt;&gt; v; type[4].sum[3][0]=v; type[5].sum[1][1]=v; type[6].sum[3][2]=v; modify(1,1,n,l,r,opt); &#125; else&#123; matrix ans=query(1,1,n,l,r); cout &lt;&lt; ans.sum[0][0]%mod &lt;&lt; &#x27; &#x27; &lt;&lt; ans.sum[0][1]%mod &lt;&lt; &#x27; &#x27; &lt;&lt; ans.sum[0][2]%mod &lt;&lt; endl; &#125; &#125; return 0;&#125; 权值线段树：权值线段树与线段树的结构完全相同，基本操作也相同。 二者的主要区别在于：前者维护了桶相关信息，后者维护了序列区间信息。 例如，前者支持查询序列中有多少个数落在给定区间内，后者支持查询序列一段区间的和。 动态开点线段树： 有些时候，线段树维护的值域$V$很大，不能将整个结构建出。 注意到，每次修改只会涉及$O(\\log V)$个位置，我们考虑只建出所有有用的点，从而保证线段树的大小不超过$O(q \\log V)$。 具体来说： 对于修改操作，我们仍套用普通线段树的操作；特别的，若发现当前节点为空，则新建一个点作为当前点。注意：传参时，一定要传入引用，保证新建节点的赋值正确。 对于查询操作，我们仍套用普通线段树的查询；特别的，若发现当前节点为空，则立即返回。 值得注意的是，此时点$u$的左儿子不一定是$2u$，右儿子也不一定是$2u+1$，而可能为任意值。 模板（单点修改，区间查询）： 12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;const int N=1e5+5;struct node&#123; int l,r; int sum;&#125;tr[N];int cnt;void pushup(int u)&#123; tr[u].sum=tr[tr[u].l].sum+tr[tr[u].r].sum;&#125;void change(int &amp;u,int l,int r,int x,int k)&#123; if(!u)u=++cnt; if(l==r)&#123; tr[u].sum+=k; return; &#125; int mid=l+r&gt;&gt;1; if(x&lt;=mid)change(tr[u].l,l,mid,x,k); else change(tr[u].r,mid+1,r,x,k); pushup(u);&#125;int query(int u,int l,int r,int L,int R)&#123; if(!u)return 0; if(R&lt;l||L&gt;r)return 0; if(l&gt;=L&amp;&amp;r&lt;=R)return tr[u].sum; int mid=l+r&gt;&gt;1; return query(tr[u].l,l,mid,L,R)+query(tr[u].r,mid+1,r,L,R);&#125;int main()&#123; return 0;&#125; 例题4：权值线段树上二分形式化题面： 给定长度为 $n(n \\le 10^5 )$ 的序列 $a$ 和$ q(q \\le 10^5 ) $次命令，每次命令形如$ x, y, k$，表示将 $a_x$ 改为 $y$，并立即查询序列中第 $k$ 小的数。 保证任意时刻 $a$ 中的任意元素均不超过 $10^9$。 分析： 建立一个权值线段树记录区间数的个数，查询时从根节点开始，如果当前节点的左儿子的数的个数$\\ge k$，则查找左儿子中第$k$小的数，否则查找右儿子中第$k$减去左儿子中数的个数的数，查到叶节点即可。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;using namespace std;const int N=1e5+5,MAX=1e9;struct node&#123; int l,r; int sum;&#125;tr[120*N];int cnt,root;void pushup(int u)&#123; tr[u].sum=tr[tr[u].l].sum+tr[tr[u].r].sum;&#125;void change(int &amp;u,int l,int r,int x,int k)&#123; if(!u)u=++cnt; if(l==r)&#123; tr[u].sum+=k; return; &#125; int mid=l+r&gt;&gt;1; if(x&lt;=mid)change(tr[u].l,l,mid,x,k); else change(tr[u].r,mid+1,r,x,k); pushup(u);&#125;int find(int u,int l,int r,int k)&#123; if(!u)return 0; if(l==r)return l; int mid=l+r&gt;&gt;1; if(tr[tr[u].l].sum&gt;=k)return find(tr[u].l,l,mid,k); return find(tr[u].r,mid+1,r,k-tr[tr[u].l].sum);&#125;int n,m;int a[N];int main()&#123; root=1,cnt=1; cin &gt;&gt; n &gt;&gt; m; for(int i=1;i&lt;=n;i++)&#123; cin &gt;&gt; a[i]; change(root,1,MAX,a[i],1); &#125; for(int i=1;i&lt;=m;i++)&#123; int x,y,k; cin &gt;&gt; x &gt;&gt; y &gt;&gt; k; change(root,1,MAX,a[x],-1); change(root,1,MAX,y,1); a[x]=y; cout &lt;&lt; find(root,1,MAX,k) &lt;&lt; endl; &#125; return 0;&#125; 线段树合并：权值线段树支持合并。 两个权值线段树$T_1,T_2$的合并是递归过程。具体来说，设目前要合并的两个子树分别为$T_1$中节点$x$，$T_2$中节点$y$的子树，其对应区间均为$[l,r]$，那么： 首先，若$x&#x3D;0$或$y&#x3D;0$，则$x,y$至少一者对应一个空节点，直接返回$x+y$即可。 先将$x,y$的左儿子合并，设合并后的节点编号为$p$。 再将$x,y$的右儿子合并，设合并后的节点编号为$q$。 将$y$的左儿子设为$p$，右儿子设为$q$，完成合并，并返回$y$表示合并后的节点编号为$y$。 特别的，当$x$或$y$为叶子时，直接合并信息。 注意，再合并过程中，我们需要实时下放标记$(pushdown)$，并实时更新节点信息$(pushup)$。 123456789101112int merge(int x,int y,int l,int r)&#123; if(!x||!y)return x|y; if(l==r)&#123; tr[y].sum+=tr[x].sum; return y; &#125; int mid=l+r&gt;&gt;1; tr[y].l=merge(tr[x].l,tr[y].l,l,mid) tr[y].r=merge(tr[x].r,tr[y].r,mid+1,r); pushup(y); return y;&#125; 例题5：洛谷P4556 [Vani有约会] 雨天的尾巴 &#x2F;【模板】线段树合并 [Vani有约会] 雨天的尾巴 &#x2F;【模板】线段树合并题目背景深绘里一直很讨厌雨天。 灼热的天气穿透了前半个夏天，后来一场大雨和随之而来的洪水，浇灭了一切。 虽然深绘里家乡的小村落对洪水有着顽固的抵抗力，但也倒了几座老房子，几棵老树被连根拔起，以及田地里的粮食被弄得一片狼藉。 无奈的深绘里和村民们只好等待救济粮来维生。 不过救济粮的发放方式很特别。 题目描述首先村落里的一共有 $n$ 座房屋，并形成一个树状结构。然后救济粮分 $m$ 次发放，每次选择两个房屋 $(x, y)$，然后对于 $x$ 到 $y$ 的路径上（含 $x$ 和 $y$）每座房子里发放一袋 $z$ 类型的救济粮。 然后深绘里想知道，当所有的救济粮发放完毕后，每座房子里存放的最多的是哪种救济粮。 输入格式输入的第一行是两个用空格隔开的正整数，分别代表房屋的个数 $n$ 和救济粮发放的次数 $m$。 第 $2$ 到 第 $n$ 行，每行有两个用空格隔开的整数 $a, b$，代表存在一条连接房屋 $a$ 和 $b$ 的边。 第 $(n + 1)$ 到第 $(n + m)$ 行，每行有三个用空格隔开的整数 $x, y, z$，代表一次救济粮的发放是从 $x$ 到 $y$ 路径上的每栋房子发放了一袋 $z$ 类型的救济粮。 输出格式输出 $n$ 行，每行一个整数，第 $i$ 行的整数代表 $i$ 号房屋存放最多的救济粮的种类，如果有多种救济粮都是存放最多的，输出种类编号最小的一种。 如果某座房屋没有救济粮，则输出 $0$。 样例 #1样例输入 #1123456785 31 23 13 45 32 3 31 5 23 3 3 样例输出 #11234523302 提示 对于 $20%$ 的数据，保证 $n, m \\leq 100$。 对于 $50%$ 的数据，保证 $n, m \\leq 2 \\times 10^3$。 对于 $100%$ 测试数据，保证 $1 \\leq n, m \\leq 10^5$，$1 \\leq a,b,x,y \\leq n$，$1 \\leq z \\leq 10^5$。 分析： 考虑暴力：可以树上差分，将单次区间修改变为四次单点修改，即$[x,y]$的修改对应$x,y$的单点加和$lca(x,y),fa_{lca(x,y)}$的单点减，最后求答案时从下往上前缀和即可。 但是这样会超时，而这种算法的瓶颈是最后的数组加，于是可以使用权值线段树的合并优化这个过程。在每个节点上新建一个权值线段树，下标为救济粮的种类，按照上面的思路，最后进行线段树合并即可。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include&lt;bits/stdc++.h&gt;using namespace std;const int N=1e5+5,MAX=1e5;int n,m;int h[N],to[100*N],ne[100*N];//树部分int idx;void addedge(int u,int v)&#123; to[++idx]=v; ne[idx]=h[u]; h[u]=idx;&#125;int anc[N][20],dep[N];//LCA部分void dfs(int u,int fa)&#123; anc[u][0]=fa; dep[u]=dep[fa]+1; for(int i=h[u];i;i=ne[i])&#123; if(to[i]!=fa)&#123; dfs(to[i],u); &#125; &#125;&#125;void init()&#123; for(int i=1;i&lt;=17;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; anc[j][i]=anc[anc[j][i-1]][i-1]; &#125; &#125;&#125;int lca(int x,int y)&#123; if(dep[x]&lt;dep[y])swap(x,y); for(int i=17;i&gt;=0;i--)&#123; if(dep[anc[x][i]]&gt;=dep[y])x=anc[x][i]; &#125; if(x==y)return x; for(int i=17;i&gt;=0;i--)&#123; if(anc[x][i]!=anc[y][i])x=anc[x][i],y=anc[y][i]; &#125; return anc[x][0];&#125;struct node&#123;//线段树部分 int l,r; int mx,mx_sum;&#125;;node tr[N*100];int idx_tr;void pushup(int u)&#123; if(!tr[u].l)&#123; tr[u].mx=tr[tr[u].r].mx; tr[u].mx_sum=tr[tr[u].r].mx_sum; &#125; if(!tr[u].r)&#123; tr[u].mx=tr[tr[u].l].mx; tr[u].mx_sum=tr[tr[u].l].mx_sum; &#125; if(tr[tr[u].l].mx_sum&gt;=tr[tr[u].r].mx_sum)&#123; tr[u].mx=tr[tr[u].l].mx; tr[u].mx_sum=tr[tr[u].l].mx_sum; &#125; else&#123; tr[u].mx=tr[tr[u].r].mx; tr[u].mx_sum=tr[tr[u].r].mx_sum; &#125;&#125;void change(int &amp;u,int l,int r,int x,int k)&#123; if(!u)u=++idx_tr; if(l==r)&#123; tr[u].mx=x; tr[u].mx_sum+=k; return; &#125; int mid=l+r&gt;&gt;1; if(x&lt;=mid)change(tr[u].l,l,mid,x,k); else change(tr[u].r,mid+1,r,x,k); pushup(u);&#125;int merge(int x,int y,int l,int r)&#123; if(!x||!y)return x|y; if(l==r)&#123; tr[y].mx_sum+=tr[x].mx_sum; return y; &#125; int mid=l+r&gt;&gt;1; tr[y].l=merge(tr[x].l,tr[y].l,l,mid); tr[y].r=merge(tr[x].r,tr[y].r,mid+1,r); pushup(y); return y;&#125;int ans[N];void get(int u,int fa)&#123; for(int i=h[u];i;i=ne[i])&#123; if(to[i]!=fa)&#123; get(to[i],u); u=merge(to[i],u,1,MAX); &#125; &#125; ans[u]=tr[u].mx; if(tr[u].mx_sum==0)ans[u]=0;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i=1;i&lt;n;i++)&#123; int a,b; cin &gt;&gt; a &gt;&gt; b; addedge(a,b); addedge(b,a); &#125; dfs(1,0); init(); idx_tr=n; for(int i=1;i&lt;=m;i++)&#123; int x,y,z; cin &gt;&gt; x &gt;&gt; y &gt;&gt; z; int l=lca(x,y); change(x,1,MAX,z,1); change(y,1,MAX,z,1); change(l,1,MAX,z,-1); change(anc[l][0],1,MAX,z,-1); &#125; get(1,0); for(int i=1;i&lt;=n;i++)&#123; cout &lt;&lt; ans[i] &lt;&lt; endl; &#125; return 0;&#125; 例题6：洛谷P5298 [PKUWC2018] Minimax（线段树合并优化树形dp） [PKUWC2018] Minimax题目描述小 $C$ 有一棵 $n$ 个结点的有根树，根是 $1$ 号结点，且每个结点最多有两个子结点。 定义结点 $x$ 的权值为： 1.若 $x$ 没有子结点，那么它的权值会在输入里给出，保证这类点中每个结点的权值互不相同。 2.若 $x$ 有子结点，那么它的权值有 $p_x$ 的概率是它的子结点的权值的最大值，有 $1-p_x$ 的概率是它的子结点的权值的最小值。 现在小 $C$ 想知道，假设 $1$ 号结点的权值有 $m$ 种可能性，权值第 $i$ 小的可能性的权值是 $V_i$，它的概率为 $D_i(D_i&gt;0)$，求： $$\\sum_{i&#x3D;1}^{m}i\\cdot V_i\\cdot D_i^2$$ 你需要输出答案对 $998244353$ 取模的值。 输入格式第一行一个正整数 $n$； 第二行 $n$ 个整数，第 $i$ 个整数表示第 $i$ 个结点的父亲的编号，其中第 $1$ 个结点的父亲为 $0$； 第三行 $n$ 个整数，若第 $i$ 个结点没有子结点，则第 $i$ 个数为它的权值，否则第 $i$ 个数为 $p_i\\cdot 10000$，保证 $p_i\\cdot 10000$ 是个正整数。 输出格式输出答案。 样例 #1样例输入 #112330 1 15000 1 2 样例输出 #11748683266 提示样例解释1号结点的权值有 $\\frac{1}{2}$ 的概率是 $1$，有 $\\frac{1}{2}$ 的概率是 $2$，所以答案是 $\\frac{5}{4}$。 数据范围 对于 $10%$ 的数据，有 $1\\leq n\\leq 20$； 对于 $20%$ 的数据，有 $1\\leq n\\leq 400$； 对于 $40%$ 的数据，有 $1\\leq n\\leq 5000$； 对于 $60%$ 的数据，有 $1\\leq n\\leq 10^5$； 另有 $10%$ 的数据保证树的形态随机； 对于 $100%$ 的数据，有 $1\\leq n\\leq 3\\times 10^5$，$1\\leq w_i\\leq 10^9$。 对于所有数据，满足 $0 &lt; p_i \\cdot 10000 &lt; 10000$，所以易证明所有叶子的权值都有概率被根取到。 线段树分裂线段树不仅支持合并，也同样支持分裂。 假设我们需要将权值线段树$T$分为$\\le k$的部分$T_1$和$&gt;k$的部分$T_2$。原树上的点可分为两类，对于第一类的点，其子树内同时含有两部分的叶子，则其在$T_!$，$T_2$中同时出现；否则，其只会在$T_1$或$T_2$中出现。我们只遍历原树上的第一类点，将其属于第二类的儿子挂在$T_1$或$T_2$中，再更新其在$T_1$及$T_2$中的信息即可。由于第一类点不超过$O(\\log n)$个，因此遍历、新建的节点数为$O(\\log n)$级别。 123456789void split(int x,int &amp;y,int k)&#123; if(!x)return; y=++cnt;//新树中的点 int sizel=tr[tr[x].l].sz; if(k&lt;sizel)swap(tr[x].r,tr[y].r),split(tr[x].l,tr[y].l,k);//把右儿子加到新树里 else if(k==sizel)swap(tr[x].r,tr[y].r);//把右儿子加到新树里 else split(tr[x].r,tr[y].r,k-sizel); pushup(x),pushup(y);&#125; 例题7：洛谷P2824 [HEOI2016&#x2F;TJOI2016] 排序（线段树分裂） [HEOI2016&#x2F;TJOI2016] 排序题目描述在 $2016$ 年，佳媛姐姐喜欢上了数字序列。因而她经常研究关于序列的一些奇奇怪怪的问题，现在她在研究一个难题，需要你来帮助她。 这个难题是这样子的：给出一个 $1$ 到 $n$ 的排列，现在对这个排列序列进行 $m$ 次局部排序，排序分为两种： 0 l r 表示将区间 $[l,r]$ 的数字升序排序 1 l r 表示将区间 $[l,r]$ 的数字降序排序 注意，这里是对下标在区间 $[l,r]$ 内的数排序。最后询问第 $q$ 位置上的数字。 输入格式输入数据的第一行为两个整数 $n$ 和 $m$，$n$ 表示序列的长度，$m$ 表示局部排序的次数。 第二行为 $n$ 个整数，表示 $1$ 到 $n$ 的一个排列。 接下来输入 $m$ 行，每一行有三个整数 $\\text{op},l,r$，$\\text{op}$ 为 $0$ 代表升序排序，$\\text{op}$ 为 $1$ 代表降序排序, $l,r$ 表示排序的区间。 最后输入一个整数 $q$，表示排序完之后询问的位置 输出格式输出数据仅有一行，一个整数，表示按照顺序将全部的部分排序结束后第 $q$ 位置上的数字。 样例 #1样例输入 #11234566 31 6 2 5 3 40 1 41 3 60 2 43 样例输出 #115 提示河北省选2016第一天第二题。 对于 $30%$ 的数据，$n,m\\leq 1000$ 对于 $100%$ 的数据，$n,m\\leq 10^5$，$1\\leq q\\leq n$ 分析： 可以将序列划分为多个连续段，每个连续段内序列单调，使用权值线段树维护，初始时每个元素位于单独的连续段内。当进行操作时，可以将多个连续段拆分合并成新的连续段，使用set维护连续段，每次二分查找连续段并进行操作。 操作时，可能遇到特殊情况： 对于第一种情况，二分左右端点，分裂左端点的右半部分和右端点的左半部分对应的权值线段树，与中间部分合并即可。 对于第二种情况，把连续段分裂成三部分，取中间部分即可。 注意，对于每种情况，要分升序和降序两种情况讨论。 代码：(未AC) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175#include&lt;bits/stdc++.h&gt;using namespace std;const int N=1e5+5;struct node&#123; int l,r; int sz; void clear()&#123; l=r=sz=0; &#125;&#125;;struct data&#123; int l,r; bool flag; int tr; void clear()&#123; l=r=flag=0; &#125; bool operator&lt;(const data x)const&#123; return r&lt;x.r; &#125;&#125;;set&lt;data&gt;seq;node tr[100*N];int idx;data newq(int l,int r,bool flag,int x)&#123; data t; t.l=l,t.r=r,t.flag=flag,t.tr=x; return t;&#125;int n,m;int a[N];void pushup(int u)&#123; tr[u].sz=tr[tr[u].l].sz+tr[tr[u].r].sz;&#125;void change(int &amp;u,int l,int r,int x,int k)&#123; if(!u)u=++idx; if(l==r)&#123; tr[u].sz+=k; return; &#125; int mid=l+r&gt;&gt;1; if(x&lt;=mid)change(tr[u].l,l,mid,x,k); else change(tr[u].r,mid+1,r,x,k); pushup(u);&#125;int merge(int x,int y,int l,int r)&#123; if(!x||!y)return x|y; if(l==r)&#123; tr[y].sz+=tr[x].sz; return y; &#125; int mid=l+r&gt;&gt;1; tr[y].l=merge(tr[x].l,tr[y].l,l,mid); tr[y].r=merge(tr[x].r,tr[y].r,mid+1,r); pushup(y); return y;&#125;void split(int x,int &amp;y,int k)&#123; if(!x)return; y=++idx; if(k&lt;tr[tr[x].l].sz)swap(tr[x].r,tr[y].r),split(tr[x].l,tr[y].l,k); else if(k==tr[tr[x].l].sz)swap(tr[x].r,tr[y].r); else split(tr[x].r,tr[y].r,k-tr[tr[x].l].sz); pushup(x),pushup(y);&#125;int ans[N],cnt;void out(bool opt,int u,int l,int r)&#123; if(!u)return; if(l==r)&#123; ans[++cnt]=l; return; &#125; int mid=l+r&gt;&gt;1; if(opt==0)&#123; out(opt,tr[u].l,l,mid); out(opt,tr[u].r,mid+1,r); &#125; else&#123; out(opt,tr[u].r,mid+1,r); out(opt,tr[u].l,l,mid); &#125;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i=1;i&lt;=n;i++)&#123; cin &gt;&gt; a[i]; int x=0; change(x,1,n,a[i],1); seq.insert(newq(i,i,0,x)); &#125; for(int i=1;i&lt;=m;i++)&#123; int op,l,r; cin &gt;&gt; op &gt;&gt; l &gt;&gt; r; auto left=seq.lower_bound(newq(0,l,0,0)); int res=0; bool fflag=0; while(left!=seq.end()&amp;&amp;left-&gt;l&lt;=r)&#123; auto now=*left; auto tt=left;tt++; seq.erase(left);left=tt; if(now.l&gt;=l&amp;&amp;now.r&lt;=r)&#123;//完全包含 res=merge(now.tr,res,1,n); &#125; else if(now.l&lt;=l&amp;&amp;now.r&gt;=r)&#123;//取中间 if(op==now.flag)&#123;//符号相同，不用改，放回去 seq.insert(now); goto end; &#125; else if(now.flag)&#123;//符号不同，拆成三段，分开考虑 int tmp=0; split(now.tr,tmp,now.r-r); split(tmp,res,r-l+1); swap(tmp,res);swap(now.tr,tmp); if(tr[now.tr].sz)seq.insert(newq(now.l,l-1,now.flag,now.tr)); if(tr[tmp].sz)seq.insert(newq(r+1,now.r,now.flag,tmp)); &#125; else&#123; int tmp=0; split(now.tr,tmp,l-now.l); split(tmp,res,r-l+1); swap(tmp,res); swap(now.tr,tmp); if(tr[tmp].sz)seq.insert(newq(now.l,l-1,now.flag,tmp)); if(tr[now.tr].sz)seq.insert(newq(r+1,now.r,now.flag,now.tr)); &#125; seq.insert(newq(l,r,op,res)); goto end; &#125; else if(now.l&lt;l)&#123;//取右边 if(now.flag)&#123; int tmp=0; split(now.tr,tmp,now.r-l+1); res=merge(now.tr,res,1,n); if(tr[tmp].sz)seq.insert(newq(now.l,l-1,now.flag,tmp)); &#125; else&#123; int tmp=0; split(now.tr,tmp,l-now.l); res=merge(tmp,res,1,n); if(tr[now.tr].sz)seq.insert(newq(now.l,l-1,now.flag,now.tr)); &#125; &#125; else if(now.r&gt;r)&#123;//取左边 if(now.flag)&#123; int tmp=0; split(now.tr,tmp,now.r-r); res=merge(tmp,res,1,n); if(tr[now.tr].sz)seq.insert(newq(r+1,now.r,now.flag,now.tr)); &#125; else&#123; int tmp=0; split(now.tr,tmp,r-now.l+1); res=merge(now.tr,res,1,n); if(tr[tmp].sz)seq.insert(newq(r+1,now.r,now.flag,tmp)); &#125; &#125; &#125; seq.insert(newq(l,r,op,res)); end:; &#125; for(auto x:seq)&#123; out(x.flag,x.tr,1,n); &#125; int q; cin &gt;&gt; q; cout &lt;&lt; ans[q]; return 0;&#125; 可持久化线段树（主席树）考虑这样一个问题：给定长度为$n$的序列$a$和$q$次命令，每次命令形如： 将$a_i$加上$x$。 查询第$i$次操作结束后的$[l,r]$的和。 首先，若第$2$类操作的$i$总等于当前操作的次数，可直接$O(\\log n)$地用线段树维护。 但是，现在我们要访问线段树的任意历史版本。注意到，每次单点修改后，只有$O(\\log n)$个节点的权值发生了改变。我们考虑只新建$O(\\log n)$个点，而非$O(n)$地全盘推倒重建。具体来说，对于被修改的非叶节点$x$，设$x$的左儿子为$p$。若$p$也被修改，则建立一个与$p$对应的新点$p’$，将$x’$的左儿子设为$p’$，并向$p’$递归处理；否则，$x’$的左儿子仍为$p$。右儿子的处理是相同的。 具体实现： 将当前点复制一遍 如果当前点是叶节点，直接修改；若不是，分情况向下遍历： 若要修改的点在左子树，遍历左儿子，新点的右儿子为原点的右儿子 若要修改的点在右子树，遍历右儿子，新点的左儿子为原点的左儿子 1234567891011121314151617181920212223struct node&#123; int l,r; int sum;&#125;tr[N];int idx;int copy(int u)&#123; tr[++idx]=tr[u]; return idx;&#125;int change(int u,int l,int r,int x,int k)&#123; u=copy(u); if(l==r)&#123; tr[u].sum+=k; return u; &#125; int mid=l+r&gt;&gt;1; if(x&lt;=mid)tr[u].l=change(tr[u].l,l,mid,x,k); else tr[u].r=change(tr[u].r,mid+1,r,x,k); pushup(u); return u;&#125; 例题8：洛谷P3919 【模板】可持久化线段树 1（可持久化数组） 【模板】可持久化线段树 1（可持久化数组）题目背景UPDATE : 最后一个点时间空间已经放大 2021.9.18 增添一组 hack 数据 by @panyf 标题即题意 有了可持久化数组，便可以实现很多衍生的可持久化功能（例如：可持久化并查集） 题目描述如题，你需要维护这样的一个长度为 $ N $ 的数组，支持如下几种操作 在某个历史版本上修改某一个位置上的值 访问某个历史版本上的某一位置的值 此外，每进行一次操作（对于操作2，即为生成一个完全一样的版本，不作任何改动），就会生成一个新的版本。版本编号即为当前操作的编号（从1开始编号，版本0表示初始状态数组） 输入格式输入的第一行包含两个正整数 $ N, M $， 分别表示数组的长度和操作的个数。 第二行包含$ N $个整数，依次为初始状态下数组各位的值（依次为 $ a_i $，$ 1 \\leq i \\leq N $）。 接下来$ M $行每行包含3或4个整数，代表两种操作之一（$ i $为基于的历史版本号）： 对于操作1，格式为$ v_i \\ 1 \\ {loc}_i \\ {value}i $，即为在版本$ v_i $的基础上，将 $ a{loc_i} $ 修改为 $ {value}_i $。 对于操作2，格式为$ v_i \\ 2 \\ {loc}i $，即访问版本$ v_i $中的 $ a{loc_i} $的值，注意：**生成一样版本的对象应为 $v_i$**。 输出格式输出包含若干行，依次为每个操作2的结果。 样例 #1样例输入 #11234567891011125 1059 46 14 87 410 2 10 1 1 140 1 1 570 1 1 884 2 40 2 50 2 44 2 12 2 21 1 5 91 样例输出 #1123456598741878846 提示数据规模： 对于30%的数据：$ 1 \\leq N, M \\leq {10}^3 $ 对于50%的数据：$ 1 \\leq N, M \\leq {10}^4 $ 对于70%的数据：$ 1 \\leq N, M \\leq {10}^5 $ 对于100%的数据：$ 1 \\leq N, M \\leq {10}^6, 1 \\leq {loc}_i \\leq N, 0 \\leq v_i &lt; i, -{10}^9 \\leq a_i, {value}_i \\leq {10}^9$ 经测试，正常常数的可持久化数组可以通过，请各位放心 数据略微凶残，请注意常数不要过大 另，此题I&#x2F;O量较大，如果实在TLE请注意I&#x2F;O优化 询问生成的版本是指你访问的那个版本的复制 样例说明： 一共11个版本，编号从0-10，依次为： * 0 : 59 46 14 87 41 * 1 : 59 46 14 87 41 * 2 : 14 46 14 87 41 * 3 : 57 46 14 87 41 * 4 : 88 46 14 87 41 * 5 : 88 46 14 87 41 * 6 : 59 46 14 87 41 * 7 : 59 46 14 87 41 * 8 : 88 46 14 87 41 * 9 : 14 46 14 87 41 * 10 : 59 46 14 87 91 分析： 模板题，新建一个数组记录每个版本的根。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;bits/stdc++.h&gt;using namespace std;const int N=1e6+5;int n,m;int a[N];struct node&#123; int l,r; int sum;&#125;;node tr[50*N];int idx;void pushup(int u)&#123; tr[u].sum=tr[tr[u].l].sum+tr[tr[u].r].sum;&#125;void build(int &amp;u,int l,int r)&#123; if(!u)u=++idx; if(l==r)&#123; tr[u].sum=a[l]; return; &#125; int mid=l+r&gt;&gt;1; build(tr[u].l,l,mid); build(tr[u].r,mid+1,r); pushup(u);&#125;int root[N],cnt;int copy(int u)&#123; tr[++idx]=tr[u]; return idx;&#125;int change(int u,int l,int r,int x,int k)&#123; u=copy(u); if(l==r)&#123; tr[u].sum=k; return u; &#125; int mid=l+r&gt;&gt;1; if(x&lt;=mid)tr[u].l=change(tr[u].l,l,mid,x,k); else tr[u].r=change(tr[u].r,mid+1,r,x,k); pushup(u); return u;&#125;int find(int u,int l,int r,int x)&#123; if(l==r)return tr[u].sum; int mid=l+r&gt;&gt;1; if(x&lt;=mid)return find(tr[u].l,l,mid,x); return find(tr[u].r,mid+1,r,x);&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0);cout.tie(0); cin &gt;&gt; n &gt;&gt; m; for(int i=1;i&lt;=n;i++)&#123; cin &gt;&gt; a[i]; &#125; build(root[cnt],1,n); for(int i=1;i&lt;=m;i++)&#123; int ver,op,loc; cin &gt;&gt; ver &gt;&gt; op &gt;&gt; loc; if(op==1)&#123; int val; cin &gt;&gt; val; root[++cnt]=change(root[ver],1,n,loc,val); &#125; else&#123; cout &lt;&lt; find(root[ver],1,n,loc) &lt;&lt; endl; root[++cnt]=root[ver]; &#125; &#125; return 0;&#125; 例题9：洛谷P3834 【模板】可持久化线段树 2（静态区间第$k$大） 【模板】可持久化线段树 2题目背景这是个非常经典的可持久化权值线段树入门题——静态区间第 $k$ 小。 数据已经过加强，请使用可持久化权值线段树。同时请注意常数优化。 题目描述如题，给定 $n$ 个整数构成的序列 $a$，将对于指定的闭区间 $[l, r]$ 查询其区间内的第 $k$ 小值。 输入格式第一行包含两个整数，分别表示序列的长度 $n$ 和查询的个数 $m$。第二行包含 $n$ 个整数，第 $i$ 个整数表示序列的第 $i$ 个元素 $a_i$。接下来 $m$ 行每行包含三个整数 $ l, r, k$ , 表示查询区间 $[l, r]$ 内的第 $k$ 小值。 输出格式对于每次询问，输出一行一个整数表示答案。 样例 #1样例输入 #112345675 525957 6405 15770 26287 26465 2 2 13 4 14 5 11 2 24 4 1 样例输出 #112345640515770262872595726287 提示样例 1 解释$n&#x3D;5$，数列长度为 $5$，数列从第一项开始依次为${25957, 6405, 15770, 26287, 26465}$。 第一次查询为 $[2, 2]$ 区间内的第一小值，即为 $6405$。 第二次查询为 $[3, 4]$ 区间内的第一小值，即为 $15770$。 第三次查询为 $[4, 5]$ 区间内的第一小值，即为 $26287$。 第四次查询为 $[1, 2]$ 区间内的第二小值，即为 $25957$。 第五次查询为 $[4, 4]$ 区间内的第一小值，即为 $26287$。 数据规模与约定 对于 $20%$ 的数据，满足 $1 \\leq n,m \\leq 10$。 对于 $50%$ 的数据，满足 $1 \\leq n,m \\leq 10^3$。 对于 $80%$ 的数据，满足 $1 \\leq n,m \\leq 10^5$。 对于 $100%$ 的数据，满足 $1 \\leq n,m \\leq 2\\times 10^5$，$|a_i| \\leq 10^9$，$1 \\leq l \\leq r \\leq n$，$1 \\leq k \\leq r - l + 1$。 形式化题面： 给定$n(n \\le 2 \\times 10^5)$个整数构成的序列$a$和$m(m \\le 2\\times 10^5 )$次询问，每次给定$l,r,k$，查询指定的闭区间$[l,r]$内的第$k$小值。 分析： 可以发现，这道题与例题例题4（查询序列第$k$小）类似，但是要求查询区间的第$k$小，考虑如何转换。 可以建立序列的所有前缀的权值线段树，即主席树的$n$次单点修改，每次询问时在$l-1,r$两棵线段树上同时二分，即可得出答案。 具体来说，同时二分两棵线段树，设$l-1,r$的左子树的权值分别为$c,c’$，则当$c’-c \\ge k$ 时，两棵树同时向左儿子遍历，否则向右儿子遍历。 由于值域很大，需要进行离散化。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;bits/stdc++.h&gt;using namespace std;const int N=2e5+5,MAX=2e9+1;int num[N],num_cnt;int find(int x)&#123; int l=1,r=num_cnt; while(l&lt;r)&#123; int mid=l+r&gt;&gt;1; if(x&lt;=num[mid])r=mid; else l=mid+1; &#125; return l;&#125;int n,m;int a[N];struct node&#123; int l,r; int sz;&#125;tr[50*N];int idx;int root[N],cnt;void pushup(int u)&#123; tr[u].sz=tr[tr[u].l].sz+tr[tr[u].r].sz;&#125;int copy(int u)&#123; tr[++idx]=tr[u]; return idx;&#125;int change(int u,int l,int r,int x)&#123; u=copy(u); if(l==r)&#123; tr[u].sz++; return u; &#125; int mid=l+r&gt;&gt;1; if(x&lt;=mid)tr[u].l=change(tr[u].l,l,mid,x); else tr[u].r=change(tr[u].r,mid+1,r,x); pushup(u); return u;&#125;int query(int ul,int ur,int l,int r,int k)&#123; if(l==r)&#123; return l; &#125; int sz=tr[tr[ur].l].sz-tr[tr[ul].l].sz; int mid=l+r&gt;&gt;1; if(sz&gt;=k)return query(tr[ul].l,tr[ur].l,l,mid,k); return query(tr[ul].r,tr[ur].r,mid+1,r,k-sz);&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i=1;i&lt;=n;i++)&#123; cin &gt;&gt; a[i]; num[++num_cnt]=a[i]; &#125; sort(num+1,num+num_cnt+1); num_cnt=unique(num+1,num+num_cnt+1)-(num+1); for(int i=1;i&lt;=n;i++)&#123; root[++cnt]=change(root[i-1],1,MAX,find(a[i])); &#125; for(int i=1;i&lt;=m;i++)&#123; int l,r,k; cin &gt;&gt; l &gt;&gt; r &gt;&gt; k; cout &lt;&lt; num[query(root[l-1],root[r],1,MAX,k)] &lt;&lt; endl; &#125; return 0;&#125; 带懒标记线段树的可持久化每次如果要下放标记，就新建两个节点，并继续递归相应点。 区间mex问题例题10：洛谷P4137 Rmq Problem &#x2F; mex Rmq Problem &#x2F; mex题目描述有一个长度为 $n$ 的数组 ${a_1,a_2,\\ldots,a_n}$。 $m$ 次询问，每次询问一个区间内最小没有出现过的自然数。 输入格式第一行，两个正整数 $n,m$。第二行，$n$ 个非负整数 $a_1, a_2, \\ldots , a_n$。接下来 $m$ 行，每行两个正整数 $l,r$，表示一次询问。 输出格式输出 $m$ 行，每行一个数，依次表示每个询问的答案。 样例 #1样例输入 #112345675 52 1 0 2 13 32 32 41 23 5 样例输出 #11234512303 提示对于 $30%$ 的数据：$1\\leq n,m\\leq 1000$。对于 $100%$ 的数据：$1\\leq n,m\\leq 2\\times {10}^5$，$1\\leq l\\leq r\\leq n$，$0\\leq a_i\\leq 2\\times 10^5$。 分析： 考虑对于每个节点不再维护区间数的数量，维护$last_i$表示$i$上一次出现的位置，则对于每次询问$[l,r]$，只需查询$r$上$last$小于$l$的最小值即可。 接下来考虑如何查找，对于一个节点$u$，若左子树任意点的$last_i \\le l$ 则向右递归，否则向左递归，直到走到叶节点。 考虑如何判断$last_i \\le l$，可以维护所有$last$的最小值，若最小值$\\le l$即可。 考虑如何维护最小值，设当前已知第$i-1$个线段树，则第$i$个线段树的$last_{a_i}$会变成$i$，相当于对$i$进行了一次单点修改。 注意到当$a_i&gt;n$时，$a_i$一定不会被取到，因此直接忽略即可。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;using namespace std;const int N=2e5+5;int n,m;int a[N];int root[N],cnt;struct node&#123; int l,r; int minn;&#125;tr[N*50];int idx;void pushup(int u)&#123; tr[u].minn=min(tr[tr[u].l].minn,tr[tr[u].r].minn);&#125;int copy(int u)&#123; tr[++idx]=tr[u]; return idx;&#125;int change(int u,int l,int r,int x,int k)&#123; u=copy(u); if(l==r)&#123; tr[u].minn=k; return u; &#125; int mid=l+r&gt;&gt;1; if(x&lt;=mid)tr[u].l=change(tr[u].l,l,mid,x,k); else tr[u].r=change(tr[u].r,mid+1,r,x,k); pushup(u); return u;&#125;int query(int u,int l,int r,int lim)&#123; if(l==r)&#123; return l; &#125; int mid=l+r&gt;&gt;1; if(tr[tr[u].l].minn&lt;lim) return query(tr[u].l,l,mid,lim); return query(tr[u].r,mid+1,r,lim);&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i=1;i&lt;=n;i++)&#123; cin &gt;&gt; a[i]; if(a[i]&lt;=n)root[i]=change(root[i-1],0,n,a[i],i); else root[i]=root[i-1]; &#125; for(int i=1;i&lt;=m;i++)&#123; int l,r; cin &gt;&gt; l &gt;&gt; r; cout &lt;&lt; query(root[r],0,n,l) &lt;&lt; endl; &#125; return 0;&#125; 例题11：洛谷CF464E The Classic Problem&#x2F;Codeforces 464E The Classic Problem题面翻译给定一张 $n$ 个点，$m$ 条边的无向图，每条边的边权为 $2^{x_i}$，求 $s$ 到 $t$ 的最短路，结果对 $10^9+7$ 取模。 $n, m, x \\leq 10^5$。 题目描述You are given a weighted undirected graph on $ n $ vertices and $ m $ edges. Find the shortest path from vertex $ s $ to vertex $ t $ or else state that such path doesn’t exist. 输入格式The first line of the input contains two space-separated integers — $ n $ and $ m $ ( $ 1&lt;&#x3D;n&lt;&#x3D;10^{5} $ ; $ 0&lt;&#x3D;m&lt;&#x3D;10^{5} $ ). Next $ m $ lines contain the description of the graph edges. The $ i $ -th line contains three space-separated integers — $ u_{i} $ , $ v_{i} $ , $ x_{i} $ ( $ 1&lt;&#x3D;u_{i},v_{i}&lt;&#x3D;n $ ; $ 0&lt;&#x3D;x_{i}&lt;&#x3D;10^{5} $ ). That means that vertices with numbers $ u_{i} $ and $ v_{i} $ are connected by edge of length $ 2^{x_{i}} $ (2 to the power of $ x_{i} $ ). The last line contains two space-separated integers — the numbers of vertices $ s $ and $ t $ . The vertices are numbered from $ 1 $ to $ n $ . The graph contains no multiple edges and self-loops. 输出格式In the first line print the remainder after dividing the length of the shortest path by $ 1000000007 (10^{9}+7) $ if the path exists, and -1 if the path doesn’t exist. If the path exists print in the second line integer $ k $ — the number of vertices in the shortest path from vertex $ s $ to vertex $ t $ ; in the third line print $ k $ space-separated integers — the vertices of the shortest path in the visiting order. The first vertex should be vertex $ s $ , the last vertex should be vertex $ t $ . If there are multiple shortest paths, print any of them. 样例 #1样例输入 #11234564 41 4 21 2 02 3 03 4 01 4 样例输出 #1123341 2 3 4 样例 #2样例输入 #2123454 31 2 42 3 53 4 61 4 样例输出 #212311241 2 3 4 样例 #3样例输入 #312344 21 2 03 4 11 4 样例输出 #31-1 提示A path from vertex $ s $ to vertex $ t $ is a sequence $ v_{0} $ , …, $ v_{k} $ , such that $ v_{0}&#x3D;s $ , $ v_{k}&#x3D;t $ , and for any $ i $ from 0 to $ k-1 $ vertices $ v_{i} $ and $ v_{i+1} $ are connected by an edge. The length of the path is the sum of weights of edges between $ v_{i} $ and $ v_{i+1} $ for all $ i $ from 0 to $ k-1 $ . The shortest path from $ s $ to $ t $ is the path which length is minimum among all possible paths from $ s $ to $ t $ . 分析： 这是一道最短路的题，但是发现边权非常大，无法直接计算，因此需要使用高精度。但是如果直接使用高精度，时间复杂度很大，于是考虑用权值线段树实现高精度。 考虑需要进行的操作： 比较两个二进制数的大小 进行单点修改，单点查询 设为无穷大$\\inf$ 将一个节点的$dis$复制到另一节点 对于第一个操作，可以在每个节点维护一个哈希值，比较时使用线段树二分，若左儿子的哈希值不同，则向左儿子递归，否则向右儿子递归，直到走到根节点，判断两棵树的这一位是$0$还是$1$即可。 对于第二个操作，正常处理即可。 对于第三个操作，由于$n$最大为$10^5$，因此只需将$\\inf$设为大于$10^5\\times\\log_2 10^5 \\approx 1660964$的数，即$2\\times 10^5$即可。 对于第四个操作，只需将上面的操作可持久化即可。 平衡树全称“平衡二叉搜索树”，常见的类型有： splay treap AVL Tree Red Black Tree Scape Goat Tree Weight Balanced Leafy Tree（特殊结构） 二叉搜索树性质：一个节点$x$左子树所有点的关键字都比$x$的关键字小，右子树的所有点的关键字都比$x$的关键字大。 treap基础知识略 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include &lt;bits/stdc++.h&gt;using namespace std; const int N=100010,INF=1e8;int n;struct Node&#123; int l,r; int key,val; int cnt,size;&#125;tr[N];int root,idx;void pushup(int p)&#123; tr[p].size=tr[tr[p].l].size+tr[tr[p].r].size+tr[p].cnt;&#125;int get_node(int key)&#123; tr[++idx].key=key; tr[idx].val=rand(); tr[idx].cnt=tr[idx].size=1; return idx;&#125;void build()&#123; get_node(-INF),get_node(INF); root=1,tr[1].r=2; pushup(root);&#125;void zig(int &amp;p)&#123; int q=tr[p].l; tr[p].l=tr[q].r,tr[q].r=p,p=q; pushup(tr[p].r),pushup(p);&#125;void zag(int &amp;p)&#123; int q=tr[p].r; tr[p].r=tr[q].l,tr[q].l=p,p=q; pushup(tr[p].l),pushup(p);&#125;void insert(int &amp;p,int key)&#123; if(!p)p=get_node(key); else if(tr[p].key==key)tr[p].cnt++; else if(tr[p].key&gt;key)&#123; insert(tr[p].l,key); if(tr[tr[p].l].val&gt;tr[p].val)zig(p); &#125; else&#123; insert(tr[p].r,key); if(tr[tr[p].r].val&gt;tr[p].val)zag(p); &#125; pushup(p);&#125;void remove(int &amp;p,int key)&#123; if(!p)return; if(tr[p].key==key)&#123; if(tr[p].cnt&gt;1)tr[p].cnt--; else if(tr[p].l||tr[p].r)&#123; if(!tr[p].r||tr[tr[p].l].val&gt;tr[tr[p].r].val)&#123; zig(p); remove(tr[p].r,key); &#125; else&#123; zag(p); remove(tr[p].l,key); &#125; &#125; else p=0; &#125; else if(tr[p].key&gt;key)remove(tr[p].l,key); else remove(tr[p].r,key); pushup(p);&#125;int get_rank_by_key(int p,int key)&#123; if(!p)return 0; if(tr[p].key==key)return tr[tr[p].l].size+1; if(tr[p].key&gt;key)return get_rank_by_key(tr[p].l,key); return tr[tr[p].l].size+tr[p].cnt+get_rank_by_key(tr[p].r,key);&#125;int get_key_by_rank(int p,int rank)&#123; if(!p)return INF; if(tr[tr[p].l].size&gt;=rank)return get_key_by_rank(tr[p].l,rank);\tif(tr[tr[p].l].size+tr[p].cnt&gt;=rank)return tr[p].key; return get_key_by_rank(tr[p].r,rank-tr[tr[p].l].size-tr[p].cnt);&#125;int get_prev(int p,int key)&#123; if(!p)return -INF; if(tr[p].key&gt;=key)return get_prev(tr[p].l,key); return max(tr[p].key,get_prev(tr[p].r,key));&#125;int get_next(int p,int key)&#123; if(!p)return INF; if(tr[p].key&lt;=key)return get_next(tr[p].r,key); return min(tr[p].key,get_next(tr[p].l,key));&#125;int main()&#123; build(); scanf(&quot;%d&quot;,&amp;n); while(n--)&#123; int opt,x; scanf(&quot;%d%d&quot;,&amp;opt,&amp;x); if(opt==1)insert(root,x); else if(opt==2)remove(root,x); else if(opt==3)printf(&quot;%d &quot;,get_rank_by_key(root,x)-1); else if(opt==4)printf(&quot;%d &quot;,get_key_by_rank(root,x+1)); else if(opt==5)printf(&quot;%d &quot;,get_prev(root,x)); else printf(&quot;%d &quot;,get_next(root,x)); &#125; return 0;&#125; 无旋treap核心函数： split(x,a,b,k)：当前为x，将树分为左边大小为k的两棵树a,b，直接递归处理，若k小于等于左儿子的大小，递归处理左儿子，否则处理右儿子的a-s-1（s为左儿子大小）。 12345678910111213void split(int now,int &amp;a,int &amp;b,int k)&#123;\tif(now==0)&#123;a=0;b=0;return;&#125;\tpushdown(now);\tif(si[t[now][0]]&lt;k)&#123; a=now; split(t[now][1],t[now][1],b,k-si[t[now][0]]-1);\t&#125;\telse&#123; b=now; split(t[now][0],a,t[now][0],k);\t&#125;\tpushup(now);&#125; merge 123456789101112131415int merge(int a,int b)&#123;\tif(!a||!b) return a+b;\tif(key[a]&lt;=key[b])&#123; pushdown(a); t[a][1]=merge(t[a][1],b); pushup(a); return a;\t&#125;\telse&#123; pushdown(b); t[b][0]=merge(a,t[b][0]); pushup(b); return b;\t&#125;&#125; 分块把序列分为$\\sqrt{n}$个块，每个块有$\\sqrt{n}$个元素，进行区间操作时整体操作整块，暴力修改散点，时间复杂度$O(n\\sqrt n)$。 例题：洛谷P3372 【模板】线段树 1 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;bits/stdc++.h&gt;using namespace std;const int N=1e5+5;typedef long long ll;int n,m;int belong[N];int block;ll a[N];ll sum[500];ll lazy[500];void add(int l,int r,ll x)&#123; int bl=(l-1)/block+1,br=(r-1)/block+1; if(bl==br)&#123; for(int i=l;i&lt;=r;i++)&#123; a[i]+=x; &#125; sum[bl]+=(r-l+1)*x; return; &#125; else&#123; while(belong[l]==bl)&#123; a[l]+=x; sum[bl]+=x; l++; &#125; while(belong[r]==br)&#123; a[r]+=x; sum[br]+=x; r--; &#125; for(int i=bl+1;i&lt;br;i++)&#123; lazy[i]+=x; &#125; &#125;&#125;ll query(int l,int r)&#123; int bl=(l-1)/block+1,br=(r-1)/block+1; ll res=0; if(bl==br)&#123; for(int i=l;i&lt;=r;i++)&#123; res+=a[i]; &#125; res+=(r-l+1)*lazy[bl]; return res; &#125; else&#123; while(belong[l]==bl)&#123; res+=a[l]+lazy[bl]; l++; &#125; while(belong[r]==br)&#123; res+=a[r]+lazy[br]; r--; &#125; for(int i=bl+1;i&lt;br;i++)&#123; res+=lazy[i]*block+sum[i]; &#125; return res; &#125;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; block=sqrt(n); for(int i=1;i&lt;=n;i++)&#123; cin &gt;&gt; a[i]; belong[i]=(i-1)/block+1; sum[belong[i]]+=a[i]; &#125; for(int i=1;i&lt;=m;i++)&#123; int opt; cin &gt;&gt; opt; if(opt==1)&#123; int l,r; ll x; cin &gt;&gt; l &gt;&gt; r &gt;&gt; x; add(l,r,x); &#125; else&#123; int l,r; cin &gt;&gt; l &gt;&gt; r; cout &lt;&lt; query(l,r) &lt;&lt; endl; &#125; &#125; return 0;&#125;"},{"title":"搜索","path":"/2024/07/25/搜索/","content":"搜索深度优先搜索($DFS$)，广度优先搜索($BFS$) 对比： 数据结构 空间 $DFS$ $stack$ $O(h)$ 不具最短性 $BFS$ $queue$ $O(2^h)$ 最短路 $DFS$:例1：给定一个数字$n$，输出$1\\sim n$的全排列(按字典序) 考虑顺序与回溯 123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;const int N=10;int n;int num[N];bool use[N];void dfs(int now)&#123; if(now&gt;n)&#123; for(int i=1;i&lt;=n;i++)&#123; cout &lt;&lt; num[i] &lt;&lt; &#x27; &#x27;; &#125; cout &lt;&lt; endl; return; &#125; for(int i=1;i&lt;=n;i++)&#123; if(!use[i])&#123; use[i]=1; num[now]=i; dfs(now+1); use[i]=0; &#125; &#125;&#125;int main()&#123; cin &gt;&gt; n; dfs(1); return 0;&#125; 例2：n皇后问题 给定一个整数$n$，表示在$n*n$的棋盘上摆放$n$个皇后，保证每行，每列，每一斜线只有一个皇后，求所有的摆放方法 分析：类似上一题，每次摆放时判断当前点是否可以放，若放，标记行、列、斜线，进入下一行 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;using namespace std;const int N=20;int n;char g[N][N];bool col[N],dg[N],udg[N];void dfs(int u)&#123; if(u==n)&#123; for(int i=0;i&lt;n;i++)&#123; cout &lt;&lt; g[i] &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; for(int i=0;i&lt;n;i++)&#123; if(!col[i]&amp;&amp;!dg[u+i]&amp;&amp;!udg[n-u+i])&#123; g[u][i]=&#x27;Q&#x27;; col[i]=dg[u+i]=udg[n-u+i]=true; dfs(u+1); col[i]=dg[u+i]=udg[n-u+i]=false; g[u][i]=&#x27;.&#x27;; &#125; &#125;&#125;int main()&#123; cin &gt;&gt; n; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;n;j++)&#123; g[i][j]=&#x27;.&#x27;; &#125; &#125; dfs(0); return 0;&#125; $BFS$:每次扩展队列中的元素，若扩展后的点符合要求即入队，搜索到终点后或队列为空停止 例2：给定一个$n*m$的迷宫，其中$0$表示路，$1$表示墙，求从左上走到右下的最短长度 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;const int N=105;int n,m;int mp[N][N];int d[N][N];int dx[5]=&#123;0,0,0,-1,1&#125;,dy[5]=&#123;0,1,-1,0,0&#125;;void bfs()&#123; memset(d,-1,sizeof d); d[1][1]=0; queue&lt;pair&lt;int,int&gt;&gt;q; q.push(&#123;1,1&#125;); while(!q.empty())&#123; auto t=q.front(); q.pop(); int x=t.first,y=t.second; if(x==n&amp;&amp;y==m)&#123; cout &lt;&lt; d[x][y] &lt;&lt; endl; break; &#125; for(int i=1;i&lt;=4;i++)&#123; if(x+dx[i]&gt;n||x+dx[i]&lt;1||y+dy[i]&gt;m||y+dy[i]&lt;1)continue; if(mp[x+dx[i]][y+dy[i]])continue; if(d[x+dx[i]][y+dy[i]]==-1)&#123; d[x+dx[i]][y+dy[i]]=d[x][y]+1; q.push(&#123;x+dx[i],y+dy[i]&#125;); &#125; &#125; &#125;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++)&#123; cin &gt;&gt; mp[i][j]; &#125; &#125; bfs(); return 0;&#125;"},{"title":"拓扑排序","path":"/2024/07/25/拓扑排序/","content":"拓扑排序定义：若一个由图中所有点构成的序列 $A$ 满足：对于图中的每条边 $(x,y)$，$x$ 在 $A$ 中都出现在 $y$ 之前，则称 $A$ 是该图的一个拓扑序列。 拓扑序列只存在于有向图中，可以证明，所有的有向无环图($DAG$)都一定有至少一个拓扑序列。 分析：若一个点的入度为零，则这个点可以排在最前面的位置，因此 将所有入度为零的点入队 取出队首$t$，枚举$t$的所有出边，删除这些边，若某条边$(t,v)$删除后$v$的入度为零，则将$v$入队，重复，直至队列为空。 若仍有未入队的点，则一定存在环。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;bits/stdc++.h&gt;using namespace std;const int N=1e5+5;int h[N],ne[N],to[N];int cnt;int d[N];void addedge(int u,int v)&#123; ne[++cnt]=h[u]; h[u]=cnt; to[cnt]=v; d[v]++;&#125;queue&lt;int&gt;ans;int idx;int n,m;void topsort()&#123; queue&lt;int&gt;q; for(int i=1;i&lt;=n;i++)&#123; if(d[i]==0)&#123; q.push(i); ans.push(i); idx++; &#125; &#125; while(!q.empty())&#123; int t=q.front(); q.pop(); for(int i=h[t];i;i=ne[i])&#123; d[to[i]]--; if(d[to[i]]==0)&#123; q.push(to[i]); ans.push(to[i]); idx++; &#125; &#125; &#125; if(idx==n)&#123; while(!ans.empty())&#123; cout &lt;&lt; ans.front() &lt;&lt; &#x27; &#x27;; ans.pop(); &#125; &#125; else&#123; cout &lt;&lt; -1; &#125;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i=1;i&lt;=m;i++)&#123; int u,v; cin &gt;&gt; u &gt;&gt; v; addedge(u,v); &#125; topsort(); return 0;&#125;"},{"title":"快速排序","path":"/2024/07/25/快速排序/","content":"快速排序思想：分治 步骤 确定分界点 选择一个点（ $a[l],a[r],a[mid]…$）,记为$x$ 调整范围 令所有$\\le x$ 的数在$x$左侧，$&gt;x$ 的数在 $x$ 右侧 递归处理左右两段 重复处理$[1 \\thicksim x],[x+1 \\thicksim n]$两段 实现方式1：暴力（$O(n\\log n)$）$空间复杂度极高$ 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std;const int N=1e5;int n;int q[N];void qksort(int l,int r)&#123; if(l&gt;=r)return; int mid=l+r&gt;&gt;1; int x=q[mid]; int a[N],b[N],cnta=0,cntb=0; for(int i=l;i&lt;=r;i++)&#123; if(q[i]&lt;=x&amp;&amp;i!=mid)&#123; a[++cnta]=q[i]; &#125; else if(q[i]&gt;x)&#123; b[++cntb]=q[i]; &#125; &#125; for(int i=1;i&lt;=cnta;i++)&#123; q[l+i-1]=a[i]; &#125; q[l+cnta]=x; for(int i=1;i&lt;=cntb;i++)&#123; q[l+cnta+i]=b[i]; &#125; qksort(l,l+cnta-1),qksort(l+cnta+1,r);&#125;int main()&#123; cin &gt;&gt; n; for(int i=1;i&lt;=n;i++)&#123; cin &gt;&gt; q[i]; &#125; qksort(1,n); for(int i=1;i&lt;=n;i++)&#123; cout &lt;&lt; q[i] &lt;&lt; &#x27; &#x27; ; &#125; return 0;&#125; 实现方式2：双指针（$O(n\\log n)$）$空间复杂度O(1)$ 123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;const int N=1e6+5;int n;int q[N];void qksort(int l,int r)&#123; if(l&gt;=r)return; int x=q[l+r&gt;&gt;1]; int L=l-1,R=r+1; while(L&lt;R)&#123; do L++;while(q[L]&lt;x); do R--;while(q[R]&gt;x); if(L&lt;R)swap(q[L],q[R]); &#125; qksort(l,R),qksort(R+1,r);&#125;int main()&#123; cin &gt;&gt; n; for(int i=1;i&lt;=n;i++)&#123; cin &gt;&gt; q[i]; &#125; qksort(1,n); for(int i=1;i&lt;=n;i++)&#123; cout &lt;&lt; q[i] &lt;&lt; &#x27; &#x27;; &#125; return 0;&#125;"},{"title":"快速傅里叶变换","path":"/2024/07/25/快速傅里叶变换/","content":"快速傅里叶变换（FFT）快速傅里叶变换用于解决多项式乘法（卷积）问题 给定一个 $ n $ 次多项式 $ F(x) &#x3D; a_0 + a_1x + a_2x^2+…+a_nx^n $。 以及一个 $ m $ 次多项式 $ G(x) &#x3D; b_0 + b_1x + b_2x^2+…+b_mx^m $。 已知 $ H(x) &#x3D; F(x) \\cdot G(x) &#x3D; c_0 + c_1x + c_2x^2+…+c_{n+m}x^{n+m} $。 请你计算并输出 $ c_0,c_1,…,c_{n+m} $。 FFT 可以将朴素的 $O(n^2)$ 算法优化为 $O(n\\log n)$ 前置知识多项式有一个 $n$ 次多项式 $A(x)&#x3D;a_0+a_1x+\\cdots +a_n x^n$ 性质：用任 $n+1$ 个不同点均可确定一个 $n$ 次多项式（点表示法） 证明：任取 $n+1$ 个不同数 $x_0 \\sim x_n$，代入 $A(x)$ 得到 $y_0\\sim y_n$，则可以得到方程组：$$\\left{\\begin{matrix} a_0+a_1x_0+\\cdots +a_nx_0^n&#x3D;y_0\\ a_0+a_1x_1+\\cdots +a_nx_1^n&#x3D;y_1\\ \\cdots \\ a_0+a_1x_n+\\cdots +a_nx_n^n&#x3D;y_n\\end{matrix}\\right.$$由于 $x_0 \\sim x_n,y_0 \\sim y_n$ 均为已知，因此这个方程组就是一个 $n+1$ 元一次方程组 该方程组的系数行列式（$n+1$ 阶范德蒙行列式）$$\\begin{bmatrix} 1&amp; x_0&amp; x_0^2&amp;\\cdots &amp; x_0^n \\ 1&amp; x_1&amp; x_1^2&amp;\\cdots &amp; x_1^n \\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\ 1&amp; x_n&amp; x_n^2&amp;\\cdots &amp; x_n^n\\end{bmatrix}&#x3D;\\prod _{1\\le i &lt; j \\le n+1}(x_i-x_j) e 0$$则由克莱姆法则，该线性方程组有唯一解 复数设复数 $z&#x3D;a+bi$ 称 $x$ 轴为实轴， $y$ 轴为虚轴，则这样的平面称为复平面。 $z$ 在复平面对应的点为 $Z(a,b)$，向量 $\\overrightarrow{OZ}$ 与实轴正方向的夹角称为 $z$ 的辐角，记作 $\\text{Arg } z$，满足 $\\text{Arg } z\\in (-\\pi,\\pi]$ 的辐角叫作 $z$ 的辐角主值，记作 $\\arg z$ 复数乘法的几何意义：设 $z&#x3D;z_1 \\cdot z_2$，则 $|\\vec{z}|&#x3D;|\\vec {z_1}|+|\\vec{z_2}|,\\arg z&#x3D;\\arg z_1+\\arg z_2$ 在复平面上取单位圆，将单位圆等分成 $n$ 份，第 $k$ 份对应的复数记作 $\\omega_n^k$，$|\\omega_n^k|&#x3D;1,\\arg \\omega_n^k &#x3D;k\\frac {2\\pi} n$，则 $\\omega_n^k$ 称作 $n$ 次单位根 性质： $\\omega_n^i e \\omega_n^j,\\forall i e j$ $\\omega_n^k&#x3D;\\cos \\frac {2k\\pi} n +i\\sin\\frac{2k\\pi} n$ $\\omega_n^0&#x3D;\\omega_n^n&#x3D;1$ $\\omega_{2n}^{2k}&#x3D;\\omega_n^k$ $\\omega_n^{k+\\frac n 2}&#x3D;-\\omega_n^k$ 快速傅里叶变换将多项式转化为点 设 $A(x)&#x3D;a_0+a_1x+\\cdots +a_{n-1}x^{n-1}$$$\\begin{array}{l}A(x)\\&#x3D;a_0+a_1x+\\cdots +a_{n-1}x^{n-1}\\&#x3D;(a_0+a_2x^2+\\cdots +a_{n-2}x^{n-2})+(a_1x+a_3x^3+\\cdots +a_{n-1}x^{n-1})\\&#x3D;(a_0+a_2x^2+\\cdots +a_{n-2}x^{n-2})+x(a_1+a_3x^2+\\cdots +a_{n-1}x^{n-2})\\end{array}$$记 $A_1(x)&#x3D;a_0+a_2x+\\cdots +a_{n-2}x^{\\frac n 2-1},A_2(x)&#x3D;a_1+a_3x+\\cdots +a_{n-1}x^{\\frac n 2-1}$ 则 $A(x)&#x3D;A_1(x^2)+xA_2(x^2)$ 取 $n$ 次单位根 $\\omega_n^0 \\sim \\omega_n^{n-1}$ 代入 $A(x)$ 若 $k\\in [0,\\frac n 2 -1]$，$$\\begin{array}{l}A(\\omega_n^k)\\&#x3D;A_1(\\omega_n^{2k})+\\omega_n^kA_2(\\omega_n^{2k})\\&#x3D;A_1(\\omega_{\\frac n 2}^{k})+\\omega_n^kA_2(\\omega_{\\frac n 2}^{k})\\end{array}$$ 若 $k \\in [\\frac n 2,n-1]$，相当于 $k \\in [0, \\frac n 2 -1]$ ，$k’&#x3D;k+\\frac n 2$$$\\begin{array}{l}A(\\omega_n^{k+\\frac n 2})\\&#x3D;A_1(\\omega_n^{2k+n})+\\omega_n^{k+\\frac n 2}A_2(\\omega_n^{2k+n})\\&#x3D;A_1(\\omega_n^{2k})+\\omega_n^{k+\\frac n 2}A_2(\\omega_n^{2k})\\&#x3D;A_1(\\omega_{\\frac n 2}^{k})-\\omega_n^{k}A_2(\\omega_{\\frac n 2}^{k})\\end{array}$$可以发现，若要求 $A(\\omega_n^k)$，则只需求两个长度为 $\\frac n 2$ 的序列 $A_1(\\omega_{\\frac n 2}^k),A_2(\\omega_{\\frac n 2}^k)$，它们各自也可以按照这种方式划分为两个部分，由此产生蝶形算法 时间复杂度 $O(n \\log n)$ 快速傅里叶逆变换将点还原为多项式 设 $A(x)&#x3D;a_0+a_1x+\\cdots +a_{n-1}x^{n-1}$ 已知 $n$ 个点 $(\\omega_n^k,A(\\omega_n^k))$，记 $A(\\omega_n^k)&#x3D;y_k$，令 $c_k&#x3D;\\sum_{i&#x3D;0}^{n-1} y_i(w_n^{-k})^i$，则 $c_k&#x3D;na_k$ 则令 $B(x)&#x3D;y_0+y_1x+\\cdots+y_{n-1}x^{n-1}$，那么 $c_k&#x3D;B(\\omega _n^{-k})$ 也就是求 $B(\\omega_n^0) \\sim B(\\omega_n^{-(n-1)})$，等价于求 $$B(\\omega_n^n) \\sim B(\\omega_n^{1})$$，因此可以用快速傅里叶变换求出 下面证明 $c_k&#x3D;na_k$$$\\begin{array}{l}c_k\\&#x3D;\\sum_{i&#x3D;0}^{n-1} y_i(w_n^{-k})^i\\&#x3D;\\sum_{i&#x3D;0}^{n-1} (\\sum_{j&#x3D;0}^{n-1} a_j(\\omega_n^i)^j)(\\omega_n^{-k})^i\\&#x3D;\\sum_{i&#x3D;0}^{n-1} (\\sum_{j&#x3D;0}^{n-1} a_j(\\omega_n^j)^i)(\\omega_n^{-k})^i\\&#x3D;\\sum_{i&#x3D;0}^{n-1} (\\sum_{j&#x3D;0}^{n-1} a_j(\\omega_n^{j-k})^i)\\&#x3D;\\sum_{j&#x3D;0}^{n-1} (\\sum_{i&#x3D;0}^{n-1} a_j(\\omega_n^{j-k})^i)\\&#x3D;\\sum_{j&#x3D;0}^{n-1} a_j(\\sum_{i&#x3D;0}^{n-1} (\\omega_n^{j-k})^i)\\end{array}$$令 $S(x)&#x3D;1+x+x^2+\\cdots+x^{n-1}$ 若 $k e 0$，则$$\\begin{array}{l}S(\\omega_n^k)&#x3D;1+\\omega_n^k+\\omega_n^{2k}+\\cdots+\\omega_n^{(n-1)k}\\\\omega_n^k S(\\omega_n^k)&#x3D;\\omega_n^k+\\omega_n^{2k}+\\cdots+\\omega_n^{(n-1)k}+\\omega_n^{nk}&#x3D;1+\\omega_n^k+\\omega_n^{2k}+\\cdots+\\omega_n^{(n-1)k}&#x3D;S(\\omega_n^k)\\\\therefore (\\omega_n^k-1) S(\\omega_n^k)&#x3D;0\\\\because k e 0\\\\therefore \\omega_n^k e 1\\\\therefore S(\\omega_n^k)&#x3D;0\\end{array}$$ 若 $k&#x3D;0$，则 $\\omega_n^0&#x3D;1,S(1)&#x3D;n$ 因此$$\\begin{array}{l}c_k\\&#x3D;\\sum_{j&#x3D;0}^{n-1} a_j(\\sum_{i&#x3D;0}^{n-1} (\\omega_n^{j-k})^i)\\&#x3D;\\sum_{j&#x3D;0}^{n-1} a_j(S(\\omega_n^{j-k}))\\&#x3D;na_k\\end{array}$$ 蝶形算法以 $n&#x3D;8$ 为例： 则需要先预处理下面一行的顺序，写出上下每个数的二进制表示，不难看出下面一行每个数的二进制就是上面一行对应数二进制表示翻转形成的 记下面一行第 $i$ 个数的编号为 $(rev[i]&#x3D;rev[i\\gg1]\\gg1)|((rev[i])&amp;1 \\ll (bit-1))$，其中 $bit$ 表示位数，即将当前数的最低位取出，将剩余位右移，然后把取出的数放到最高位。 至此，算法结束。 洛谷 P3803 【模板】多项式乘法（FFT）&#x2F;AcWing 3122. 多项式乘法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;bits/stdc++.h&gt;using namespace std;const int N=3e5+5;const double PI=acos(-1);int n,m;struct Complex&#123;//复数 double x,y; Complex operator+(const Complex &amp;t)const&#123; return &#123;x+t.x,y+t.y&#125;; &#125; Complex operator-(const Complex &amp;t)const&#123; return &#123;x-t.x,y-t.y&#125;; &#125; Complex operator*(const Complex &amp;t)const&#123; return &#123;x*t.x-y*t.y,x*t.y+y*t.x&#125;; &#125;&#125;a[N],b[N];int rev[N],bit,tot;void fft(Complex a[],int inv)&#123; for(int i=0;i&lt;tot;i++)&#123;//调整顺序 if(i&lt;rev[i])&#123; swap(a[i],a[rev[i]]); &#125; &#125; for(int mid=1;mid&lt;tot;mid&lt;&lt;=1)&#123;//从倒数第二层开始向上计算，mid是每一段长度的一半 auto w1=Complex(&#123;cos(PI/mid),inv*sin(PI/mid)&#125;);//w_n^1，方便后面运算，若inv=1，表示正变换，即从w0~wn-1，否则为逆变换，即从wn~w1 for(int i=0;i&lt;tot;i+=mid*2)&#123;//一段一段枚举 auto wk=Complex(&#123;1,0&#125;);//当前段的单位根 for(int j=0;j&lt;mid;j++,wk=wk*w1)&#123;// auto x=a[i+j],y=wk*a[i+j+mid];//x=A1(wk),y=A2(wk) a[i+j]=x+y,a[i+j+mid]=x-y;//A(wk)=A1(wk)+wk*A2(wk),A(wk+mid)=A1(wk)-wk*A2(wk) &#125; &#125; &#125;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i=0;i&lt;=n;i++)cin &gt;&gt; a[i].x; for(int i=0;i&lt;=m;i++)cin &gt;&gt; b[i].x; while((1&lt;&lt;bit)&lt;n+m+1)bit++;//这里要将tot定为最小的满足tot&gt;=n+m+1的数，2^bit=tot tot=1&lt;&lt;bit; for(int i=0;i&lt;tot;i++)&#123;//求出最后一行的顺序 rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); &#125; fft(a,1),fft(b,1);//正变换 for(int i=0;i&lt;tot;i++)&#123; a[i]=a[i]*b[i]; &#125; fft(a,-1);//逆变换 for(int i=0;i&lt;=n+m;i++)&#123; cout &lt;&lt; (int)(a[i].x/tot+0.5) &lt;&lt; &#x27; &#x27;;//防止出现0.999-&gt;0,加上0.5 &#125; return 0;&#125; 例题 ：洛谷 P1919 【模板】高精度乘法 | A*B Problem 升级版&#x2F;AcWing 3123. 高精度乘法II 给定两个正整数 $ A $ 和 $ B $，请你计算 $ A \\times B $ 的值。 输入格式共两行，第一行包含整数 $ A $，第二行包含整数 $ B $。 输出格式共一行，包含 $ A \\times B $ 的值。 数据范围$ 1 \\le A与B的长度 \\le 10^5 $。 输入样例：1223 输出样例：16 分析： 设 $A&#x3D;\\overline {a_{n-1}a_{n-2}\\cdots a_1a_0}$ 则 $A&#x3D;a_{n-1}10^{n-1}+a_{n-2}10^{n-2}+\\cdots + a_0+10^0$ 设 $A(x)&#x3D;a_{n-1}x^{n-1}+a_{n-2}x^{n-2}+\\cdots+a_0x^0$ 则 $A&#x3D;A(10)$，同理 $B&#x3D;B(10)$ 则 $C(10)&#x3D;A(10)B(10)$，使用 FFT 优化即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;bits/stdc++.h&gt;using namespace std;const int N=3e6+5;const double PI=acos(-1);int n,m;char s1[N],s2[N];int res[N];struct Complex&#123; double x,y; Complex operator+(const Complex &amp;t)const&#123; return &#123;x+t.x,y+t.y&#125;; &#125; Complex operator-(const Complex &amp;t)const&#123; return &#123;x-t.x,y-t.y&#125;; &#125; Complex operator*(const Complex &amp;t)const&#123; return &#123;x*t.x-y*t.y,x*t.y+y*t.x&#125;; &#125;&#125;a[N],b[N];int rev[N],bit,tot;void fft(Complex a[],int inv)&#123; for(int i=0;i&lt;tot;i++)&#123; if(i&lt;rev[i])&#123; swap(a[i],a[rev[i]]); &#125; &#125; for(int mid=1;mid&lt;tot;mid&lt;&lt;=1)&#123; auto w1=Complex(&#123;cos(PI/mid),inv*sin(PI/mid)&#125;); for(int i=0;i&lt;tot;i+=mid*2)&#123; auto wk=Complex(&#123;1,0&#125;); for(int j=0;j&lt;mid;j++,wk=wk*w1)&#123; auto x=a[i+j],y=wk*a[i+j+mid]; a[i+j]=x+y,a[i+j+mid]=x-y; &#125; &#125; &#125;&#125;int main()&#123; cin &gt;&gt; s1 &gt;&gt; s2; n=strlen(s1)-1,m=strlen(s2)-1; for(int i=0;i&lt;=n;i++)a[i].x=s1[n-i]-&#x27;0&#x27;; for(int i=0;i&lt;=m;i++)b[i].x=s2[m-i]-&#x27;0&#x27;; while((1&lt;&lt;bit)&lt;n+m+1)bit++; tot=1&lt;&lt;bit; for(int i=0;i&lt;tot;i++)&#123; rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); &#125; fft(a,1),fft(b,1); for(int i=0;i&lt;tot;i++)&#123; a[i]=a[i]*b[i]; &#125; fft(a,-1); //处理进位 int k=0; for(int i=0,t=0;i&lt;tot||t;i++)&#123; t+=a[i].x/tot+0.5; res[k++]=t%10; t/=10; &#125; while(k&gt;1&amp;&amp;!res[k-1])k--; for(int i=k-1;i&gt;=0;i--)cout &lt;&lt; res[i] ; return 0;&#125;"},{"title":"归并排序","path":"/2024/07/25/归并排序/","content":"归并排序流程： 确定分界点 一般取$mid&#x3D;l+r&gt;&gt;1$ 递归两侧 $[l\\thicksim mid],[mid+1 \\thicksim r]$ 合并两侧的序列 每次比较两侧的第一个数，取较小值 代码实现（$O(n\\log n)$） 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;using namespace std;const int N=1e6+5;int n;int q[N];void merge_sort(int l,int r)&#123; if(l&gt;=r)return; int mid=l+r&gt;&gt;1; merge_sort(l,mid),merge_sort(mid+1,r); int tmp[N],cnta=l,cntb=mid+1; for(int i=l;i&lt;=r;i++)&#123; if(cnta==mid+1)&#123; tmp[i]=q[cntb++]; &#125; else if(cntb==r+1)&#123; tmp[i]=q[cnta++]; &#125; else&#123; if(q[cnta]&lt;q[cntb])&#123; tmp[i]=q[cnta++]; &#125; else&#123; tmp[i]=q[cntb++]; &#125; &#125; &#125; for(int i=l;i&lt;=r;i++)&#123; q[i]=tmp[i]; &#125;&#125;int main()&#123; cin &gt;&gt; n; for(int i=1;i&lt;=n;i++)&#123; cin &gt;&gt; q[i]; &#125; merge_sort(1,n); for(int i=1;i&lt;=n;i++)&#123; cout &lt;&lt; q[i] &lt;&lt; &#x27; &#x27;; &#125; return 0;&#125; 应用逆序对：若有一对数$a_i$,$a_j$（$i&lt;j$）且$a_i&gt;a_j$,则这对数是一个逆序对 方法： 归并排序 每次合并时，当取到$q[cntb]$时（$q[cntb]&gt;q[cnta]$）,此时，对于所有$q[cnta\\thicksim mid]$都小于$q[cntb]$,且所有的$q[cnta\\thicksim mid]$在原数组中都位于$q[cntb]$的左侧,所以都是逆序对，共$mid-cnta+1$对 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;const int N=1e6+5;int n;int q[N];long long ans;void merge_sort(int l,int r)&#123; if(l&gt;=r)return; int mid=l+r&gt;&gt;1; merge_sort(l,mid),merge_sort(mid+1,r); int tmp[N],cnta=l,cntb=mid+1; for(int i=l;i&lt;=r;i++)&#123; if(cnta==mid+1)&#123; tmp[i]=q[cntb++]; ans+=mid-cnta+1; &#125; else if(cntb==r+1)&#123; tmp[i]=q[cnta++]; &#125; else&#123; if(q[cnta]&lt;=q[cntb])&#123; tmp[i]=q[cnta++]; &#125; else&#123; tmp[i]=q[cntb++]; ans+=mid-cnta+1; &#125; &#125; &#125; for(int i=l;i&lt;=r;i++)&#123; q[i]=tmp[i]; &#125;&#125;int main()&#123; cin &gt;&gt; n; for(int i=1;i&lt;=n;i++)&#123; cin &gt;&gt; q[i]; &#125; merge_sort(1,n); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;"},{"title":"差分","path":"/2024/07/25/并查集/","content":"并查集操作： 将两个集合合并 询问两个元素是否在一个集合中 暴力算法：合并$O(n)$，查询$O(1)$ 并查集： 基本原理：每个集合用一棵树来表示，树根的编号就是整个集合的编号。每个节点用$fa$数组存储父节点 问题1：如何判断树根:fa[x]==x 问题2：如何查找树根:while(fa[x]!=x)x=fa[x] 问题3：如何合并两个集合:求出$x,y$两点所在树的根节点$fa_x,fa_y$，把其中一个根节点连到另一棵树的根节点上fa[x]=y 这样就实现了并查集的基本操作，但可以发现此时的复杂度依然可以达到$O(n)$,于是考虑优化 路径压缩优化：查找树根时更新父节点直到根节点 按秩合并：把深度较小的树连接到深度较大的树的根节点上，例： 可以发现，把深度较小的树连接到深度较大的树上，合并后的树的深度小，因为查询的复杂度与深度正相关，所以这样的复杂度较低。 可以使用$d$数组维护每个节点所在树的深度，实际实现中只需记录根节点的深度即可。 优化后复杂度近似为$O(1)$ 定义及初始化： 1234int fa[N],d[N],sz[N];//d,sz为深度和大小，是维护的额外信息for(int i=1;i&lt;=n;i++)&#123; fa[i]=i,d[i]=1,sz[i]=1;&#125; 查找(路径压缩)： 123int find(int x)&#123; return fa[x]==x?x:fa[x]=find(fa[x]);&#125; 合并（按秩合并）： 1234567891011121314151617void merge(int x,int y)&#123; x=find(x),y=find(y); if(x==y)return; if(d[x]&gt;d[y])&#123; fa[y]=x; sz[x]+=sz[y]; &#125; else if(d[x]&lt;d[y])&#123; fa[x]=y; sz[y]+=sz[x]; &#125; else&#123; fa[x]=y; d[y]++; sz[y]+=sz[x]; &#125;&#125; 一般不使用按秩合并： 123456void merge(int x,int y)&#123; x=find(x),y=find(y); if(x==y)return; fa[x]=y; sz[y]+=sz[x];&#125; 带权并查集例题：P2024 NOI2001 食物链 用每一个点到根节点的距离表示这个点与根节点的关系 $\\left {\\begin{matrix} dis \\equiv 1 (\\bmod 3) &amp; 当前点被根吃\\ dis \\equiv 2 (\\bmod 3) &amp; 根被当前点吃 \\ dis \\equiv 0 (\\bmod 3) &amp; 当前点与根同类\\end{matrix}\\right.$"},{"title":"平衡树","path":"/2024/07/25/平衡树/","content":"平衡树BST(Binary Search Tree):二叉搜索树满足： 当前节点的左子树中的任何一个点的权值$&lt;$当前节点的权值 当前节点的右子树中的任何一个点的权值$&gt;$当前节点的权值 一般保证无重复权值，若有，可以在每个节点上记录当前权值的个数 可以发现，BST的中序遍历是有序的，因此BST的作用就是动态维护有序集合 操作： 插入 删除 找前驱（中序遍历中的前一个位置）和后继（中序遍历中的后一个位置） 找最大和最小 平衡树就是特殊的二叉搜索树 普通平衡树(Treap)Treap——Tree+heap 使用堆的性质优化二叉搜索树，使用左旋和右旋让二叉搜索树保持堆的性质使二叉树的层数尽量小，减少每次操作的复杂度。 结点的保存： 12345struct Node&#123; int l,r;//左右儿子 int key,val;//二叉搜索树中的值和堆中的值(随机) int cnt,size;//次数，自身所在子树大小&#125;tr[N]; 初始化：新建两个哨兵结点，初始值为$-\\infin,+\\infin$ 核心操作：旋转：左旋（zag），右旋（zig） 操作： 新建节点 123456int get_node(int key)&#123; tr[++idx].key=key; tr[idx].val=rand(); tr[idx].cnt=tr[idx].size=1; return idx;&#125; pushup(计算size) 123void pushup(int p)&#123; tr[p].size=tr[tr[p].l].size+tr[tr[p].r].size+tr[p].cnt;&#125; 左旋右旋 1234567891011void zig(int &amp;p)&#123;//一定要传引用，此时p代表指向根节点的指针(根会改变) int q=tr[p].l; tr[p].l=tr[q].r,tr[q].r=p,p=q;//右挂左，拧左，改变指向根节点的指针 pushup(tr[p].r),pushup(p);&#125;void zag(int &amp;p)&#123; int q=tr[p].r; tr[p].r=tr[q].l,tr[q].l=p,p=q; pushup(tr[p].l),pushup(p);&#125; 初始化（新建哨兵结点） 123456void build()&#123; get_node(-INF),get_node(INF); root=1,tr[1].r=2; pushup(root); if (tr[1].val&lt;tr[2].val)zag(root);//可能一开始就不符合堆的性质，旋转&#125; 插入：与二叉搜索树的插入相同，但是插入完后需要旋转保持堆的性质 12345678910111213void insert(int &amp;p,int key)&#123;//更新结点时也要更新祖先节点的相应值，所以也要传引用 if(!p)p=get_node(key); else if(tr[p].key==key)tr[p].cnt++; else if(tr[p].key&gt;key)&#123; insert(tr[p].l,key); if(tr[tr[p].l].val&gt;tr[p].val)zig(p); &#125; else&#123; insert(tr[p].r,key); if(tr[tr[p].r].val&gt;tr[p].val)zag(p); &#125; pushup(p);&#125; 删除 12345678910111213141516171819202122232425void remove(int &amp;p,int key)&#123; if(!p)return; if(tr[p].key==key)&#123; if(tr[p].cnt&gt;1)tr[p].cnt--; else if(tr[p].l||tr[p].r)&#123; if(!tr[p].r||tr[tr[p].l].val&gt;tr[tr[p].r].val)&#123; zig(p); remove(tr[p].r,key); &#125; else&#123; zag(p); remove(tr[p].l,key); &#125; &#125; else p=0; &#125; else if(tr[p].key&gt;key)&#123; remove(tr[p].l,key); &#125; else&#123; remove(tr[p].r,key); &#125; pushup(p);&#125; 通过数值找排名 注意：因为有哨兵结点的存在，最终求的排名比实际多一位 123456789101112int get_rank_by_key(int p,int key)&#123; if(!p)return 0;//找不到 if(tr[p].key==key)return tr[tr[p].l].size+1; if(tr[p].key&gt;key)return get_rank_by_key(tr[p].l,key); return tr[tr[p].l].size+tr[p].cnt+get_rank_by_key(tr[p].r,key);&#125;int main()&#123; ... get_rank_by_key(root,key)-1; ...&#125; 通过排名找数值 注意：因为有哨兵结点的存在，查找时应查的排名应加一 123456789101112int get_key_by_rank(int p,int rank)&#123; if(!p)return INF; if(tr[tr[p].l].size&gt;=rank)return get_key_by_rank(tr[p].l,rank); if(tr[tr[p].l].size+tr[p].cnt&gt;=rank)return tr[p].key; return get_key_by_rank(tr[p].r,rank-tr[tr[p].l].size-tr[p].cnt);&#125;int main()&#123; ... get_key_by_rank(root,rank+1); ...&#125; 找前驱(严格小于k的最大数) 12345int get_prev(int p,int key)&#123; if(!p)return -INF; if(tr[p].key&gt;=key)return get_prev(tr[p].l,key); return max(tr[p].key,get_prev(tr[p].r,key));&#125; 找后继(严格大于k的最小数) 与找前驱类似 12345int get_next(int p,int key)&#123; if(!p)return INF; if(tr[p].key&lt;=key)return get_next(tr[p].r,key); return min(tr[p].key,get_next(tr[p].l,key));&#125; 总模板： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include &lt;bits/stdc++.h&gt;using namespace std;const int N=100010,INF=0x3f3f3f3f;int n;struct Node&#123; int l, r; int key, val; int cnt, size;&#125;tr[N];int root,idx;int get_node(int key)&#123; tr[++idx].key=key; tr[idx].val=rand(); tr[idx].cnt=tr[idx].size=1; return idx;&#125;void pushup(int p)&#123; tr[p].size=tr[tr[p].l].size+tr[tr[p].r].size+tr[p].cnt;&#125;void zig(int &amp;p)&#123; int q=tr[p].l; tr[p].l=tr[q].r,tr[q].r=p,p=q; pushup(tr[p].r),pushup(p);&#125;void zag(int &amp;p)&#123; int q=tr[p].r; tr[p].r=tr[q].l,tr[q].l=p,p=q; pushup(tr[p].l),pushup(p);&#125;void build()&#123; get_node(-INF),get_node(INF); root=1,tr[1].r=2; pushup(root); if (tr[1].val&lt;tr[2].val)zag(root);&#125;void insert(int &amp;p,int key)&#123; if(!p)p=get_node(key); else if(tr[p].key==key)tr[p].cnt++; else if(tr[p].key&gt;key)&#123; insert(tr[p].l,key); if(tr[tr[p].l].val&gt;tr[p].val)zig(p); &#125; else&#123; insert(tr[p].r,key); if(tr[tr[p].r].val&gt;tr[p].val)zag(p); &#125; pushup(p);&#125;void remove(int &amp;p,int key)&#123; if(!p)return; if(tr[p].key==key)&#123; if(tr[p].cnt&gt;1)tr[p].cnt--; else if(tr[p].l||tr[p].r)&#123; if(!tr[p].r||tr[tr[p].l].val&gt;tr[tr[p].r].val)&#123; zig(p); remove(tr[p].r,key); &#125; else&#123; zag(p); remove(tr[p].l,key); &#125; &#125; else p=0; &#125; else if(tr[p].key&gt;key)&#123; remove(tr[p].l,key); &#125; else&#123; remove(tr[p].r,key); &#125; pushup(p);&#125;int get_rank_by_key(int p,int key)&#123; if(!p)return 0; if(tr[p].key==key)return tr[tr[p].l].size+1; if(tr[p].key&gt;key)return get_rank_by_key(tr[p].l,key); return tr[tr[p].l].size+tr[p].cnt+get_rank_by_key(tr[p].r,key);&#125;int get_key_by_rank(int p,int rank)&#123; if(!p)return INF; if(tr[tr[p].l].size&gt;=rank)return get_key_by_rank(tr[p].l,rank); if(tr[tr[p].l].size+tr[p].cnt&gt;=rank)return tr[p].key; return get_key_by_rank(tr[p].r,rank-tr[tr[p].l].size-tr[p].cnt);&#125;int get_prev(int p,int key)&#123; if(!p)return -INF; if(tr[p].key&gt;=key)return get_prev(tr[p].l,key); return max(tr[p].key,get_prev(tr[p].r,key));&#125;int get_next(int p,int key)&#123; if(!p)return INF; if(tr[p].key&lt;=key)return get_next(tr[p].r,key); return min(tr[p].key,get_next(tr[p].l,key));&#125;int main()&#123; build(); cin &gt;&gt; n; while(n--) &#123; int op,x; cin &gt;&gt; op &gt;&gt; x; if(op==1)insert(root,x); else if(op==2)remove(root,x); else if(op==3)cout &lt;&lt; get_rank_by_key(root,x)-1 &lt;&lt; endl; else if(op==4)cout &lt;&lt; get_key_by_rank(root,x+1) &lt;&lt; endl; else if(op==5)cout &lt;&lt; get_prev(root,x) &lt;&lt; endl; else cout &lt;&lt; get_next(root,x) &lt;&lt; endl; &#125; return 0;&#125; 文艺平衡树(Splay)支持序列中区间翻转的平衡二叉树，保证中序遍历为当前序列的顺序 存储： 123456789struct Node&#123; int l,r,p,v;//左右子节点，父节点，编号 int size,flag;//子树大小，懒标记 void init(int _v,int _p)&#123; v=_v,p=_p; size=1; &#125;&#125;tr[N]; 核心：每操作一个结点（插入，查询），都将该结点旋转到树根 维护信息（size，懒标记flag(记录翻转)）: pushup：维护信息(当前点的size等于左右儿子的size之和加1) 旋转之后 pushdown：下传懒标记(翻转左右子树后标记下传) 递归之前 核心操作： 旋转rotate(x) 1234567891011void rotate(int x)&#123; int y=tr[x].p,z=tr[y].p; int k=tr[y].s[1]==x;//k=0表示x是y的左儿子;k=1表示x是y的右儿子 tr[z].s[tr[z].s[1]==y]=x,tr[x].p=z; //改变y和z,x和z的关系,z的y原先所在儿子变为x，x的父节点变为z tr[y].s[k]=tr[x].s[k^1],tr[tr[x].s[k^1]].p=y; //改变y和x的相反儿子的关系，y的x原先所在儿子变为x的相反儿子，x的原先相反儿子的父节点变为y tr[x].s[k^1]=y,tr[y].p=x; //改变x和y的关系，x的相反儿子变为y，y的父节点变为x pushup(y),pushup(x);&#125; splay(x,k)： 1234567891011void splay(int x,int k)&#123; while(tr[x].p!=k)&#123; int y=tr[x].p,z=tr[y].p; if(z!=k)&#123; if((tr[y].s[1]==x)^(tr[z].s[1]==y)) rotate(x); else rotate(y); &#125; rotate(x); &#125; if(!k)root=x;&#125; 插入 12345678void insert(int v)&#123; int u=root,p=0; while(u)p=u,u=tr[u].s[v&gt;tr[u].v]; u=++idx; if(p)tr[p].s[v&gt;tr[p].v]=u; tr[u].init(v,p); splay(u,0);&#125; 删除 通过排名找数值 12345678910int get_k(int k)&#123; int u=root; while(true)&#123; pushdown(u); if(tr[tr[u].s[0]].size&gt;=k)u=tr[u].s[0]; else if(tr[tr[u].s[0]].size+1==k)return u; else k-=tr[tr[u].s[0]].size+1,u=tr[u].s[1]; &#125; return -1;&#125; 输出序列(中序遍历) 123456void output(int u)&#123; pushdown(u); if(tr[u].s[0])output(tr[u].s[0]); if(tr[u].v&gt;=1&amp;&amp;tr[u].v&lt;=n)cout &lt;&lt; tr[u].v &lt;&lt; &#x27; &#x27;; if(tr[u].s[1])output(tr[u].s[1]);&#125; 其余操作参考Treap 总模板: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;bits/stdc++.h&gt;using namespace std;const int N=100010;int n,m;struct Node&#123; int s[2],p,v;//左右节点，父节点，编号 int size,flag; void init(int _v,int _p)&#123; v=_v,p=_p; size=1; &#125;&#125;tr[N];int root,idx;void pushup(int x)&#123; tr[x].size=tr[tr[x].s[0]].size+tr[tr[x].s[1]].size+1;&#125;void pushdown(int x)&#123; if(tr[x].flag)&#123; swap(tr[x].s[0],tr[x].s[1]); tr[tr[x].s[0]].flag^=1,tr[tr[x].s[1]].flag^=1; tr[x].flag=0; &#125;&#125;void rotate(int x)&#123; int y=tr[x].p,z=tr[y].p; int k=tr[y].s[1]==x;//k=0表示x是y的左儿子;k=1表示x是y的右儿子 tr[z].s[tr[z].s[1]==y]=x,tr[x].p=z; tr[y].s[k]=tr[x].s[k^1],tr[tr[x].s[k^1]].p=y; tr[x].s[k^1]=y,tr[y].p=x; pushup(y),pushup(x);&#125;void splay(int x,int k)&#123; while(tr[x].p!=k)&#123; int y=tr[x].p,z=tr[y].p; if(z!=k)&#123; if((tr[y].s[1]==x)^(tr[z].s[1]==y)) rotate(x); else rotate(y); &#125; rotate(x); &#125; if(!k)root=x;&#125;void insert(int v)&#123; int u=root,p=0; while(u)p=u,u=tr[u].s[v&gt;tr[u].v]; u=++idx; if(p)tr[p].s[v&gt;tr[p].v]=u; tr[u].init(v,p); splay(u,0);&#125;int get_k(int k)&#123; int u=root; while(true)&#123; pushdown(u); if(tr[tr[u].s[0]].size&gt;=k)u=tr[u].s[0]; else if(tr[tr[u].s[0]].size+1==k)return u; else k-=tr[tr[u].s[0]].size+1,u=tr[u].s[1]; &#125; return -1;&#125;void output(int u)&#123; pushdown(u); if(tr[u].s[0])output(tr[u].s[0]); if(tr[u].v&gt;=1&amp;&amp;tr[u].v&lt;=n)cout &lt;&lt; tr[u].v &lt;&lt; &#x27; &#x27;; if(tr[u].s[1])output(tr[u].s[1]);&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i=0;i&lt;=n+1;i++)&#123;//0和n+1是哨兵结点 insert(i); &#125; while(m--)&#123; int l,r; cin &gt;&gt; l &gt;&gt; r; l=get_k(l),r=get_k(r+2); splay(l,0),splay(r,l); tr[tr[r].s[0]].flag^=1; &#125; output(root); return 0;&#125; FHQ-Treap123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include&lt;bits/stdc++.h&gt;using namespace std;const int N=1e5+5;struct node&#123; int l,r,sz,val,rd;&#125;tr[N];int cnt;int root,x,y,z;void pushup(int u)&#123; tr[u].sz=tr[tr[u].l].sz+tr[tr[u].r].sz+1;&#125;void split(int u,int k,int &amp;x,int &amp;y)&#123; if(!u)&#123; x=y=0; return; &#125; if(tr[u].val&lt;=k)&#123; x=u; split(tr[u].r,k,tr[u].r,y); &#125; else&#123; y=u; split(tr[u].l,k,x,tr[u].l); &#125; pushup(u);&#125;int merge(int u,int v)&#123; if(!u||!v)return u|v; if(tr[u].rd&lt;tr[v].rd)&#123; tr[u].r=merge(tr[u].r,v); pushup(u); return u; &#125; else&#123; tr[v].l=merge(u,tr[v].l); pushup(v); return v; &#125;&#125;int new_node(int a)&#123; tr[++cnt].val=a,tr[cnt].sz=1,tr[cnt].rd=rand(); return cnt;&#125;void insert(int a)&#123; split(root,a,x,y); root=merge(merge(x,new_node(a)),y);&#125;void delete_all(int a)&#123; split(root,a,x,y); split(x,a-1,x,y); root=merge(x,y);&#125;void delete_one(int a)&#123; split(root,a,x,y); split(x,a-1,x,z); z=merge(tr[z].l,tr[z].r); root=merge(merge(x,z),y);&#125;int get_key_by_rank(int u,int k)&#123; while(true)&#123; if(k&lt;=tr[tr[u].l].sz)u=tr[u].l; else if(k==tr[tr[u].l].sz+1)return u; else&#123; k=k-tr[tr[u].l].sz-1; u=tr[u].r; &#125; &#125;&#125;int get_rank_by_key(int a)&#123; split(root,a-1,x,y); int k=tr[x].sz+1; root=merge(x,y); return k;&#125;int findpre(int a)&#123; split(root,a-1,x,y); int tmp=tr[get_key_by_rank(x,tr[x].sz)].val; root=merge(x,y); return tmp;&#125;int findnext(int a)&#123; split(root,a,x,y); int tmp=tr[get_key_by_rank(y,1)].val; root=merge(x,y); return tmp;&#125;int n;int main()&#123; cin &gt;&gt; n; for(int i=1;i&lt;=n;i++)&#123; int opt,a; cin &gt;&gt; opt &gt;&gt; a; if(opt==1)&#123; insert(a); &#125; if(opt==2)&#123; delete_one(a); &#125; if(opt==3)&#123; cout &lt;&lt; get_rank_by_key(a) &lt;&lt; endl; &#125; if(opt==4)&#123; cout &lt;&lt; tr[get_key_by_rank(root,a)].val &lt;&lt; endl; &#125; if(opt==5)&#123; cout &lt;&lt; findpre(a) &lt;&lt; endl; &#125; if(opt==6)&#123; cout &lt;&lt; findnext(a) &lt;&lt; endl; &#125; &#125; return 0;&#125;"},{"title":"常用STL","path":"/2024/07/25/常用STL/","content":"常用STLvector变长数组（数组长度变化），倍增思想 初始化: 123vector&lt;int&gt;a;//定义一个普通vectorvector&lt;int&gt;a(10);//定义一个长度为10的vectorvector&lt;int&gt;a(10,3);//定义一个长度为10，每个元素为3的vector size():返回元素个数 empty()：返回是否为空 clear()：清空 front()/back():返回第一&#x2F;最后一个数 push_back()/pop_back():在末尾插入&#x2F;删除一个数 begin()/end():返回开头&#x2F;结尾的迭代器 支持随机访问 支持比较运算，按字典序 pair定义: 1pair&lt;int,int&gt;//数据类型可换 first:第一个元素 second:第二个元素 支持比较运算，以first为第一关键字，second为第二关键字(字典序) 构造: 12p=make_pair(a,b);p=&#123;a,b&#125;; string字符串 size():返回元素个数 empty()：返回是否为空 clear()：清空 substr(pos,len):从下标$pos$开始复制长度为$len$的字符串，若$len$特别大或省略，则返回从$pos$开始的整个字符串 c_str():返回字符串存储的起始地址 queue队列 size():返回元素个数 empty()：返回是否为空 push():向队尾插入一个元素 front():返回队头元素 back():返回队尾元素 pop():弹出队头元素 priority_queue优先队列 push():插入一个元素 top():返回堆顶元素 pop():弹出堆顶元素 默认为大根堆(堆顶为最大值) 小根堆定义方法： 插入元素$x$时插入$-x$ 定义小根堆：priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;q stack栈 size():返回元素个数 empty()：返回是否为空 push():向栈顶插入一个元素 top():返回栈顶元素 pop():弹出栈顶元素 deque双端队列 size():返回元素个数 empty()：返回是否为空 clear()：清空 front()/back():返回第一&#x2F;最后一个数 push_front()/pop_front():在开头插入&#x2F;删除一个数 push_back()/pop_back():在末尾插入&#x2F;删除一个数 begin()/end():返回开头&#x2F;结尾的迭代器 支持随机访问 set,multiset基于平衡二叉树（红黑树），动态维护有序序列 size():返回元素个数 empty():返回是否为空 clear():清空 begin()/end():返回开头&#x2F;结尾的迭代器 insert():插入一个数 find():查找一个数 count():返回一个数的个数 erase() 输入是一个数$x$，删除所有的$x$ 输入一个迭代器，删除这个迭代器 lower_bound(x):返回大于等于$x$的最小的数的迭代器 upper_bound(x):返回大于$x$的最小的数的迭代器 区别：$set$不支持重复元素，$multiset$支持重复元素 map,multimapsize():返回元素个数 empty()：返回是否为空 clear()：清空 insert():插入一个$pair$ find():查找一个$pair$ erase() 输入是一个$pair$,删除所有的$pair$ 输入一个迭代器，删除这个迭代器 支持像数组一样的操作[] (时间复杂度$O(logn)$) 支持$lower_bound&#x2F;upper_bound$ unordered_set,unordered_map,unordered_multiset,unordered_multimap基于哈希表 类似上面的操作（时间复杂度$O(1)$） 不支持$lower_bound&#x2F;upper_bound$ bitset压位 定义：bitset&lt;10000&gt;s 支持~,&amp;,|,^,&gt;&gt;,&lt;&lt;,==,!=,[] count():返回有多少个$1$ any():判断是否至少有一个$1$ none():判断是否全为$0$ set():把所有位变成$1$ set(k,v):把第$k$位变成$v$ reset():把所有位变成$0$ flip():取反，等价于$\\sim$ flip(k):把第$k$位取反"},{"title":"差分","path":"/2024/07/25/差分/","content":"差分作用：快速进行区间修改 给定数列$a$,构造数列$b$使得 $a_k&#x3D;\\sum_{\\substack{1\\le i\\le k }} b_i$,则$b$是$a$的差分数组，$a$是$b$的前缀和数组，前缀和与差分互为逆运算 $b[i]&#x3D;a[i]-a[i-1]$ 此时，若需要把$[l,r]$的数加上$x$,则$a_l$到$a_l$都会加上$x$,此时$b[l]&#x3D;a[l]-a[l-1]$增大了$x$,$b[r+1]&#x3D;a[r+1]-a[r]$减小了$x$，所以$b[l]+&#x3D;x,b[r+1]-&#x3D;x$ 修改后，求前缀和即可得到原数组修改后的结果 例：给一个$n$项数列，共$p$次修改，每次把$[l,r]$之间的数加上$x$,求修改后数列的最小值 1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;const int N=5e6+5;int n,p;int a[N],b[N];int ans=1e9;int main()&#123; cin &gt;&gt; n &gt;&gt; p; for(int i=1;i&lt;=n;i++)&#123; cin &gt;&gt; a[i]; b[i]=a[i]-a[i-1]; &#125; for(int i=1;i&lt;=p;i++)&#123; int l,r,x; cin &gt;&gt; l &gt;&gt; r &gt;&gt; x; b[l]+=x,b[r+1]-=x; &#125; for(int i=1;i&lt;=n;i++)&#123; a[i]=a[i-1]+b[i]; ans=min(ans,a[i]); &#125; cout &lt;&lt; ans; return 0;&#125; 二维差分若$b[x][y]$加上$k$,则从点$(x,y)$到$(n,n)$均加上了$k$,所以要给左上点$(x_1,y_1)$,右下点$(x_2,y_2)$的矩阵加上$k$,则$b[x_1][y_1]+&#x3D;k,b[x_2+1][y_1]-&#x3D;k,b[x_1][y_2+1]-&#x3D;k,b[x_2+1][y_2+1]+&#x3D;k$ 最后求前缀和数组即可 例：有一个$n*n$的矩阵，$m$次修改，每次修改把$(x_1,y_1)$到$(x_2,y_2)$的矩阵加$1$,最后求修改后的矩阵 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;const int N=1005;int n,m;int b[N][N];void change(int x_1,int y_1,int x_2,int y_2,int k)&#123; b[x_1][y_1]+=k; b[x_2+1][y_1]-=k; b[x_1][y_2+1]-=k; b[x_2+1][y_2+1]+=k;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i=1;i&lt;=m;i++)&#123; int a,b,c,d; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d; change(a,b,c,d,1); &#125; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; b[i][j]+=b[i-1][j]+b[i][j-1]-b[i-1][j-1]; cout &lt;&lt; b[i][j] &lt;&lt; &#x27; &#x27;; &#125; cout &lt;&lt; endl; &#125;&#125;"},{"title":"堆","path":"/2024/07/25/堆/","content":"堆操作： 插入一个数 求集合中的最大(小)值 删除集合的最大(小)值 删除任意一个元素 修改任意一个元素 以下以小根堆(根节点为最小值为例) 基本结构：二叉树 存储：用一个数组$heap$存储二叉树，$size$表示数组中元素的个数，$heap[1]$为根节点，对于一个节点$i$，$i2$是它的左儿子，$i2+1$是它的右儿子。 性质：对于每一个非根节点，它的值一定大于其父节点值 例： 此时的$heap$数组: $i$ $1$ $2$ $3$ $4$ $5$ $6$ $7$ $8$ $9$ $10$ $heap[i]$ $1$ $2$ $3$ $4$ $5$ $6$ $7$ $8$ $9$ $10$ 操作： $down(x)$：将$x$号节点的值下移直至二叉树满足堆的性质 若两个子节点都比当前节点大或当前节点为叶子节点，则操作停止 否则，将当前节点与两个子节点的较小值进行交换，重复上一步骤 $down(x)$：将$x$号节点的值下移直至二叉树满足堆的性质 若父节点比当前节点大或当前节点为根节点，则操作停止 否则，将当前节点与父节点的值进行交换，重复上一步骤 $insert(x)$:插入一个数$x$ 新建一个节点，其值为插入的数heap[++size]=x; 将新插入的数上移up(size); $top()$:查找最小值：return heap[1]; $pop()$:删除最小值 将最小值和最后一个值交换swap(heap[1],heap[size])，然后删除最后一个值size--;，将此时的新根节点下移down(1); 以下三个操作需要额外定义$ph,hp$数组，其中$ph[i]$表示第$i$个插入的数在堆中的下标，$hp[i]$表示堆中的第$i$号点是第几个插入的点,，交换时需交换所有数组，插入时也需记录次序。 $heap_swap(x,y)$：交换两个点 交换两点的$ph$（swap(ph[hp[x]],ph[hp[y]])）、$hp$（swap(hp[x],hp[y])）、值（swap(heap[x],heap[y])） $del(k)$:删除第$k$个插入的数 将当前数和最后一个值交换heap_swap(heap[k],heap[size])，然后删除最后一个值size--;，将此时的新的点下移且上移（不确定大小，都做一遍，只会执行一个）down(k);up(k); $change(k,x)$:把第$k$个插入的数改为$x$ 先修改heap[k]=x，然后将新点移动down(k);up(k); 代码实现： 普通版(不包含特定点的修改删除) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;using namespace std;const int N=1e5+5;int n,m;int treap[N],cnt;void up(int x)&#123;//上移 if(x==1)return; if(treap[x&gt;&gt;1]&gt;treap[x])&#123; swap(treap[x],treap[x&gt;&gt;1]); up(x&gt;&gt;1); &#125;&#125;void down(int x)&#123;//下移 int t=x; if((x&lt;&lt;1)&lt;=cnt&amp;&amp;treap[x&lt;&lt;1]&lt;treap[t])t=x*2; if((x&lt;&lt;1|1)&lt;=cnt&amp;&amp;treap[x&lt;&lt;1|1]&lt;treap[t])t=x*2+1; if(x!=t)&#123; swap(treap[x],treap[t]); down(t); &#125;&#125;void insert(int x)&#123;//插入 treap[++cnt]=x; up(cnt);&#125;void pop()&#123;//弹出最小值 swap(treap[1],treap[cnt]); cnt--; down(1);&#125;int top()&#123;//询问最小值 return treap[1];&#125;bool empty()&#123;//询问是否为空 return !cnt;&#125;int size()&#123;//询问大小 return cnt;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i=1;i&lt;=n;i++)&#123; int tmp; cin &gt;&gt; tmp; insert(tmp); &#125; for(int i=1;i&lt;=m;i++)&#123; cout &lt;&lt; top() &lt;&lt; &#x27; &#x27;; pop(); &#125; return 0;&#125; 进阶版（包含特定点操作，应用场景：$Dijkstra$）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;bits/stdc++.h&gt;using namespace std;const int N=1e5+5;int n;int heap[N],cnt,alls;int ph[N],hp[N];void heap_swap(int x,int y)&#123;//堆的交换 swap(ph[hp[x]],ph[hp[y]]); swap(hp[x],hp[y]); swap(heap[x],heap[y]);&#125;void up(int x)&#123;//上移 if(x==1)return; if(heap[x&gt;&gt;1]&gt;heap[x])&#123; heap_swap(x,x&gt;&gt;1); up(x&gt;&gt;1); &#125;&#125;void down(int x)&#123;//下移 int t=x; if((x&lt;&lt;1)&lt;=cnt&amp;&amp;heap[x&lt;&lt;1]&lt;heap[t])t=x*2; if((x&lt;&lt;1|1)&lt;=cnt&amp;&amp;heap[x&lt;&lt;1|1]&lt;heap[t])t=x*2+1; if(x!=t)&#123; heap_swap(x,t); down(t); &#125;&#125;void insert(int x,int k)&#123;//插入 heap[++cnt]=x; ph[k]=cnt; hp[cnt]=k; up(cnt);&#125;void pop()&#123;//弹出 heap_swap(1,cnt); cnt--; down(1);&#125;int top()&#123;//询问最小 return heap[1];&#125;bool empty()&#123;//询问是否为空 return !cnt;&#125;int size()&#123;//询问大小 return cnt;&#125;void del(int k)&#123;//删除第k个插入的值 k=ph[k]; heap_swap(k,cnt); cnt--; up(k);down(k);&#125;void change(int k,int x)&#123;//修改第k个插入的值 k=ph[k]; heap[k]=x; up(k);down(k);&#125;int main()&#123; cin &gt;&gt; n; for(int i=1;i&lt;=n;i++)&#123; char op[3]; cin &gt;&gt; op; if(op[0]==&#x27;I&#x27;)&#123;//插入 int x; cin &gt;&gt; x; insert(x,++alls); &#125; else if(op[0]==&#x27;P&#x27;)&#123;//弹出最小值 cout &lt;&lt; top() &lt;&lt; endl; &#125; else if(op[0]==&#x27;C&#x27;)&#123;//修改 int k,x; cin &gt;&gt; k &gt;&gt; x; change(k,x); &#125; else if(op[1]==&#x27;M&#x27;)&#123;//弹出最小值 pop(); &#125; else&#123;//删除 int k; cin &gt;&gt; k; del(k); &#125; &#125; return 0;&#125;"},{"title":"基础优化技巧","path":"/2024/07/25/基础优化技巧/","content":"基础优化技巧三分三分用来解决求单峰函数的极值点的问题。 单峰函数：在所考虑的区间中只有一个极值点的函数。 例题：[洛谷P3382 三分](P3382 三分) 三分题目背景本题可能存在严重精度问题，部分数据下难以通过。本题数据较水，仅供参考。 题目描述如题，给出一个 $N$ 次函数，保证在范围 $[l, r]$ 内存在一点 $x$，使得 $[l, x]$ 上单调增，$[x, r]$ 上单调减。试求出 $x$ 的值。 输入格式第一行一次包含一个正整数 $N$ 和两个实数 $l, r$，含义如题目描述所示。 第二行包含 $N + 1$ 个实数，从高到低依次表示该 $N$ 次函数各项的系数。 输出格式输出为一行，包含一个实数，即为 $x$ 的值。若你的答案满足以下二者之一，则算正确： 你的答案 $x’$ 与标准答案 $x$ 的相对或绝对误差不超过 $10^{-5}$。 你的答案 $x’$ 与标准答案 $x$ 对应的函数值，即 $f(x’) $ 和 $f(x)$ 的相对或绝对误差不超过 $10^{-5}$。 样例 #1样例输入 #1123 -0.9981 0.51 -3 -3 1 样例输出 #11-0.41421 提示对于 $100%$ 的数据，$6 \\le N \\le 13$，函数系数均在 $[-100,100]$ 内且至多 $15$ 位小数，$|l|,|r|\\leq 10$ 且至多 $15$ 位小数。$l\\leq r$。 【样例解释】 如图所示，红色段即为该函数 $f(x) &#x3D; x^3 - 3 x^2 - 3x + 1$ 在区间 $[-0.9981, 0.5]$ 上的图像。 当 $x &#x3D; -0.41421$ 时图像位于最高点，故此时函数在 $[l, x]$ 上单调增，$[x, r]$ 上单调减，故 $x &#x3D; -0.41421$，输出 $-0.41421$。 分析： 令 $lmid, rmid$ 是区间任意的两个分段点，把区间分成三段。丢弃极值点一定不在的那一段区间， 使得区间长度缩小。 以这题上凸的函数为例子， 当$ f (lmid) &gt; f (rmid)$ 的时候， 丢弃 $(rmid, R)$ 这一段， 令 $R &#x3D; rmid$ 继续循环， 反之则丢弃$ (L, lmid) $这 一段。 上凸函数 : 开口向下的单峰函数 代码： 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;const int N=15;int n;double l,r;double num[N];double f(double x)&#123; double ans=0,tmp=1; for(int i=1;i&lt;=n+1;i++,tmp*=x)&#123; ans+=tmp*num[i]; &#125; return ans;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; l &gt;&gt; r; for(int i=n+1;i&gt;=1;i--)&#123; cin &gt;&gt; num[i]; &#125; while(r-l&gt;1e-10)&#123; double len=(r-l)/3.0; double lmid=l+len,rmid=r-len; if(f(lmid)&lt;f(rmid))l=lmid; else r=rmid; &#125; cout &lt;&lt; fixed &lt;&lt; setprecision(10) &lt;&lt; l; return 0;&#125; 可以发现其实只会丢掉最两边的段， 中间这一段不会丢， 可以让两边的段尽量长。 那么我们令 $lmid &#x3D; mid – delta, rmid &#x3D; mid + delta$, 这样每次可以让区间长度缩小一半, 其中 $delta$ 是一个很小的量。 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;const int N=15;int n;double l,r;double num[N];double f(double x)&#123; double ans=0,tmp=1; for(int i=1;i&lt;=n+1;i++,tmp*=x)&#123; ans+=tmp*num[i]; &#125; return ans;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; l &gt;&gt; r; for(int i=n+1;i&gt;=1;i--)&#123; cin &gt;&gt; num[i]; &#125; while(r-l&gt;1e-10)&#123; double delta=(r-l)/10000.0,mid=(l+r)/2.0; double lmid=mid-delta,rmid=mid+delta; if(f(lmid)&lt;f(rmid))l=lmid; else r=rmid; &#125; cout &lt;&lt; fixed &lt;&lt; setprecision(10) &lt;&lt; l; return 0;&#125; 当然也是可以二分斜率的。 二分斜率的时候为了避免求导， 可以计算 $f(mid), f (mid + delta)$ 的值， 其中 $delta$ 是一个很小的数来判断怎么取舍区间。 代码与上面相同。 01分数规划形如： 有 $n$ 个物品， 每个物品有两个权值 $a, b$ ， 然后让你选出一些物品使得两个权值和的比值最大或者最小。 也就是令 $w_i$ 表示选 ($w_i &#x3D; 1$) 或者不选 ($w_i &#x3D; 0$)，最大或者最小化下列值:$$\\frac{\\sum w_i\\times a_i}{\\sum w_i \\times b_i}$$除此之外，一般还会对选择的件数或者是选择的物品给出一些限制。 一般来说我们使用二分求解。二分一个值$t$以后，得到：$$\\frac{\\sum w_i\\times a_i}{\\sum w_i \\times b_i} \\ge t$$意思是二分一个值，然后判定能不能大于这个值，然后移项：$$\\sum w_i \\times(a_i-t\\times b_i)\\ge 0$$ 例题：洛谷P3199 [HNOI2009] 最小圈 [HNOI2009] 最小圈题目描述考虑带权有向图 $G&#x3D;(V,E)$ 以及 $w:E\\rightarrow \\R$，每条边 $e&#x3D;(i,j)$（$i eq j$，$i, j\\in V$）的权值定义为 $w_{i,j}$。设 $n&#x3D;|V|$。 $c&#x3D;(c_1,c_2,\\cdots,c_k)$（$c_i\\in V$）是 $G$ 中的一个圈当且仅当 $(c_i,c_{i+1})$（$1\\le i&lt;k$）和 $(c_k,c_1)$ 都在 $E$ 中。称 $k$ 为圈 $c$ 的长度，同时记 $c_{k+1}&#x3D;c_1$，并定义圈 $c&#x3D;(c_1,c_2,\\cdots,c_k)$ 的平均值为$$\\mu(c)&#x3D; \\frac 1 k \\sum\\limits_{i&#x3D;1}^{k} w_{c_i,c_{i+1}}$$即 $c$ 上所有边的权值的平均值。设 $\\mu’(G)&#x3D;\\min_c\\mu(c)$ 为 $G$ 中所有圈 $c$ 的平均值的最小值。 给定图 $G&#x3D;(V,E)$ 以及 $w:E\\rightarrow \\R$，求出 $G$ 中所有圈 $c$ 的平均值的最小值 $\\mu’(G)$。 输入格式第一行两个正整数，分别为 $n$ 和 $m$，并用一个空格隔开。其中 $n&#x3D;|V|$，$m&#x3D;|E|$ 分别表示图中有 $n$ 个点 和 $m$ 条边。 接下来 $m$ 行，每行三个数 $i,j,w_{i,j}$，表示有一条边 $(i,j)$ 且该边的权值为 $w_{i,j}$，注意边权可以是实数。输入数据保证图 $G&#x3D;(V,E)$ 连通，存在圈且有一个点能到达其他所有点。 输出格式一个实数 $\\mu’(G)$，要求精确到小数点后 $8$ 位。 样例 #1样例输入 #11234564 51 2 52 3 53 1 52 4 34 1 3 样例输出 #113.66666667 样例 #2样例输入 #21232 21 2 -2.92 1 -3.1 样例输出 #21-3.00000000 提示对于 $100%$ 的数据，$2\\leq n\\le 3000$，$1\\leq m\\le 10000$，$|w_{i,j}| \\le 10^7$，$1\\leq i, j\\leq n$ 且 $i eq j$。 形式化题面： 给一张 $n$ 个点 $m$ 条边的有向带权图，在图中找一个环，使得环上边权之和除以节点个数最小，求这个最小平均值。 分析： 设第$i$条边的边权为$w_i$，环上有$k$个点，每个环上的边数与点数一定相等，则要求的就是$\\frac{\\sum_{i&#x3D;1}^{k} w_i}{k}$的最小值。 观察到答案是一个“比率” 的形式，联想到分数规划问题。 二分一个答案 $t$ 后，需要判断：$$\\frac{\\sum_{i&#x3D;1}^{k} w_i}{k}\\le t$$若满足，则继续二分$[l,t]$即可，下面考虑如何判断。 不等式移项得：$$\\sum_{i&#x3D;1}^{k} w_i-k\\times t&#x3D;\\sum_{i&#x3D;1}^{k}(w_i-t) &lt;0$$因此，只需要把第$i$条边的边权改成$w_i-t$，SPFA判断负环即可，时间复杂度$O(\\log_2v\\times n\\times m)$。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;using namespace std;const int N=3005,M=1e4+5;int n,m;int h[N],ne[M],to[M];double e[M];int idx;void addedge(int u,int v,double w)&#123; ne[++idx]=h[u]; h[u]=idx; to[idx]=v; e[idx]=w;&#125;double d[N];int cnt;bool vis[N];bool spfa(double t)&#123; queue&lt;int&gt;q; for(int i=1;i&lt;=n;i++)&#123; d[i]=0; q.push(i); vis[i]=true; &#125; cnt=0; while(!q.empty())&#123; int u=q.front(); q.pop(); vis[u]=false; for(int i=h[u];i;i=ne[i])&#123; if(d[to[i]]-(d[u]+e[i]-t)&gt;1e-10)&#123; d[to[i]]=d[u]+e[i]-t; cnt++; if(cnt&gt;11*n)return true; if(!vis[to[i]])&#123; vis[to[i]]=true; q.push(to[i]); &#125; &#125; &#125; &#125; return 0;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i=1;i&lt;=m;i++)&#123; int u,v; double w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; addedge(u,v,w); &#125; double l=-1e7,r=1e7; while(r-l&gt;1e-10)&#123; double mid=(l+r)/2.0; if(spfa(mid))r=mid-1e-10; else l=mid+1e-10; &#125; cout &lt;&lt; fixed &lt;&lt; setprecision(8) &lt;&lt; l; return 0;&#125; 整体二分有多个需要二分的对象的时候，有时候可以放在一起来二分。 例题：洛谷P3527 [POI2011] MET-Meteors [POI2011] MET-Meteors题面翻译Byteotian Interstellar Union 有 $n$ 个成员国。现在它发现了一颗新的星球，这颗星球的轨道被分为 $m$ 份（第 $m$ 份和第 $1$ 份相邻），第 $i$ 份上有第 $a_i$ 个国家的太空站。 这个星球经常会下陨石雨。BIU 已经预测了接下来 $k$ 场陨石雨的情况。 BIU 的第 $i$ 个成员国希望能够收集 $p_i$ 单位的陨石样本。你的任务是判断对于每个国家，它需要在第几次陨石雨之后，才能收集足够的陨石。 输入格式第一行是两个数 $n,m$。 第二行有 $m$ 个数，第 $i$ 个数 $o_i$ 表示第 $i$ 段轨道上有第 $o_i$ 个国家的太空站。 第三行有 $n$ 个数，第 $i$ 个数 $p_i$ 表示第 $i$ 个国家希望收集的陨石数量。 第四行有一个数 $k$，表示 BIU 预测了接下来的 $k$ 场陨石雨。 接下来 $k$ 行，每行有三个数 $l_i,r_i,a_i$ ，表示第 $k$ 场陨石雨的发生地点在从 $l_i$ 顺时针到 $r_i$ 的区间中（如果 $l_i \\leq r_i$，则是 $l_i, l_i + 1\\cdots, r_i$，否则就是 $l_i, l_i + 1,\\cdots m - 1, m, 1, 2, \\cdots r_i$），向区间中的每个太空站提供 $a_i$ 单位的陨石样本。 输出格式输出 $n$ 行。第 $i$ 行的数 $w_i$ 表示第 $i$ 个国家在第 $w_i$ 波陨石雨之后能够收集到足够的陨石样本。如果到第 $k$ 波结束后仍然收集不到，输出 NIE。 数据范围$1\\le n,m,k\\le 3\\cdot10^5$； $1\\le p_i,a_i\\le 10^9$； 题目描述Byteotian Interstellar Union (BIU) has recently discovered a new planet in a nearby galaxy. The planet is unsuitable for colonisation due to strange meteor showers, which on the other hand make it an exceptionally interesting object of study. The member states of BIU have already placed space stations close to the planet’s orbit. The stations’ goal is to take samples of the rocks flying by. The BIU Commission has partitioned the orbit into $m$ sectors, numbered from $1$ to $m$, where the sectors $1$ and $m$ are adjacent. In each sector there is a single space station, belonging to one of the $n$ member states. Each state has declared a number of meteor samples it intends to gather before the mission ends. Your task is to determine, for each state, when it can stop taking samples, based on the meter shower predictions for the years to come. 输入格式The first line of the standard input gives two integers, $n$ and $m$ ($1\\le n,m\\le 300\\ 000$), separated by a single space, that denote,respectively, the number of BIU member states and the number of sectors the orbit has been partitioned into. In the second line there are $m$ integers $o_i$ ($1\\le o_i\\le n$),separated by single spaces, that denote the states owning stations in successive sectors. In the third line there are $n$ integers $p_i$ ($1\\le p_i\\le 10^9$),separated by single spaces, that denote the numbers of meteor samples that the successive states intend to gather. In the fourth line there is a single integer $k$ ($1\\le k\\le 300\\ 000$) that denotes the number of meteor showers predictions. The following $k$ lines specify the (predicted) meteor showers chronologically. The $i$-th of these lines holds three integers $l_i,r_i,a_i$ (separated by single spaces), which denote that a meteor shower is expected in sectors $l_i,l_{i+1},…,r_i$(if $l_i\\le r_i$) or sectors $l_i,l_{i+1},…,m,1,…,r_i$ (if $l_i&gt;r_i$) , which should provide each station in those sectors with $a_i$ meteor samples ($1\\le a_i\\le 10^9$). 输出格式Your program should print $n$ lines on the standard output. The $i$-th of them should contain a single integer $w_i$, denoting the number of shower after which the stations belonging to the $i$-th state are expected to gather at least $p_i$ samples, or the word NIE (Polish for no) if that state is not expected to gather enough samples in the foreseeable future. 样例 #1样例输入 #112345673 51 3 2 1 310 5 734 2 41 3 13 5 2 样例输出 #11233NIE1 考虑对所有国家同时进行二分， 使用数组存当前要处理的所有国家， 定义一个函数 $solve (v, L, R)$ 表示当前要处理 $v$ 中的国家， 可能的答案区间是 $[L, R]$，二分出一个 $mid &#x3D; (L + R) &#x2F; 2$ 以后，递归处理 $solve (vl, L, mid)$ 和 $solve (vr, mid + 1, R)$。 其中 $vl$ 是答案小于等于 $mid$ 的国家， $vr$ 是答案大于 $mid$ 的国家。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include&lt;bits/stdc++.h&gt;using namespace std;const int N=3e5+5;typedef long long ll;ll n,m;ll ans[N];ll k;struct que&#123; ll l,r,a,id;&#125;e[N];ll tr[2*N];struct node&#123; ll need,id;&#125;p[N],p1[N],p2[N];vector&lt;ll&gt;q[N];ll lowbit(ll x)&#123; return x&amp;-x;&#125;void add(ll x,ll k)&#123; for(ll i=x;i&lt;=2*m;i+=lowbit(i))&#123; tr[i]+=k; &#125;&#125;ll query(ll x)&#123; ll res=0; for(ll i=x;i;i-=lowbit(i))&#123; res+=tr[i]; &#125; return res;&#125;ll get(ll x)&#123; ll res=0; for(ll i=0;i&lt;q[p[x].id].size();i++)&#123; res+=query(q[p[x].id][i])+query(q[p[x].id][i]+m); if(res&gt;=p[x].need)return res; &#125; return res;&#125;void merge(ll l,ll r,ll L,ll R)&#123; if(L&gt;R)return; if(l==r)&#123; for(ll i=L;i&lt;=R;i++)&#123; ans[p[i].id]=l; &#125; return; &#125; ll mid=l+r&gt;&gt;1; ll cnt1=0,cnt2=0; for(ll i=l;i&lt;=mid;i++)&#123; add(e[i].l,e[i].a);add(e[i].r+1,-e[i].a); &#125; for(ll i=L;i&lt;=R;i++)&#123; ll tmp=get(i); if(tmp&gt;=p[i].need)p1[++cnt1]=p[i]; else p[i].need-=tmp,p2[++cnt2]=p[i]; &#125; for(ll i=l;i&lt;=mid;i++)&#123; add(e[i].l,-e[i].a);add(e[i].r+1,e[i].a); &#125; for(ll i=L;i&lt;=L+cnt1-1;i++)&#123; p[i]=p1[i-L+1]; &#125; for(ll i=L+cnt1;i&lt;=R;i++)&#123; p[i]=p2[i-L-cnt1+1]; &#125; merge(l,mid,L,L+cnt1-1); merge(mid+1,r,L+cnt1,R);&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(ll i=1;i&lt;=m;i++)&#123; ll x; cin &gt;&gt; x; q[x].push_back(i); &#125; for(ll i=1;i&lt;=n;i++)&#123; cin &gt;&gt; p[i].need; p[i].id=i; &#125; cin &gt;&gt; k; for(ll i=1;i&lt;=k;i++)&#123; cin &gt;&gt; e[i].l &gt;&gt; e[i].r &gt;&gt; e[i].a; e[i].id=i; if(e[i].r&lt;e[i].l)e[i].r+=m; &#125; k++; e[k].l=1,e[k].r=2*m,e[k].a=1000000000; merge(1,k,1,n); for(ll i=1;i&lt;=n;i++)&#123; if(ans[i]==k)cout &lt;&lt; &quot;NIE &quot;; else cout &lt;&lt; ans[i] &lt;&lt; &#x27; &#x27;; &#125; return 0;&#125; 分治主要思想是把大问题分成小问题再合并起来。 所以一般要求问题有可分性，同时有可合并性。 例题1：洛谷P3810 【模板】三维偏序（陌上花开） 【模板】三维偏序（陌上花开）题目背景这是一道模板题，可以使用 bitset，CDQ 分治，KD-Tree 等方式解决。 题目描述有 $ n $ 个元素，第 $ i $ 个元素有 $ a_i,b_i,c_i $ 三个属性，设 $ f(i) $ 表示满足 $ a_j \\leq a_i $ 且 $ b_j \\leq b_i $ 且 $ c_j \\leq c_i $ 且 $ j e i $ 的 $j$ 的数量。 对于 $ d \\in [0, n) $，求 $ f(i) &#x3D; d $ 的数量。 输入格式第一行两个整数 $ n,k $，表示元素数量和最大属性值。 接下来 $ n $ 行，每行三个整数 $ a_i ,b_i,c_i $，分别表示三个属性值。 输出格式$ n $ 行，第 $ d + 1 $ 行表示 $ f(i) &#x3D; d $ 的 $ i $ 的数量。 样例 #1样例输入 #1123456789101110 33 3 32 3 32 3 13 1 13 1 21 3 11 1 21 2 21 3 21 2 1 样例输出 #1123456789103130101001 提示$ 1 \\leq n \\leq 10^5$，$1 \\leq a_i, b_i, c_i \\le k \\leq 2 \\times 10^5 $。 分析： 排序解决一个维度，分治解决一个维度，剩下的维度使用树状数组解决。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;bits/stdc++.h&gt;using namespace std;const int N=1e5+5,M=2e5+5;int n,m;struct Data&#123; int a,b,c,res,s; bool operator&lt;(const Data&amp; t)const&#123; if(a!=t.a)return a&lt;t.a; if(b!=t.b)return b&lt;t.b; return c&lt;t.c; &#125; bool operator==(const Data&amp; t)const&#123; return a==t.a&amp;&amp;b==t.b&amp;&amp;c==t.c; &#125;&#125;q[N],w[N];int tr[M],ans[N];int lowbit(int x)&#123; return x&amp;-x;&#125;void add(int x,int v)&#123; for(int i=x;i&lt;M;i+=lowbit(i))&#123; tr[i]+=v; &#125;&#125;int query(int x)&#123; int res=0; for(int i=x;i;i-=lowbit(i))&#123; res+=tr[i]; &#125; return res;&#125;void merge_sort(int l,int r)&#123; if(l&gt;=r)return; int mid=l+r&gt;&gt;1; merge_sort(l,mid),merge_sort(mid+1,r); int i=l,j=mid+1,k=0; while(i&lt;=mid&amp;&amp;j&lt;=r)&#123; if(q[i].b&lt;=q[j].b)&#123; add(q[i].c,q[i].s),w[k++]=q[i++]; &#125; else&#123; q[j].res+=query(q[j].c),w[k++]=q[j++]; &#125; &#125; while(i&lt;=mid)&#123; add(q[i].c,q[i].s),w[k++]=q[i++]; &#125; while(j&lt;=r)&#123; q[j].res+=query(q[j].c),w[k++]=q[j++]; &#125; for(int i=l;i&lt;=mid;i++)&#123; add(q[i].c,-q[i].s); &#125; for(int i=l,j=0;j&lt;k;i++,j++)&#123; q[i]=w[j]; &#125;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i=0;i&lt;n;i++)&#123; cin &gt;&gt; q[i].a &gt;&gt; q[i].b &gt;&gt; q[i].c; q[i].s=1; &#125; sort(q,q+n); int k=1; for(int i=1;i&lt;n;i++)&#123; if(q[i]==q[k-1])q[k-1].s++; else q[k++]=q[i]; &#125; merge_sort(0,k-1); for(int i=0;i&lt;k;i++)&#123; ans[q[i].res+q[i].s-1]+=q[i].s; &#125; for(int i=0;i&lt;n;i++)&#123; cout &lt;&lt; ans[i] &lt;&lt; endl; &#125; return 0;&#125; 例题2：洛谷P3350 [ZJOI2016] 旅行者 [ZJOI2016] 旅行者题目描述小 Y 来到了一个新的城市旅行。她发现了这个城市的布局是网格状的，也就是有 $n$ 条从东到西的道路和 $m$ 条从南到北的道路，这些道路两两相交形成 $n\\times m$ 个路口 $(i,j)$， $(1\\leq i\\leq n,1\\leq j\\leq m)$ 她发现不同的道路路况不同，所以通过不同的路口需要不同的时间。通过调查发现，从路口 $(i,j)$ 到路口 $(i,j+1)$ 需要时间 $r(i,j)$ ，从路口 $(i,j)$ 到路口 $(i+1,j)$ 需要时间 $c(i,j)$ 。注意这里的道路是双向的。小 Y 有 $q$ 个询问，她想知道从路口 $(x1,y1)$ 到路口 $(x2,y2)$ 最少需要花多少时间。 输入格式第一行包含 2 个正整数 $n,m$ 表示城市的大小。 接下来 $n$ 行，每行包含 $m-1$ 个整数，第 $i$ 行第 $j$ 个正整数表示从一个路口到另一个路口的时间 $r(i,j)$ 。 接下来 $n-1$ 行，每行包含 $m$ 个整数，第 $i$ 行第 $j$ 个正整数表示从一个路口到另一个路口的时间 $c(i,j)$。 接下来一行，包含一个正整数 $q$，表示小 Y 的询问个数。 接下来 $q$ 行，每行包含 $4$ 个正整数 $x1,y1,x2,y2$，表示两个路口的位置。 输出格式输出共 $q$ 行，每行包含一个整数表示从一个路口到另一个路口最少需要花的时间。 样例 #1样例输入 #112345672 2236 421 1 2 21 2 2 1 样例输出 #11267 提示数据规模与约定 $n\\times m \\le 2\\times 10^4$。 $q \\le 10^5$。 $1 \\le r(i,j),c(i,j) \\le 10^4$。 例题3：洛谷CF1156E Special Segments of Permutation Special Segments of Permutation题面翻译给定一个长度为 $n$ 的排列 $p$，求有多少区间 $[l,r]$ 满足，$p_l+p_r&#x3D;\\max\\limits_{i&#x3D;l}^r{p_i}$。 题目描述You are given a permutation $ p $ of $ n $ integers $ 1 $ , $ 2 $ , …, $ n $ (a permutation is an array where each element from $ 1 $ to $ n $ occurs exactly once). Let’s call some subsegment $ p[l, r] $ of this permutation special if $ p_l + p_r &#x3D; \\max \\limits_{i &#x3D; l}^{r} p_i $ . Please calculate the number of special subsegments. 输入格式The first line contains one integer $ n $ ( $ 3 \\le n \\le 2 \\cdot 10^5 $ ). The second line contains $ n $ integers $ p_1 $ , $ p_2 $ , …, $ p_n $ ( $ 1 \\le p_i \\le n $ ). All these integers are pairwise distinct. 输出格式Print the number of special subsegments of the given permutation. 样例 #1样例输入 #11253 4 1 5 2 样例输出 #112 样例 #2样例输入 #21231 3 2 样例输出 #211 提示Special subsegments in the first example are $ [1, 5] $ and $ [1, 3] $ . The only special subsegment in the second example is $ [1, 3] $ . 倍增一般是处理一个 $f[i][j]$ 表示 $[i, i + 2^k – 1]$ 这个区间或者从某个点开始跳 $2^k$ 步的信息， 然后通过合并两个小区间的信息得到大区间的信息。 LCA, ST 表都是倍增的经典应用。 例题1：洛谷P4155 [SCOI2015] 国旗计划 [SCOI2015] 国旗计划题目描述A 国正在开展一项伟大的计划 —— 国旗计划。这项计划的内容是边防战士手举国旗环绕边境线奔袭一圈。这项计划需要多名边防战士以接力的形式共同完成，为此，国土安全局已经挑选了 $N$ 名优秀的边防战上作为这项计划的候选人。 A 国幅员辽阔，边境线上设有 $M$ 个边防站，顺时针编号 $1$ 至 $M$。每名边防战士常驻两个边防站，并且善于在这两个边防站之间长途奔袭，我们称这两个边防站之间的路程是这个边防战士的奔袭区间。$N$ 名边防战士都是精心挑选的，身体素质极佳，所以每名边防战士的奔袭区间都不会被其他边防战士的奔袭区间所包含。 现在，国十安全局局长希望知道，至少需要多少名边防战士，才能使得他们的奔袭区间覆盖全部的边境线，从而顺利地完成国旗计划。不仅如此，安全局局长还希望知道更详细的信息：对于每一名边防战士，在他必须参加国旗计划的前提下，至少需要多少名边防战士才能覆盖全部边境线，从而顺利地完成国旗计划。 输入格式第一行，包含两个正整数 $N,M$，分别表示边防战士数量和边防站数量。 随后 $N$ 行，每行包含两个正整数。其中第 $i$ 行包含的两个正整数 $C_i$、$D_i$ 分别表示 $i$ 号边防战士常驻的两个边防站编号，$C_i$ 号边防站沿顺时针方向至 $D_i$ 号边防站力他的奔袭区间。数据保证整个边境线都是可被覆盖的。 输出格式输出数据仅 $1$ 行，需要包含 $N$ 个正整数。其中，第 $j$ 个正整数表示 $j$ 号边防战士必须参加的前提下至少需要多少名边防战士才能顺利地完成国旗计划。 样例 #1样例输入 #1123454 82 54 76 17 3 样例输出 #113 3 4 3 提示$N\\leqslant 2×10^5,M&lt;10^9,1\\leqslant C_i,D_i\\leqslant M$。 分析： 因为不存在一个区间完全包含另外一个区间， 那么把所有区间按照左端点排序， 右端点必然单调增加， 我们总是可以找到以一个战士最远可以跳到的那个战士所在的位置。 我们定义跳到最远那个战士为跳一步。 $F[x][0]$ 表示 $x$ 跳一步可以到的地方，倍增即可。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;using namespace std;const int N=2e5+5;int n,m;struct node&#123; int l,r,id; bool operator&lt;(const node &amp;x)const&#123; if(l==x.l)return r&lt;x.r; return l&lt;x.l; &#125;&#125;a[2*N];int to[2*N][30];int ans[N];void solve(int k)&#123; int rmax=a[k].l+m,p=k,tmp=0; for(int i=20;i&gt;=0;i--) &#123; if(to[k][i]!=0&amp;&amp;a[to[k][i]].r&lt;rmax)&#123; k=to[k][i]; tmp+=1&lt;&lt;i; &#125; &#125; ans[a[p].id]=tmp+2;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i=1;i&lt;=n;i++)&#123; int l,r; cin &gt;&gt; l &gt;&gt; r; if(r&lt;l)r+=m; a[i]=&#123;l,r,i&#125;; &#125; sort(a+1,a+n+1); for(int i=1;i&lt;=n;i++)&#123; a[i+n]=a[i]; a[i+n].l+=m; a[i+n].r+=m; &#125; for(int i=1,j=1;i&lt;=2*n;i++)&#123; while(a[i].r&gt;=a[j].l&amp;&amp;j&lt;=2*n)&#123; j++; &#125; to[i][0]=j-1; &#125; for(int i=1;i&lt;=20;i++)&#123; for(int j=1;j&lt;=2*n;j++)&#123; to[j][i]=to[to[j][i-1]][i-1]; &#125; &#125; for(int i=1;i&lt;=n;i++)&#123; solve(i); &#125; for(int i=1;i&lt;=n;i++)&#123; cout &lt;&lt; ans[i] &lt;&lt; &#x27; &#x27;; &#125; return 0;&#125; 例题2：洛谷P9361 [ICPC2022 Xi’an R] Contests [ICPC2022 Xi’an R] Contests题面翻译题目描述$n$ 个选手参加了 $m$ 场比赛。给出每场比赛的排行榜。第 $k$ 场比赛的排行榜是一个 $n$ 阶排列 $a_k$，表示选手 $a_{k, i}$ 的排名为 $i$。 SolarPea 和 PolarSea 也是选手。SolarPea 想要证明他比 PolarSea 更强。 定义选手 $x$「$l$ - 强于」选手 $y$，当且仅当存在长度为 $l + 1$ 的序列，满足 $b_1 &#x3D; x$，$b_{l + 1} &#x3D; y$，且对于所有 $1\\leq i\\leq l$，均有 $b_i$ 在至少一场比赛中排名小于 $b_{i + 1}$。 给出 $q$ 组询问。在第 $i$ 组询问中，SolarPea 是选手 $x$，PolarSea 是选手 $y$。求出最小的正整数 $l$，使得 $x$「$l$ - 强于」$y$。 $2\\leq n\\leq 10 ^ 5$，$1\\leq q\\leq 10 ^ 5$，$1\\leq m\\leq 5$，$1\\leq x, y\\leq n$，$x eq y$。 输入格式第一行两个整数 $n, m$。 接下来 $m$ 行，每行 $n$ 个整数，表示第 $i$ 场比赛的排行榜。保证 $a_i$ 是 $1, 2, \\ldots, n$ 的排列。 接下来一行一个整数 $q$。 接下来 $q$ 行，每行两个整数 $x, y$ 表示一组询问。 输出格式对于每组询问，输出一行一个整数表示答案。若不存在这样的 $l$，输出 $-1$。 题目描述There are $n$ contestants and they take part in $m$ contests. You are given the ranklist of each contest. The ranklist of the $k$-th contest is a sequence $a_k$, indicating that the $a_{k, i}$-th contestant’s rank is $i$. SolarPea and PolarSea are two of the $n$ contestants. SolarPea wants to prove that he is stronger than PolarSea. Define $x$ is $l$-stronger than $y$, if and only if there exists a sequence $b$ of length $l + 1$, such that $b_1 &#x3D; x$, $b_{l + 1} &#x3D; y$, and for all $1\\leq i\\leq l$, $b_i$ has a smaller rank than $b_{i + 1}$ in at least one contest. There are $q$ queries. In the $i$-th query, SolarPea is contestant $x$ and PolarSea is contestant $y$. Please find the minimum positive number $l$ such that SolarPea is $l$-stronger than PolarSea. 输入格式The first line contains two integers $n$ ($2\\leq n\\leq 10 ^ 5$) and $m$ ($1\\leq m\\leq 5$). The $i$-th of the next $m$ lines contains $n$ intergers $a_{i, 1}, a_{i, 2}, \\ldots, a_{i, n}$. It is guaranteed that $a_i$ is a permutaion of $1,2,\\ldots,n$. The next line contains an integer $q$ ($1\\leq q\\leq 10 ^ 5$). Each of the next $q$ lines contains two integers $x$ and $y$ ($1 \\le x,y \\le n, x eq y$), representing a query. 输出格式For each query, output a number $l$ representing the answer. If there is no legal $l$, output $-1$. 样例 #1样例输入 #1123456786 21 3 2 5 4 62 1 4 3 6 541 45 36 15 2 样例输出 #112341253 提示Source: The 2022 ICPC Asia Xi’an Regional Contest Problem D. Author: csy2005. 哈希哈希用于把某个对象通过对其特征的“描述”映射为一个值来进行代表， 用于实现判重&#x2F;判相等。 比如字符串哈希， 树哈希等等。 字符串哈希把字符串看成一个$B(B&gt;26)$进制数，计算这个数对某个质数取模的结果作为哈希值。我们随机选取这个$B$和质数$P$。一个结论是两个随机的不同字符串按照这样生成的哈希值相同的概率大约是$\\frac 1 P$，所以比较次数很大的时候，我们需要使用两个模数计算两个哈希值，共同作为哈希值使用，这样相同的概率得到减小。 哈希模数表 子串哈希： 令字符串$s$的哈希值为$\\sum s_i\\times B^{n-i+1}$，那么先求出字符串前缀$f(f_i&#x3D;f_{i-1}\\times B+s_i)$，那么$f_r-f_{l-1}\\times B^{r-l+1}$就是子串$[l,r]$的哈希值。 1234567pw[0]=1;for(int i=1;i&lt;=s.size();i++)&#123; pw[i]=1ll*pw[i-1]*B%P;&#125;for(int i=1;i&lt;=s.size();i++)&#123; f[i]=(1ll*f[i-1]*B+s[i-1])%P;//字符串下标从0开始&#125; 例题：洛谷 [ABC250E] Prefix Equality [ABC250E] Prefix Equality题面翻译给定两个长为 $N$ 的数列 $A,B$ 与 $Q$ 次询问，每次询问给出 $x_i,y_i$，求出 $A$ 的前 $x_i$ 项去重后是否与 $B$ 的前 $y_i$ 项去重后相同。 题目描述長さ $ N $ の整数列 $ A\\ &#x3D;\\ (a_1,\\ldots,a_N) $ と $ B\\ &#x3D;\\ (b_1,\\ldots,b_N) $ が与えられます。 $ i&#x3D;1,…,Q $ に対し、次の形式のクエリに答えてください。 $ A $ の先頭 $ x_i $ 項 $ (a_1,\\ldots,a_{x_i}) $ に含まれる値の集合と $ B $ の先頭 $ y_i $ 項 $ (b_1,\\ldots,b_{y_i}) $ に含まれる値の集合が等しいならば Yes と、そうでなければ No と出力せよ。 输入格式入力は以下の形式で標準入力から与えられる。 $ N $ $ a_1 $ $ \\ldots $ $ a_N $ $ b_1 $ $ \\ldots $ $ b_N $ $ Q $ $ x_1 $ $ y_1 $ $ \\vdots $ $ x_Q $ $ y_Q $ 输出格式$ Q $ 行出力せよ。 $ i $ 行目には、$ i $ 番目のクエリに対する出力をせよ。 样例 #1样例输入 #1123456789101151 2 3 4 51 2 2 4 371 12 22 33 34 44 55 5 样例输出 #11234567YesYesYesNoNoYesNo 提示制約 $ 1\\ \\leq\\ N,Q\\ \\leq\\ 2\\ \\times\\ 10^5 $ $ 1\\ \\leq\\ a_i,b_i\\ \\leq\\ 10^9 $ $ 1\\ \\leq\\ x_i,y_i\\ \\leq\\ N $ 入力は全て整数 Sample Explanation 1集合は各値が含まれるかどうかのみに注目した概念であることに気を付けてください。 $ 3 $ 番目のクエリにおいて、$ A $ の先頭 $ 2 $ 項には $ 1 $ と $ 2 $ が $ 1 $ 個ずつ、$ B $ の先頭 $ 3 $ 項には $ 1 $ が $ 1 $ 個と $ 2 $ が $ 2 $ 個含まれます。しかし、それぞれに含まれる値の集合はどちらも $ {\\ 1,2\\ } $ となり、一致します。 また、$ 6 $ 番目のクエリにおいては各値が現れる順番が異なりますが、やはり集合としては一致します。 分析： 考虑对$A,B$进行哈希。 由于集合的相等与数的顺序无关，所以需要一个交换律运算，考虑使用异或运算。 构造出的哈希函数为：$$H(S)&#x3D;\\bigoplus_{s\\in S}f(s)$$其中$f(s)$是一个数字产生数字的哈希函数，于是有$$H(S \\cup {x})&#x3D;\\begin{cases} H(S) &amp; x \\in S \\ H(S)\\oplus f(x) &amp; x ot \\in S\\end{cases}$$对于每次询问，直接判断即可。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;const int N=2e5+5,mod=1610612741;int n,m;int a[N],b[N];unordered_set&lt;int&gt;sa,sb;int f(int x)&#123; return 1ll*13331*x%mod;&#125;int main()&#123; cin &gt;&gt; n; for(int i=1;i&lt;=n;i++)&#123; cin &gt;&gt; a[i]; if(sa.count(a[i]))&#123; a[i]=a[i-1]; &#125; else&#123; sa.insert(a[i]); a[i]=a[i-1]^f(a[i]); &#125; &#125; for(int i=1;i&lt;=n;i++)&#123; cin &gt;&gt; b[i]; if(sb.count(b[i]))&#123; b[i]=b[i-1]; &#125; else&#123; sb.insert(b[i]); b[i]=b[i-1]^f(b[i]); &#125; &#125; cin &gt;&gt; m; for(int i=1;i&lt;=m;i++)&#123; int x,y; cin &gt;&gt; x &gt;&gt; y; if(a[x]==b[y])cout &lt;&lt;&quot;Yes &quot;; else cout &lt;&lt; &quot;No &quot;; &#125; return 0;&#125; 字典树(trie)支持查询字符串是否出现和插入字符串。 另外，trie可以反映两个字符串之间的前后缀关系。如一个串的结束节点是另外一个串结束节点的祖先， 说明前者是后者的前缀。前后缀的判断可以通过这个性质转化成树上的问题。 例题1：洛谷P3065 [USACO12DEC] First! G [USACO12DEC] First! G题目描述Bessie has been playing with strings again. She found that by changing the order of the alphabet she could make some strings come before all the others lexicographically (dictionary ordering). For instance Bessie found that for the strings “omm”, “moo”, “mom”, and “ommnom” she could make “mom” appear first using the standard alphabet and that she could make “omm” appear first using the alphabet “abcdefghijklonmpqrstuvwxyz”. However, Bessie couldn’t figure out any way to make “moo” or “ommnom” appear first. Help Bessie by computing which strings in the input could be lexicographically first by rearranging the order of the alphabet. To compute if string X is lexicographically before string Y find the index of the first character in which they differ, j. If no such index exists then X is lexicographically before Y if X is shorter than Y. Otherwise X is lexicographically before Y if X[j] occurs earlier in the alphabet than Y[j]. Bessie一直在研究字符串。她发现，通过改变字母表的顺序，她可以按改变后的字母表来排列字符串（字典序大小排列）。 例如，Bessie发现，对于字符串串“omm”，“moo”，“mom”和“ommnom”，她可以使用标准字母表使“mom”排在第一个（即字典序最小），她也可以使用字母表“abcdefghijklonmpqrstuvwxyz”使得“omm”排在第一个。然而，Bessie想不出任何方法（改变字母表顺序）使得“moo”或“ommnom”排在第一个。 接下来让我们通过重新排列字母表的顺序来计算输入中有哪些字符串可以排在第一个（即字典序最小），从而帮助Bessie。 要计算字符串X和字符串Y按照重新排列过的字母表顺序来排列的顺序，先找到它们第一个不同的字母X[i]与Y[i]，按重排后的字母表顺序比较，若X[i]比Y[i]先，则X的字典序比Y小，即X排在Y前；若没有不同的字母，则比较X与Y长度，若X比Y短，则X的字典序比Y小，即X排在Y前。 输入格式* Line 1: A single line containing N (1 &lt;&#x3D; N &lt;&#x3D; 30,000), the number of strings Bessie is playing with. * Lines 2..1+N: Each line contains a non-empty string. The total number of characters in all strings will be no more than 300,000. All characters in input will be lowercase characters ‘a’ through ‘z’. Input will contain no duplicate strings. 第1行：一个数字N（1 &lt;&#x3D; N &lt;&#x3D; 30,000），Bessie正在研究的字符串的数量。 第2N+1行：每行包含一个非空字符串。所有字符串包含的字符总数不会超过300,000。 输入中的所有字符都是小写字母，即az。 输入不包含重复的字符串。 输出格式* Line 1: A single line containing K, the number of strings that could be lexicographically first. * Lines 2..1+K: The (1+i)th line should contain the ith string that could be lexicographically first. Strings should be output in the same order they were given in the input. 第1行：一个数字K，表示按重排后的字母表顺序排列的字符串有多少可以排在第一个数量。 第2~K+1行：第i+1行包含第i个按重排后的字母表顺序排列后可以排在第一个的字符串。字符串应该按照它们在输入中的顺序来输出。 样例 #1样例输入 #1123454ommmoomomommnom 样例输出 #11232ommmom 提示The example from the problem statement. Only “omm” and “mom” can be ordered first. 样例即是题目描述中的例子，只有“omm”和“mom”在各自特定的字典序下可以被排列在第一个。 分析： 考虑到字典序比大小只和第一个不相同的字符有关，联想到可以在Trie树上做这个事情。 分情况讨论， 对26个字母连边表示如果要当前串字典序最小，这些字母应该满足什么要求即可。 考虑拿着这个串在Trie上走， 那么走到当前位置以后，因为要求当前串最小，所以要对同一层的其余子树里面有串的字符连边，表示当前字母小，这样可以得到一个有向图，判断这个有向图有没有环就可以判断有没有矛盾。 这样我们考虑了所有没有前后缀关系的串，对于有前后缀关系的串，如果一个串的终止节点的祖先中存在别的串终止节点，这个串一定不是最小串。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;bits/stdc++.h&gt;using namespace std;const int N=3e4+5,M=3e5+5;int n;string s[N];int trie[M][30];int cnt[M];int idx;void insert(string str)&#123; int now=0; for(int i=0;i&lt;str.length();i++)&#123; if(!trie[now][str[i]-&#x27;a&#x27;])&#123; trie[now][str[i]-&#x27;a&#x27;]=++idx; &#125; now=trie[now][str[i]-&#x27;a&#x27;]; &#125; cnt[now]++;&#125;int d[30];int h[30],ne[30*M],to[30*M],eidx;void addedge(int u,int v)&#123; ne[++eidx]=h[u]; h[u]=eidx; to[eidx]=v; d[v]++;&#125;bool check(string str)&#123; memset(d,0,sizeof d); memset(h,0,sizeof h); eidx=0; int now=0; for(int i=0;i&lt;str.length();i++)&#123; if(cnt[now])return 0; for(int j=0;j&lt;26;j++)&#123; if(trie[now][j]&amp;&amp;j!=str[i]-&#x27;a&#x27;)&#123; addedge(str[i]-&#x27;a&#x27;,j); &#125; &#125; now=trie[now][str[i]-&#x27;a&#x27;]; &#125; queue&lt;int&gt;q; while(!q.empty())&#123; q.pop(); &#125; for(int i=0;i&lt;26;i++)&#123; if(d[i]==0)q.push(i); &#125; while(!q.empty())&#123; int t=q.front(); q.pop(); for(int i=h[t];i;i=ne[i])&#123; d[to[i]]--; if(d[to[i]]==0)q.push(to[i]); &#125; &#125; for(int i=0;i&lt;26;i++)&#123; if(d[i])return 0; &#125; return 1;&#125;int ans;bool out[N];int main()&#123; cin &gt;&gt; n; for(int i=1;i&lt;=n;i++)&#123; cin &gt;&gt; s[i]; insert(s[i]); &#125; for(int i=1;i&lt;=n;i++)&#123; if(check(s[i]))&#123; ans++; out[i]=1; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; for(int i=1;i&lt;=n;i++)&#123; if(out[i])cout &lt;&lt; s[i] &lt;&lt; endl; &#125; return 0;&#125; 例题2：洛谷P4551 最长异或路径 最长异或路径题目描述给定一棵 $n$ 个点的带权树，结点下标从 $1$ 开始到 $n$。寻找树中找两个结点，求最长的异或路径。 异或路径指的是指两个结点之间唯一路径上的所有边权的异或。 输入格式第一行一个整数 $n$，表示点数。 接下来 $n-1$ 行，给出 $u,v,w$ ，分别表示树上的 $u$ 点和 $v$ 点有连边，边的权值是 $w$。 输出格式一行，一个整数表示答案。 样例 #1样例输入 #1123441 2 32 3 42 4 6 样例输出 #117 提示最长异或序列是 $1,2,3$，答案是 $7&#x3D;3\\oplus 4$。 数据范围$1\\le n \\le 100000;0 &lt; u,v \\le n;0 \\le w &lt; 2^{31}$。 例题3：洛谷CF888G Xor-MST Xor-MST题面翻译 给定 $n$ 个结点的无向完全图。每个点有一个点权为 $a_i$。连接 $i$ 号结点和 $j$ 号结点的边的边权为 $a_i\\oplus a_j$。 求这个图的 MST 的权值。 $1\\le n\\le 2\\times 10^5$，$0\\le a_i&lt; 2^{30}$。 题目描述You are given a complete undirected graph with $ n $ vertices. A number $ a_{i} $ is assigned to each vertex, and the weight of an edge between vertices $ i $ and $ j $ is equal to $ a_{i}xora_{j} $ . Calculate the weight of the minimum spanning tree in this graph. 输入格式The first line contains $ n $ ( $ 1&lt;&#x3D;n&lt;&#x3D;200000 $ ) — the number of vertices in the graph. The second line contains $ n $ integers $ a_{1} $ , $ a_{2} $ , …, $ a_{n} $ ( $ 0&lt;&#x3D;a_{i}&lt;2^{30} $ ) — the numbers assigned to the vertices. 输出格式Print one number — the weight of the minimum spanning tree in the graph. 样例 #1样例输入 #11251 2 3 4 5 样例输出 #118 样例 #2样例输入 #21241 2 3 4 样例输出 #218 KMPKMP是最经典的字符串算法之一。 用于解决字符串匹配问题，可以求出自身每个前缀的最长border。 border：既是前缀又是后缀的非本身的子串 例题1：洛谷P5829 【模板】失配树 【模板】失配树题目描述给定一个字符串 $s$，定义它的 $k$ 前缀 $\\mathit{pre}k$ 为字符串 $s{1\\dots k}$，**$k$ 后缀** $\\mathit{suf}k$ 为字符串 $s{|s|-k+1\\dots |s|}$，其中 $1 \\le k \\le |s|$。 定义 $\\bold{Border}(s)$ 为对于 $i \\in [1, |s|)$，满足 $\\mathit{pre}_i &#x3D; \\mathit{suf}_i$ 的字符串 $\\mathit{pre}_i$ 的集合。$\\bold{Border}(s)$ 中的每个元素都称之为字符串 $s$ 的 $\\operatorname{border}$。 有 $m$ 组询问，每组询问给定 $p,q$，求 $s$ 的 $\\boldsymbol{p}$ 前缀 和 $\\boldsymbol{q}$ 前缀 的 最长公共 $\\operatorname{border}$ 的长度。 输入格式第一行一个字符串 $s$。 第二行一个整数 $m$。 接下来 $m$ 行，每行两个整数 $p,q$。 输出格式对于每组询问，一行一个整数，表示答案。若不存在公共 $\\operatorname{border}$，请输出 $0$。 样例 #1样例输入 #11234567aaaabbabbaa52 47 103 41 24 11 样例输出 #11234511202 样例 #2样例输入 #212345zzaaccaazzccaacczz32 1810 183 5 样例输出 #2123120 提示样例 $2$ 说明： 对于第一个询问，$2$ 前缀和 $18$ 前缀分别是 zz 和 zzaaccaazzccaacczz，由于 zz 只有一个 $\\operatorname{border}$，即 z，故最长公共 $\\operatorname{border}$ 长度为 $1$。 对于 $16%$ 的数据，$s$ 中的字符全部相等。 对于 $100%$ 的数据，$1\\leq p,q \\le |s|\\leq 10^6$，$1 \\leq m \\leq 10^5$，$s_i \\in [\\texttt{a}, \\texttt{z}]$ 分析： 先给出一个border的性质。 $S[1\\cdots i]$ 的所有border由 $next[S\\cdots i]], next[next[S[1\\cdots i]]], next[next[next[S[1\\cdots i]]]], \\cdots$ 等给出。 其中 $next[i]$ 是 $i$ 这个位置的最长border数组。 考虑 $next[i]$ 是 $i$ 最长的border， 那么 $i$ 剩下的border一定比 $next[i]$ 短， 且一定是 $next[i]$ 的border。 那么把$ i \\to next[i]$ 建边这就是一棵树， 公共最长border就是 LCA 。 写一个求 LCA 即可。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;using namespace std;const int N=1e6+5;string s;int n,m;int nxt[N];int h[N],ne[N],to[N];int idx;int fa[N][21],d[N];void addedge(int u,int v)&#123; ne[++idx]=h[u]; h[u]=idx; to[idx]=v; fa[v][0]=u; d[v]=d[u]+1;&#125;void init()&#123; for(int i=1;i&lt;=20;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; fa[j][i]=fa[fa[j][i-1]][i-1]; &#125; &#125;&#125;int lca(int x,int y)&#123; if(d[x]&lt;d[y])swap(x,y); if(d[x]!=d[y])&#123; for(int i=20;i&gt;=0;i--)&#123; if(d[fa[x][i]]&gt;=d[y])x=fa[x][i]; &#125; &#125; if(x==y)return x; for(int i=20;i&gt;=0;i--)&#123; if(fa[x][i]!=fa[y][i])&#123; x=fa[x][i],y=fa[y][i]; &#125; &#125; return fa[x][0];&#125;int main()&#123; cin &gt;&gt; s; n=s.length(); s=&quot; &quot;+s; for(int i=2,j=0;i&lt;=n;i++)&#123; while(j&amp;&amp;s[i]!=s[j+1])j=nxt[j]; if(s[i]==s[j+1])j++; nxt[i]=j; &#125; for(int i=1;i&lt;=n;i++)&#123; addedge(nxt[i],i); &#125; init(); cin &gt;&gt; m; for(int i=1;i&lt;=m;i++)&#123; int x,y; cin &gt;&gt; x &gt;&gt; y; cout &lt;&lt; lca(nxt[x],nxt[y]) &lt;&lt; endl; &#125; return 0;&#125; 例题2：洛谷P3193 [HNOI2008] GT考试 [HNOI2008] GT考试题目描述阿申准备报名参加 GT 考试，准考证号为 $N$ 位数$X_1,X_2…X_n\\ (0\\le X_i\\le 9)$，他不希望准考证号上出现不吉利的数字。他的不吉利数字$A_1,A_2,\\cdots, A_m\\ (0\\le A_i\\le 9)$ 有 $M$ 位，不出现是指 $X_1,X_2\\cdots X_n$ 中没有恰好一段等于 $A_1,A_2,\\cdots ,A_m$，$A_1$ 和 $X_1$ 可以为 $0$。 输入格式第一行输入 $N,M,K$ 接下来一行输入 $M$ 位的数。 输出格式阿申想知道不出现不吉利数字的号码有多少种，输出模 $K$ 取余的结果。 样例 #1样例输入 #1124 3 100111 样例输出 #1181 提示数据范围及约定对于全部数据，$N\\leq10^9$，$M\\leq 20$，$K\\leq1000$。 离散化对于某些问题，我们往往只需考虑一些关键值以及其附近的值。 例题1：洛谷 CF930E Coins Exhibition Coins Exhibition题面翻译题目大意有$k(1 \\leq k \\leq 10^9)$个硬币，每个硬币有正面朝上和反面朝上两种状态。 现有$n+m(0 \\leq n,m \\leq 10^5)$个限制条件，每个限制条件形如$(l_i,r_i)(1 \\leq l_i \\leq r_i \\leq k)$。前$n$个限制条件限制区间$[l_i,r_i]$内至少有一个硬币正面朝上，后$m$个限制条件限制区间$[l_i,r_i]$内至少有一个硬币反面朝上。 问共有多少种摆放硬币的方案使得所有限制条件都被满足。答案对$10^9+7$取模。 输入数据格式第一行三个整数$k,n,m$ 接下来$n+m$行每行两个正整数$l_i,r_i$表示一个限制区间 输出数据格式一行表示方案数 题目描述Arkady and Kirill visited an exhibition of rare coins. The coins were located in a row and enumerated from left to right from $ 1 $ to $ k $ , each coin either was laid with its obverse (front) side up, or with its reverse (back) side up. Arkady and Kirill made some photos of the coins, each photo contained a segment of neighboring coins. Akrady is interested in obverses, so on each photo made by him there is at least one coin with obverse side up. On the contrary, Kirill is interested in reverses, so on each photo made by him there is at least one coin with its reverse side up. The photos are lost now, but Arkady and Kirill still remember the bounds of the segments of coins each photo contained. Given this information, compute the remainder of division by $ 10^{9}+7 $ of the number of ways to choose the upper side of each coin in such a way, that on each Arkady’s photo there is at least one coin with obverse side up, and on each Kirill’s photo there is at least one coin with reverse side up. 输入格式The first line contains three integers $ k $ , $ n $ and $ m $ ( $ 1&lt;&#x3D;k&lt;&#x3D;10^{9} $ , $ 0&lt;&#x3D;n,m&lt;&#x3D;10^{5} $ ) — the total number of coins, the number of photos made by Arkady, and the number of photos made by Kirill, respectively. The next $ n $ lines contain the descriptions of Arkady’s photos, one per line. Each of these lines contains two integers $ l $ and $ r $ ( $ 1&lt;&#x3D;l&lt;&#x3D;r&lt;&#x3D;k $ ), meaning that among coins from the $ l $ -th to the $ r $ -th there should be at least one with obverse side up. The next $ m $ lines contain the descriptions of Kirill’s photos, one per line. Each of these lines contains two integers $ l $ and $ r $ ( $ 1&lt;&#x3D;l&lt;&#x3D;r&lt;&#x3D;k $ ), meaning that among coins from the $ l $ -th to the $ r $ -th there should be at least one with reverse side up. 输出格式Print the only line — the number of ways to choose the side for each coin modulo $ 10^{9}+7&#x3D;1000000007 $ . 样例 #1样例输入 #1123455 2 21 33 52 24 5 样例输出 #118 样例 #2样例输入 #21234565 3 21 32 23 52 24 5 样例输出 #210 样例 #3样例输入 #31234567891011121360 5 71 350 601 6030 4520 404 56 375 1850 5522 2725 3144 45 样例输出 #31732658600 提示In the first example the following ways are possible (‘O’ — obverse, ‘R’ — reverse side): OROOR, ORORO, ORORR, RROOR, RRORO, RRORR, ORROR, ORRRO. In the second example the information is contradictory: the second coin should have obverse and reverse sides up at the same time, that is impossible. So, the answer is $ 0 $ . 分析： 首先可以得到一个$O(k+n+m)$的做法。 我们对于每个位置$i$求出，在$i$之前（包括$i$）至多能填多少个$1$，那么可以dp，记$f_{i,0&#x2F;1}$表示考虑了前$i$个位置，上个位置选的$0&#x2F;1$合法得到方案数，枚举最后一个相同段的长度（最后一个不同位）即可转移，容易使用前缀和优化至线性。 注意到我们可以将所有$l_i,r_i+1$离散化，将值域划分成若干以关键点作为左端点的区间，那么题中所有$[l_i,r_i]$会对应的到离散化后一段区间的并。 于是我们可以从前往后一段段区间考虑，记$f_{i,0&#x2F;1&#x2F;2}$表示考虑了前$i$段区间，上一个位置全$0$，全$1$，或是$01$交替的方案数，前两者的转移类似，$01$交替时我们直接满足了所有要考虑的限制，$f_{i,2} \\gets (2^{len_i}-2)(f_{i-1,0}+f_{i-1,1}+f_{i-1,2})$即可。 复杂度$O((n+m)\\log(n+m))$，瓶颈在于排序与快速幂（可用基数排序+快速幂做到线性）。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;bits/stdc++.h&gt;using namespace std;const int N=1e5+5,mod=1e9+7;typedef long long ll;ll k,n,m;ll all[4*N];ll cnt;ll find(ll x)&#123; ll l=0,r=cnt; while(l&lt;r)&#123; ll mid=l+r&gt;&gt;1; if(x&lt;=all[mid])r=mid; else l=mid+1; &#125; return l;&#125;long long qkpow(ll x,ll k)&#123; long long a=1; while(k)&#123; if(k&amp;1)a=a*x%mod; x=x*x%mod; k&gt;&gt;=1; &#125; return a%mod;&#125;pair&lt;ll,ll&gt;a1[N],a2[N];ll minn[2][4*N];//枚举最后一个相同串的长度-&gt;求最后一个不同值的位置long long f[4*N][3];int main()&#123; cin &gt;&gt; k &gt;&gt; n &gt;&gt; m; for(ll i=1;i&lt;=n;i++)&#123; ll l,r; cin &gt;&gt; l &gt;&gt; r; l--; all[++cnt]=l,all[++cnt]=r; a1[i]=&#123;l,r&#125;; &#125; for(ll i=1;i&lt;=m;i++)&#123; ll l,r; cin &gt;&gt; l &gt;&gt; r; l--; all[++cnt]=l,all[++cnt]=r; a2[i]=&#123;l,r&#125;; &#125; all[++cnt]=k; sort(all+1,all+cnt+1); cnt=unique(all,all+cnt+1)-(all+1); for(ll i=0;i&lt;=cnt;i++)&#123; minn[0][i]=minn[1][i]=cnt+1; &#125; for(ll i=1;i&lt;=n;i++)&#123; ll l=find(a1[i].first),r=find(a1[i].second); minn[0][l]=min(minn[0][l],r); &#125; for(ll i=1;i&lt;=m;i++)&#123; ll l=find(a2[i].first),r=find(a2[i].second); minn[1][l]=min(minn[1][l],r); &#125; for(ll i=cnt;i;i--)&#123; minn[0][i-1]=min(minn[0][i],minn[0][i-1]); minn[1][i-1]=min(minn[1][i],minn[1][i-1]); &#125; f[cnt][0]=f[cnt][1]=f[cnt][2]=1; for(ll i=cnt-1;i&gt;=0;i--)&#123; f[i][0]=(f[i+1][0]+f[i+1][1]-f[minn[1][i]][1]+f[i+1][2]*(qkpow(2,all[i+1]-all[i])-2)%mod)%mod; f[i][1]=(f[i+1][1]+f[i+1][0]-f[minn[0][i]][0]+f[i+1][2]*(qkpow(2,all[i+1]-all[i])-2)%mod)%mod; f[i][2]=(f[i+1][0]-f[minn[0][i]][0]+f[i+1][1]-f[minn[1][i]][1]+f[i+1][2]*(qkpow(2,all[i+1]-all[i])-2)%mod)%mod; &#125; cout &lt;&lt; (f[0][2]+mod)%mod; return 0;&#125; 例题2：洛谷 CF1835B Lottery Lottery题面翻译简要题意： 给定一个长度为 $n$ 的序列 $v$，其值域为 $[0,m]$。 现在你需要选择一个 $x \\in [0,m]$，使其权值最大。定义一个数 $x$ 的权值为： $$\\sum_{c&#x3D;0}^{m}[\\sum_{i&#x3D;1}^{n}[\\vert v_i - c \\vert \\leq \\vert x - c \\vert] &lt; k]$$ 请你找到权值最大的数 $x$，若有多个，输出最小的那个。 Translated by Demeanor_Roy 题目描述$ n $ people indexed with integers from $ 1 $ to $ n $ came to take part in a lottery. Each received a ticket with an integer from $ 0 $ to $ m $ . In a lottery, one integer called target is drawn uniformly from $ 0 $ to $ m $ . $ k $ tickets (or less, if there are not enough participants) with the closest numbers to the target are declared the winners. In case of a draw, a ticket belonging to the person with a smaller index is declared a winner. Bytek decided to take part in the lottery. He knows the values on the tickets of all previous participants. He can pick whatever value he wants on his ticket, but unfortunately, as he is the last one to receive it, he is indexed with an integer $ n + 1 $ . Bytek wants to win the lottery. Thus, he wants to know what he should pick to maximize the chance of winning. He wants to know the smallest integer in case there are many such integers. Your task is to find it and calculate his chance of winning. 输入格式In the first line of the input, there are the integers $ n $ , $ m $ , and $ k $ ( $ 1 \\leq n \\leq 10^6 $ , $ 0 \\leq m \\leq 10^{18} $ , $ 1 \\leq k \\leq 10^6 $ ). In the following line, there are $ n $ integers separated by a single space, denoting the numbers on tickets received by people participating in a lottery. These numbers are integers in the range from $ 0 $ to $ m $ . 输出格式You should output two integers separated by a single space on the standard output. The first should be equal to the number of target values (from $ 0 $ to $ m $ ), upon drawing which Baytek wins, given that he chooses his ticket optimally. The second should be equal to the integer Bytek should pick to maximize his chance of winning the lottery. 样例 #1样例输入 #1123 6 21 4 5 样例输出 #114 2 样例 #2样例输入 #2127 7 12 4 7 3 0 1 6 样例输出 #211 5 提示In the first example, Bytek wins for $ 4 $ target values (namely $ 0, 1, 2, 3 $ ) if he chooses integer $ 2 $ , which is the lowest optimal value. If he chooses $ 3 $ , he also wins in four cases, but it is not the lowest value. 启发式合并启发式合并大致解决一类有向信息合并问题。具体地，我们需要支持动态将集合$S$合并至集合$T$（之后就再也用不到集合$S$了）这一类操作。 我们用某种数据结构维护集合，合并时若$S$的大小小于$T$的大小，就暴力枚举$S$内的元素加入$T$中，否则直接交换这两个数据结构，再暴力枚举$S$内的元素加入$T$中。 大部分数据结构的交换都是$O(1)$的，若不能高效交换我们可以认为记录每个集合的编号，交换两个集合编号即可。 考虑如何记录复杂度，一个点被暴力插入另一个集合后所在的集合大小总会翻倍，因此其只会被操作$O(\\log n)$次，因此总插入次数$O(n\\log n)$。 例题1：洛谷P8907 [USACO22DEC] Making Friends P [USACO22DEC] Making Friends P题目描述FJ 的 $N(2 \\le N \\le 2 \\times 10^5)$ 头编号为 $1 \\cdots N$ 的奶牛之中初始时有 $M(1 \\le M \\le 2 \\times 10^5)$ 对朋友。奶牛们一头一头地离开农场去度假。第 $i$ 天，第 $i$ 头奶牛离开了农场，同时第 $i$ 头奶牛的所有仍在农场的朋友互相都成为了朋友。问总共建立了多少新的朋友关系？ 输入格式输入的第一行包含 $N$ 和 $M$。 以下 $M$ 行每行包含两个整数 $u_i$ 和 $v_i$，表示奶牛 $u_i$ 和 $v_i$ 是朋友（$1 \\le u_i,v_i \\le N,u_i eq v_i$）。每个奶牛无序对至多出现一次。 输出格式输出一行，包含形成的新的朋友关系的总数。不要计入初始时已经是朋友的奶牛对。 样例 #1样例输入 #11234567&gt;7 6&gt;1 3&gt;1 4&gt;7 1&gt;2 3&gt;2 4&gt;3 5 样例输出 #11&gt;5 提示样例 1 解释第 $1$ 天，三个新的朋友关系被建立：$(3,4)$，$(3,7)$ 和 $(4,7)$。 第 $3$ 天，两个新的朋友关系被建立：$(4,5)$ 和 $(5,7)$。 测试点性质 测试点 $2-3$ 满足 $N \\le 500$。 测试点 $4-7$ 满足 $N \\le 10^4$。 测试点 $8-17$ 没有额外限制。 分析： 考虑一个性质，每次互相连边显然有些多余，不妨转化成将编号最小的点和其它点连边。 考虑正确性，若一头牛$x$出队，不妨设与他相连且编号大于他的牛的编号排序后的结果为 $y_1,y_2,\\cdots,y_k$，我们这种连边策略相当于延时连边，即在$y_1$出队以前连接$y_1 \\to y_2,y_3,\\cdots$ ，$y_2$出队以前连接$y_2 \\to y_3,\\cdots$，每条应当连的边都被连上了至少一次，故存在充分性，所以正确。 代码： 12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;using namespace std;const int N=2e5+5;int n,m;set&lt;int&gt;s[N];long long ans;int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i=1;i&lt;=m;i++)&#123; int u,v; cin &gt;&gt; u &gt;&gt; v; s[min(u,v)].insert(max(u,v)); &#125; for(int i=1;i&lt;=n;i++)&#123; if(s[i].empty())continue; ans+=s[i].size(); int t=*s[i].begin(); s[i].erase(s[i].begin()); if(s[i].size()&gt;s[t].size())swap(s[i],s[t]); for(auto x:s[i])&#123; s[t].insert(x); &#125; &#125; cout &lt;&lt; ans-m &lt;&lt; endl; return 0;&#125; 例题2：[洛谷CF1416D Graph and Queries](Graph and Queries - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)) Graph and Queries题面翻译给定一个 $n$ 个点 $m$ 条边的无向图，第 $i$ 个点的点权初始值为 $p_i$,所有 $p_i$ 互不相同。 接下来进行 $q$ 次操作，分为两类： $\\tt 1\\ v$ 查询与 $v$ 连通的点中， $p_u$ 最大的点 $u$ 并输出 $p_u$，然后让 $p_u&#x3D;0$。 $\\tt 2\\ i$ 将第 $i$ 条边删掉。 翻译者：一只书虫仔 题目描述You are given an undirected graph consisting of $ n $ vertices and $ m $ edges. Initially there is a single integer written on every vertex: the vertex $ i $ has $ p_i $ written on it. All $ p_i $ are distinct integers from $ 1 $ to $ n $ . You have to process $ q $ queries of two types: $ 1 $ $ v $ — among all vertices reachable from the vertex $ v $ using the edges of the graph (including the vertex $ v $ itself), find a vertex $ u $ with the largest number $ p_u $ written on it, print $ p_u $ and replace $ p_u $ with $ 0 $ ; $ 2 $ $ i $ — delete the $ i $ -th edge from the graph. Note that, in a query of the first type, it is possible that all vertices reachable from $ v $ have $ 0 $ written on them. In this case, $ u $ is not explicitly defined, but since the selection of $ u $ does not affect anything, you can choose any vertex reachable from $ v $ and print its value (which is $ 0 $ ). 输入格式The first line contains three integers $ n $ , $ m $ and $ q $ ( $ 1 \\le n \\le 2 \\cdot 10^5 $ ; $ 1 \\le m \\le 3 \\cdot 10^5 $ ; $ 1 \\le q \\le 5 \\cdot 10^5 $ ). The second line contains $ n $ distinct integers $ p_1 $ , $ p_2 $ , …, $ p_n $ , where $ p_i $ is the number initially written on vertex $ i $ ( $ 1 \\le p_i \\le n $ ). Then $ m $ lines follow, the $ i $ -th of them contains two integers $ a_i $ and $ b_i $ ( $ 1 \\le a_i, b_i \\le n $ , $ a_i e b_i $ ) and means that the $ i $ -th edge connects vertices $ a_i $ and $ b_i $ . It is guaranteed that the graph does not contain multi-edges. Then $ q $ lines follow, which describe the queries. Each line is given by one of the following formats: $ 1 $ $ v $ — denotes a query of the first type with a vertex $ v $ ( $ 1 \\le v \\le n $ ). $ 2 $ $ i $ — denotes a query of the second type with an edge $ i $ ( $ 1 \\le i \\le m $ ). For each query of the second type, it is guaranteed that the corresponding edge is not deleted from the graph yet. 输出格式For every query of the first type, print the value of $ p_u $ written on the chosen vertex $ u $ . 样例 #1样例输入 #11234567891011125 4 61 2 5 4 31 22 31 34 51 12 12 31 11 21 2 样例输出 #112345120 分析： 倒序处理，删边可以变为加边，直接进行启发式合并即可，但是操作1强制在线，不能直接做。 我们将启发式合并的结构离线，记录下形如“将某个集合全部加入另一个集合”的信息，倒序处理后我们便知道一次操作应当将集合内的哪些元素分裂出来，于是就可以在线性处理。 使用set维护每个连通块，删除时暴力删除即可，复杂度$O(n\\log ^2 n)$，不能通过本题。 考虑使用vector，在里面存下所有连通块内的值，初始我们令整个vector有序，之后我们对于每个点打上属于某个连通块的标记，相当于在之前的块中删除，这样就可以类似两个优先队列支持删除。 复杂度$O(n\\log n)$。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;bits/stdc++.h&gt;using namespace std;const int N=5e5+5;int n,m,q;vector&lt;int&gt;v[N];int a[N];int mu[N],mv[N];//记录边int qo[N],qx[N],r[N];//记录询问int bel[N],used[N];//记录属于哪个连通块和是否已经被删除int del[N];//记录边是否被删除int fa[N],sz[N];//并查集int find(int x)&#123; return (x==fa[x])?x:find(fa[x]);&#125;int merge(int x,int y)&#123; x=find(x),y=find(y); if(x==y)return 0; if(sz[x]&lt;sz[y])swap(x,y); sz[x]+=sz[y]; for(auto t:v[y])v[x].push_back(t); fa[y]=x; return y;&#125;int get(int x)&#123; while(v[x].size()&amp;&amp;(bel[v[x].back()]!=x||used[v[x].back()]))&#123;//找到最大的属于连通块的没被删除的点 v[x].pop_back(); &#125; if(!v[x].size())return 0;//没找到 int t=v[x].back(); used[t]=1;//标记删除 v[x].pop_back(); return t;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0),cout.tie(0); cin &gt;&gt; n &gt;&gt; m &gt;&gt; q; for(int i=1;i&lt;=n;i++)&#123; cin &gt;&gt; a[i]; v[i].push_back(a[i]); fa[i]=i,sz[i]=1; &#125; for(int i=1;i&lt;=m;i++)&#123; cin &gt;&gt; mu[i] &gt;&gt; mv[i]; &#125; for(int i=1;i&lt;=q;i++)&#123; cin &gt;&gt; qo[i] &gt;&gt; qx[i]; if(qo[i]==2)del[qx[i]]=1;//记录删除的边 &#125; for(int i=1;i&lt;=m;i++)&#123;//连接没被删除过的边 if(del[i])continue; merge(mu[i],mv[i]); &#125; for(int i=q;i&gt;=1;i--)&#123;//逆序处理连边 int x=find(mu[qx[i]]),y=find(mv[qx[i]]); if(qo[i]==1||x==y)continue; r[i]=merge(x,y);//记录每次操作后被合并到其他连通块的连通块编号 &#125; for(int i=1;i&lt;=n;i++)&#123;//排序，记录值属于哪个连通块 sort(v[i].begin(),v[i].end()); bel[a[i]]=find(i); &#125; for(int i=1;i&lt;=q;i++)&#123; if(qo[i]==1)cout &lt;&lt; get(find(qx[i])) &lt;&lt; endl; else if(r[i])&#123;//删边 for(auto x:v[r[i]])bel[x]=r[i];//将这次操作原来不属于当前连通块的点还原 fa[r[i]]=r[i]; &#125; &#125; return 0;&#125; 扫描线To Be Update搜索例题1：洛谷[ABC252Ex] K-th beautiful Necklace [ABC252Ex] K-th beautiful Necklace题面翻译给定 $ n $ 个珠子，每个珠子的颜色为 $ d_i $，权值为 $ v_i $。颜色共有 $ c $ 种，且保证每种颜色至少有一颗珠子。你需要从 $ n $ 个珠子种选择 $ c $ 个颜色不同的珠子串成一条项链，其权值为其中所有珠子权值的异或和。你需要输出权值第 $ k $ 大的项链的权值。只要选取的珠子不同，即使权值相同也算不同项链。数据保证可能构成的项链数不小于 $ k $。 题目描述$ N $ 個の宝石があります。$ i $ 番目の宝石は色が $ D_i $ で美しさが $ V_i $ です。 ここで、色は $ 1,2,\\ldots,C $ のいずれかであり、どの色の宝石も少なくとも $ 1 $ 個存在します。 $ N $ 個の宝石から、色が相異なる $ C $ 個の宝石を選んでネックレスを作ります。（選ぶ順番は考えません。） ネックレスの美しさは選んだ宝石の美しさのビットごとの $ \\rm\\ XOR $ となります。 全てのありえるネックレスの作り方のうち、美しさが $ K $ 番目に大きいもののネックレスの美しさを求めてください。（同じ美しさの作り方が複数存在する場合、それらは全て数えます。） ビットごとの $ \\rm\\ XOR $ とは 整数 $ A,\\ B $ のビットごとの $ \\rm\\ XOR $ 、$ A\\ {\\rm\\ XOR}\\ B $ は、以下のように定義されます。 - $ A\\ {\\rm\\ XOR}\\ B $ を二進表記した際の $ 2^k $ ($ k\\ \\geq\\ 0 $) の位の数は、$ A,\\ B $ を二進表記した際の $ 2^k $ の位の数のうち一方のみが $ 1 $ であれば $ 1 $、そうでなければ $ 0 $ である。 例えば、$ 3\\ {\\rm\\ XOR}\\ 5\\ &#x3D;\\ 6 $ となります (二進表記すると: $ 011\\ {\\rm\\ XOR}\\ 101\\ &#x3D;\\ 110 $)。 输入格式入力は以下の形式で標準入力から与えられる。 $ N $ $ C $ $ K $ $ D_1 $ $ V_1 $ $ \\vdots $ $ D_N $ $ V_N $ 输出格式答えを出力せよ。 样例 #1样例输入 #1123454 2 32 42 61 21 3 样例输出 #115 样例 #2样例输入 #212343 1 21 01 01 0 样例输出 #210 样例 #3样例输入 #3123456789101110 3 111 4142135623730950481 7320508075688772932 2360679774997896962 4494897427831780982 6457513110645905902 8284271247461900973 1622776601683793313 3166247903553998493 4641016151377545873 605551275463989293 样例输出 #31766842905529259824 提示制約 $ 1\\ \\leq\\ C\\ \\leq\\ N\\ \\leq\\ 70 $ $ 1\\ \\leq\\ D_i\\ \\leq\\ C $ $ 0\\ \\leq\\ V_i\\ &lt;\\ 2^{60} $ $ 1\\ \\leq\\ K\\ \\leq\\ 10^{18} $ 少なくとも $ K $ 種類のネックレスを作ることができる 入力に含まれる値は全て整数である Sample Explanation 1以下のような $ 4 $ 種類のネックレスを作ることができます。 - $ 1,3 $ 番目の宝石を選ぶ。ネックレスの美しさは $ 4\\ {\\rm\\ XOR}\\ 2\\ &#x3D;6 $ となる。 - $ 1,4 $ 番目の宝石を選ぶ。ネックレスの美しさは $ 4\\ {\\rm\\ XOR}\\ 3\\ &#x3D;7 $ となる。 - $ 2,3 $ 番目の宝石を選ぶ。ネックレスの美しさは $ 6\\ {\\rm\\ XOR}\\ 2\\ &#x3D;4 $ となる。 - $ 2,4 $ 番目の宝石を選ぶ。ネックレスの美しさは $ 6\\ {\\rm\\ XOR}\\ 3\\ &#x3D;5 $ となる。 よって美しさが $ 3 $ 番目に大きいネックレスの美しさは $ 5 $ となります。 Sample Explanation 2$ 3 $ 種類のネックレスを作ることができ、いずれも美しさは $ 0 $ です。"},{"title":"哈希表","path":"/2024/07/25/哈希表/","content":"哈希表作用：类似离散化，将值域较大的一些数映射进较小的范围中，并快速查询是否存在 一般可以用取模运算来映射，取模时最好取质数 注意：c++取模时会出现负数，所以取模后加上$mod$再次取模即可 若重复，解决方法： 拉链法：利用链表存储重复元素 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std;const int N=100003;int n;int h[N],ne[N],e[N];int cnt;void insert(int x)&#123; e[++cnt]=x; x=(x%N+N)%N; ne[cnt]=h[x]; h[x]=cnt;&#125;bool find(int x)&#123; int t=(x%N+N)%N; for(int i=h[t];i;i=ne[i])&#123; if(e[i]==x)return 1; &#125; return 0;&#125;int main()&#123; cin &gt;&gt; n; for(int i=1;i&lt;=n;i++)&#123; char op[2]; cin &gt;&gt; op; int tmp; cin &gt;&gt; tmp; if(op[0]==&#x27;I&#x27;)&#123; insert(tmp); &#125; else&#123; if(find(tmp))cout &lt;&lt; &quot;Yes &quot;; else cout &lt;&lt; &quot;No &quot;; &#125; &#125; return 0;&#125; 开放寻址法 遇到冲突时向后遍历第一个空的地方插入。 为了减小向后查找的次数，数组一般开两倍大小。 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;using namespace std;const int N=200003,INF=0x3f3f3f3f;int n,Hash[N];int find(int x)&#123; int t=(x%N+N)%N; while(Hash[t]!=INF)&#123; if(Hash[t]==x)return t; t++; if(t==n)t=0; &#125; return t;&#125;void insert(int x)&#123; Hash[find(x)]=x;&#125;int main()&#123; memset(Hash,0x3f,sizeof Hash); cin &gt;&gt; n; for(int i=1;i&lt;=n;i++)&#123; char op[2]; cin &gt;&gt; op; int x; cin &gt;&gt; x; if(op[0]==&#x27;I&#x27;)&#123; insert(x); &#125; else&#123; if(Hash[find(x)]==x)cout &lt;&lt; &quot;Yes &quot;; else cout &lt;&lt; &quot;No &quot;; &#125; &#125; return 0;&#125; 应用：字符串哈希作用：快速判断两个字符串是否相同 字符串前缀哈希法： 先处理字符串前缀的哈希值$h$：$$h[i]&#x3D;\\sum_{\\mathclap{1\\le i\\le n}} (str_i-‘A’) %Q$$ 然后可以通过$h$数组求出字符串任意的子串哈希值$$hash(L,R)&#x3D;(h[R]-h[L-1]\\times P^{R-L+1})%Q$$ 此后，比较两个字符串是否相等就可以比较两个字符串的哈希值是否相等。 注意：因为部分数值到达了$2^{64}$,因此需要unsigned long long 12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;typedef unsigned long long ull;const int N=1e5+5,P=131;int n,m;string s;ull h[N];ull p[N];int get(char ch)&#123; if(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)return ch-&#x27;0&#x27;+1; if(ch&gt;=&#x27;a&#x27;&amp;&amp;ch&lt;=&#x27;z&#x27;)return ch-&#x27;a&#x27;+11; if(ch&gt;=&#x27;A&#x27;&amp;&amp;ch&lt;=&#x27;Z&#x27;)return ch-&#x27;A&#x27;+37;&#125;ull Hash(int l,int r)&#123; return h[r]-h[l-1]*p[r-l+1];&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; cin &gt;&gt; s; p[0]=1; for(int i=1;i&lt;=n;i++)&#123; p[i]=p[i-1]*P; h[i]=h[i-1]*P+get(s[i-1]); &#125; for(int i=1;i&lt;=m;i++)&#123; int l1,r1,l2,r2; cin &gt;&gt; l1 &gt;&gt; r1 &gt;&gt; l2 &gt;&gt; r2; if(Hash(l1,r1)==Hash(l2,r2))cout &lt;&lt; &quot;Yes &quot;; else cout &lt;&lt; &quot;No &quot;; &#125; return 0;&#125;"},{"title":"双指针","path":"/2024/07/25/双指针/","content":"双指针通用模板： 1234for(int i=1,j=1;i&lt;=n;i++)&#123; while(j&lt;i&amp;&amp;check(i,j))j++; //每到题目的具体逻辑&#125; 核心思想: 将$O(n^2)$的朴素算法: 12345for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; &#125;&#125; 通过某种性质（当$i$移动时，$j$只会向后移动或不动(单调性)），优化成$O(n)$ 例：给定一个$n$项数列$s$，求最长连续不重复子序列（连续，不包含重复元素的最长子序列）的长度 分析：暴力做法： 12345for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=i;j++)&#123; if(check(j,i))ans=max(ans,i-j+1); &#125;&#125; 通过分析可以发现，当$i$增加时，$j$一定不会减小(当$i&#x3D;a，j&#x3D;b$时，若$j&#x3D;b-1$，则序列中有重复元素，当$i&#x3D;a+1$时，$j$若减小，必然包含$s[b-1]$,则序列中必有重复元素)，因此可以使用双指针: 1234for(int i=1,j=1;i&lt;=n;i++)&#123; while(i&lt;=j&amp;&amp;check(j,i))j++; ans=max(ans,i-j+1);&#125; 再考虑$check$,不难想到，可以用数组$b$记录$[j,i]$中数组出现的个数，但这样依旧会超时，于是考虑优化。 可以发现，每次$i$增加$1$时，只有$b[s[i]]$会增加$1$，而之前已经保证$b$中每个元素都小于等于$1$，所以只用考虑$b[s[i]]$，则增加$j$之前$b[s[j]]–$,每次判断$b[s[i]]$是否为$1$,若为$1$,则$j$满足要求，记录答案。不难看出，当$b[s[i]]&#x3D;1$是，$j$一定小于等于$i$，可以不用判断。 代码实现如下: 123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;using namespace std;const int N=1e5+5;int n;int s[N],b[N];int ans;int main()&#123; cin &gt;&gt; n; for(int i=1;i&lt;=n;i++)&#123; cin &gt;&gt; s[i]; &#125; for(int i=1,j=1;i&lt;=n;i++)&#123; b[s[i]]++; while(b[s[i]]&gt;1)b[s[j]]--,j++; ans=max(ans,i-j+1); &#125; cout &lt;&lt; ans; return 0;&#125;"},{"title":"单调队列和单调栈","path":"/2024/07/25/单调队列和单调栈/","content":"单调队列和单调栈单调队列应用：滑动窗口中的最大（最小值） 例：给定一个数列$a$，窗口的长度$k$，求滑动窗口的最小值和最大值 分析：以最大值为例：用队列存储当前窗口的值，保证队头是最大值，每次滑动窗口时先判断队头是否过期，若过期，则弹出队头，然后从队尾开始把小于等于当前数的数删除(当前数后出队，比它大，则一定不会取它),在插入当前数。为了方便判断过期，队列中存储的是下标。 12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;using namespace std;const int N=1e6+5;int n,k;int a[N];int q[N],hh,tt=-1;int main()&#123; cin &gt;&gt; n &gt;&gt; k; for(int i=1;i&lt;=n;i++)&#123; cin &gt;&gt; a[i]; &#125; for(int i=1;i&lt;=n;i++)&#123;//最小 if(hh&lt;=tt&amp;&amp;i-k+1&gt;q[hh])hh++; while(hh&lt;=tt&amp;&amp;a[q[tt]]&gt;=a[i])tt--; q[++tt]=i; if(i&gt;=k)cout &lt;&lt; a[q[hh]] &lt;&lt; &#x27; &#x27;; &#125; cout &lt;&lt; endl; hh=0,tt=-1; for(int i=1;i&lt;=n;i++)&#123;//最大 if(hh&lt;=tt&amp;&amp;i-k+1&gt;q[hh])hh++; while(hh&lt;=tt&amp;&amp;a[q[tt]]&lt;=a[i])tt--; q[++tt]=i; if(i&gt;=k)cout &lt;&lt; a[q[hh]] &lt;&lt; &#x27; &#x27;; &#125;&#125; 单调栈应用：求出每个数左边第一个比它小的数 分析：先考虑朴素做法： 12345678for(int i=1;i&lt;=n;i++)&#123; for(int j=i-1;j&gt;=1;j--)&#123; if(s[j]&lt;s[i])&#123; cout &lt;&lt; s[j] &lt;&lt; &#x27; &#x27;; break; &#125; &#125;&#125; 通过分析可以发现，如果$a[i]\\ge aj$，那么$a[i]$永远不会是右边的数的答案，所以利用栈，每次插入时把所有大于等于当前数的数弹出，直到队列为空时或栈顶小于当前数时为止，这样就能快速求出每个数左边第一个比它小的数。可以发现，这样形成的栈具有单调性，被称为单调栈。 代码实现： 12345678for(int i=1;i&lt;=n;i++)&#123; int tmp; cin &gt;&gt; tmp; while(tt&amp;&amp;stk[tt]&gt;=tmp)tt--; if(tt)cout &lt;&lt; stk[tt] &lt;&lt; &#x27; &#x27;; else cout &lt;&lt; -1 &lt;&lt; &#x27; &#x27;; stk[++tt]=tmp;&#125;"},{"title":"区间合并","path":"/2024/07/25/区间合并/","content":"区间合并作用：快速将几个有交集的区间合并成一个区间 方法： 按区间左端点排序 从左到右扫描区间： 若当前区间与后面的区间都没有交集，记录答案 若当前区间包含下一个区间，继续判断后面 若当前区间与下一个区间相交，则当前区间的右端点变为下个区间的右端点 不难发现，后两种情况可以合并成当前区间的右端点变为当前右端点和下一个区间右端点的最大值。 例：给定$n$个区间$[l_i,r_i]$，合并区间，输出合并后区间的个数 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int,int&gt; PII;const int N=1e5+5;int n;PII a[N];vector&lt;PII&gt;ans;void merge()&#123; sort(a+1,a+n+1); int s=-2e9,t=-2e9; for(int i=1;i&lt;=n;i++)&#123; if(t&lt;a[i].first)&#123; if(t!=-2e9)ans.push_back(&#123;s,t&#125;); s=a[i].first,t=a[i].second; &#125; else&#123; t=max(t,a[i].second); &#125; &#125; if(s!=-2e9)ans.push_back(&#123;s,t&#125;);&#125;int main()&#123; cin &gt;&gt; n; for(int i=1;i&lt;=n;i++)&#123; int l,r; cin &gt;&gt; l &gt;&gt; r; a[i]=&#123;l,r&#125;; &#125; merge(); cout &lt;&lt; ans.size(); return 0;&#125;"},{"title":"动态规划","path":"/2024/07/25/动态规划/","content":"动态规划数位dp数位dp是一种经典的dp模型，它的主要应用场景是与大整数及其数码有关的问题。这种问题比较好辨认，一般具有这几个特征： 要求统计满足一定条件的数的数量（即，最终目的为计数）； 这些条件经过转化后可以使用「数位」的思想去理解和判断； 输入会提供一个数字区间（有时也只提供上界）来作为统计的限制； 上界很大（比如 $10^{18}$），暴力枚举验证会超时。 数位dp的主要思想是，把大整数看成一个由 $0 \\sim 9$ 构成的整数序列而不是一个数。并采用序列 dp 的方式，从高位到低位一位一位地 dp。 例题1：洛谷P2657 [SCOI2009] windy 数 [SCOI2009] windy 数题目背景windy 定义了一种 windy 数。 题目描述不含前导零且相邻两个数字之差至少为 $2$ 的正整数被称为 windy 数。windy 想知道，在 $a$ 和 $b$ 之间，包括 $a$ 和 $b$ ，总共有多少个 windy 数？ 输入格式输入只有一行两个整数，分别表示 $a$ 和 $b$。 输出格式输出一行一个整数表示答案。 样例 #1样例输入 #111 10 样例输出 #119 样例 #2样例输入 #2125 50 样例输出 #2120 提示数据规模与约定对于全部的测试点，保证 $1 \\leq a \\leq b \\leq 2 \\times 10^9$。 分析： 经典数位dp的要素：求 $l$ 到 $r $之间的符合限制的数的个数（或求和），通常这个限制与数位有关。 首先，对于求 $l \\le x \\le r$ 的 $x$ 的个数，我们将其转化为求 $0 \\le x \\le r$ 的个数减去 $0 \\le x \\le l − 1$ 的个数。显然这两个$x$ 个数的求法是一样的， 因此接下来只需要考虑 $x \\le r$ 的求法。 梳理一下目前的限制：$\\le r$，没有前导 0，相邻数位差至少为 2。看起来限制有三个，较为复杂，但我们可以观察到一点，前两个限制都是按从高位到低位的顺序确定的，第三个限制从低位到高位和从高位到低位均可。 因此，我们考虑从高位到低位逐位进行 dp，在 dp 的过程中维护上述限制。 我们令 $f[i][j][lim][zero]$表示目前已经确定了前 $i$ 高的数位的值，最后一位（第 $i$ 高位）的值为 $j$。$lim$ 和 $zero$ 是两个布尔值， $lim &#x3D; 0$ 表示只考虑前 $i$ 位有 $x &lt; r$，$lim &#x3D; 1$ 表示前 $i$ 位 $x &#x3D; r$。 $zero &#x3D; 0$ 表示当前 $i$ 位中已有非 $0$ 元素，$zero &#x3D; 1$ 表示当前 $i $位全为 $0$。 这个状态的最后两位 $lim$ 和 $zero$ 对应了 $x \\le r $和没有前导 $0 $这两个限制。 在 dp 转移的时候，直接枚举下一位的值 $k$。 对于 $f[i][j][lim][zero]$， 如果 $zero ot &#x3D; 0$，则下一位与 $j$ 至少相差 $2$； 1if(!zero&amp;&amp;abs(j-k)&lt;2) continue; 如果 $lim &#x3D; 1$，则下一位需不超过 $r$ 的对应位。 1if(lim&amp;&amp;k&gt;a[i+1]) continue; //a[i] 表示 r 第 i 位的值 通过下一位的值可以得到新的 $lim’$ 和 $zero’$，因此可以进行 dp 转移。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;using namespace std;int l,r;int len;int f[20][20][3][3];//已填位数，当前数值，前几位是否为最大，是否有有效位int a[20];int dp(string r)&#123; int res=0; memset(a,0,sizeof a); len=r.length(); for(int i=0;i&lt;len;i++)&#123; a[i+1]=r[i]-&#x27;0&#x27;; &#125; memset(f,0,sizeof f); f[0][0][1][1]=1; for(int i=0;i&lt;len;i++)&#123; for(int j=0;j&lt;=9;j++)&#123; for(int lim=0;lim&lt;2;lim++)&#123; for(int zero=0;zero&lt;2;zero++)&#123; for(int k=0;k&lt;=9;k++)&#123; if(zero==0&amp;&amp;abs(k-j)&lt;2)continue; if(lim==1&amp;&amp;k&gt;a[i+1])break; f[i+1][k][lim&amp;&amp;k==a[i+1]][zero&amp;&amp;!k]+=f[i][j][lim][zero]; &#125; &#125; &#125; &#125; &#125; for(int j=0;j&lt;=9;j++)&#123; for(int lim=0;lim&lt;2;lim++)&#123; res+=f[len][j][lim][0]; &#125; &#125; return res;&#125;int main()&#123; cin &gt;&gt; l &gt;&gt; r; l--; string ls,rs; while(l)&#123; char ch=l%10+&#x27;0&#x27;; ls=ch+ls; l/=10; &#125; while(r)&#123; char ch=r%10+&#x27;0&#x27;; rs=ch+rs; r/=10; &#125; cout &lt;&lt; dp(rs)-dp(ls); return 0;&#125; 例题2：洛谷P4124 [CQOI2016] 手机号码 [CQOI2016] 手机号码题目描述人们选择手机号码时都希望号码好记、吉利。比如号码中含有几位相邻的相同数字、不含谐音不吉利的数字等。手机运营商在发行新号码时也会考虑这些因素，从号段中选取含有某些特征的号码单独出售。为了便于前期规划，运营商希望开发一个工具来自动统计号段中满足特征的号码数量。 工具需要检测的号码特征有两个：号码中要出现至少 $3$ 个相邻的相同数字；号码中不能同时出现 $8$ 和 $4$。号码必须同时包含两个特征才满足条件。满足条件的号码例如：13000988721、23333333333、14444101000。而不满足条件的号码例如：1015400080、10010012022。 手机号码一定是 $11$ 位数，且不含前导的 $0$。工具接收两个数 $L$ 和 $R$，自动统计出 $[L,R]$ 区间内所有满足条件的号码数量。$L$ 和 $R$ 也是 $11$ 位的手机号码。 输入格式输入文件内容只有一行，为空格分隔的 $2$ 个正整数 $L,R$。 输出格式输出文件内容只有一行，为 $1$ 个整数，表示满足条件的手机号数量。 样例 #1样例输入 #1112121284000 12121285550 样例输出 #115 提示样例解释：满足条件的号码： 12121285000、 12121285111、 12121285222、 12121285333、 12121285550。 数据范围：$10^{10}\\leq L\\leq R&lt;10^{11}$。 状态压缩dp状压 dp 是动态规划的一种，通过将状态压缩为整数来达到优化转移的目的。 例题1：洛谷P3052 [USACO12MAR] Cows in a Skyscraper G [USACO12MAR] Cows in a Skyscraper G题面翻译给出 $n$ 个物品，体积为 $w _ 1, w _ 2, \\cdots, w _ n$，现把其分成若干组，要求每组总体积小于等于 $W$，问最小分组数量。 $n\\le 18,1\\le c_i\\le W\\le 10^8$。 题目描述A little known fact about Bessie and friends is that they love stair climbing races. A better known fact is that cows really don’t like going down stairs. So after the cows finish racing to the top of their favorite skyscraper, they had a problem. Refusing to climb back down using the stairs, the cows are forced to use the elevator in order to get back to the ground floor. The elevator has a maximum weight capacity of W (1 &lt;&#x3D; W &lt;&#x3D; 100,000,000) pounds and cow i weighs C_i (1 &lt;&#x3D; C_i &lt;&#x3D; W) pounds. Please help Bessie figure out how to get all the N (1 &lt;&#x3D; N &lt;&#x3D; 18) of the cows to the ground floor using the least number of elevator rides. The sum of the weights of the cows on each elevator ride must be no larger than W. 输入格式* Line 1: N and W separated by a space. * Lines 2..1+N: Line i+1 contains the integer C_i, giving the weight of one of the cows. 输出格式* A single integer, R, indicating the minimum number of elevator rides needed. one of the R trips down the elevator. 样例 #1样例输入 #1123454 10 5 6 3 7 样例输出 #113 提示There are four cows weighing 5, 6, 3, and 7 pounds. The elevator has a maximum weight capacity of 10 pounds. We can put the cow weighing 3 on the same elevator as any other cow but the other three cows are too heavy to be combined. For the solution above, elevator ride 1 involves cow #1 and #3, elevator ride 2 involves cow #2, and elevator ride 3 involves cow #4. Several other solutions are possible for this input. 分析： 首先我们有一个最朴素的暴搜想法，就是每次枚举一个物品，如果它可以被加入当前组中就直接加入，否则另开一个新的组。 这个暴搜显然是无法通过 $n \\le 18$ 的，因此我们要找到这个问题中 “对答案贡献相同的情况”，然后想办法改用 dp 处理。 在这个问题中，我们可以发现，每一组的内部元素的加入顺序是无关的，组与组之间的顺序也是无关的。如果我们用搜索，则相当于枚举了所有可能的顺序，产生了极大的时间浪费。 因此，我们可以以此为突破口进行 dp，把物品的集合作为 dp 的状态，然后进行转移。 令 $f[S]$ 表示集合 $S$ 的物品至少要分成几组，$sum[S]$ 表示集合 $S$ 中所有物品的体积和。 在计算 $f[S]$ 时，我们枚举 $S$ 的一个非空子集 $T$，如果 $sum[T]&lt;&#x3D;W$，则可以令 $f[S] &#x3D; min(f[S], f[S \\setminus T] + 1)$。 （$S \\setminus T$ 表示从集合 $S$ 中去除集合 $T$ 后剩下的集合） 当我们要把一个集合作为 dp 的状态时，我们可以用一个二进制数来描述集合。 例如 $S$ 是一个 ${ 1, 2, . . . , n}$ 的一个子集，那么我们可以用一个 $[0, 2^n )$ 的整数 $st$ 来表示 $S$。$st$ 在二进制下从低到高的第 $i$ 位为 $1$ 表示 $S$ 中有 $i + 1$ 这个元素，为 $0$ 表示没有 $i + 1$ 这个元素。 在用二进制数表示集合后，我们可以用位运算来实现集合运算。我们设 $s$ 为表示集合 $S$ 的二进制数，$t$ 为表示集合 $T$ 的二进制数，则有： $S ∪ T$ 可以用 $s|t$ 表示 $ S ∩ T$ 可以用 $s&amp;t$ 表示 当 $T ⊂ S$ 时，$S \\setminus T$ 可以用 $s \\textasciicircum t$ 或者 $s-t$ 表示 $S$ 中是否有元素 $i$ 可以用 $(s&gt;&gt;i-1)&amp;1$ 表示 $T$ 是否为 $S$ 的子集可以用 $(s&amp;t)&#x3D;&#x3D;t$ 表示 $S$ 的补集可以用 $((1&lt;&lt;n)-1)\\textasciicircum s$ 表示（$n$ 为全集大小） 大量出现位运算时建议使用括号，避免因为运算符优先级问题浪费大量调试时间。 可以使用$__builtin_ctz(i)$计算后缀$0$，$__builtin_clz(i)$计算前缀$0$。 代码： 12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std;const int N=1&lt;&lt;18+5;int n,W;int f[N],sum[N];int w[20];int lowbit(int x)&#123; return x&amp;-x;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; W; for(int i=1;i&lt;=n;i++)&#123; cin &gt;&gt; w[i]; &#125; for(int i=1;i&lt;1&lt;&lt;n;i++)&#123; sum[i]=min(W+1,w[__builtin_ctz(i)+1]+sum[i-lowbit(i)]); &#125; for(int i=1;i&lt;1&lt;&lt;n;i++)&#123; f[i]=n+1; for(int j=1;j&lt;1&lt;&lt;n;j++)&#123; if((i&amp;j)!=j)continue; if(sum[j]&lt;=W)f[i]=min(f[i],f[i^j]+1); &#125; &#125; cout &lt;&lt; f[(1&lt;&lt;n)-1]; return 0;&#125; 时间复杂度$O(4^n)$，无法通过本题。 引理：令$S$为${1,2,\\cdots,n}$的一个子集，$T$为$S$的一个子集，则不同的$(S,T)$对的个数为$3^n$ 虽然需要枚举的 $S$ 和 $T$ 的总对数只有 $3^n$，但想要达到 $O(3^n)$ 的复杂度，还得确保代码中只枚举 $S$ 的子集。 代码： 123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;const int N=1&lt;&lt;18+5;int n,W;int f[N],sum[N];int w[20];int lowbit(int x)&#123; return x&amp;-x;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; W; for(int i=1;i&lt;=n;i++)&#123; cin &gt;&gt; w[i]; &#125; for(int i=1;i&lt;1&lt;&lt;n;i++)&#123; sum[i]=min(W+1,w[__builtin_ctz(i)+1]+sum[i-lowbit(i)]); &#125; for(int i=1;i&lt;1&lt;&lt;n;i++)&#123; f[i]=n+1; for(int j=i;j;--j&amp;=i)&#123; if(sum[j]&lt;=W)f[i]=min(f[i],f[i^j]+1); &#125; &#125; cout &lt;&lt; f[(1&lt;&lt;n)-1]; return 0;&#125; 为了获得更优的复杂度，我们可以每次加入一个物品而不是一组物品。 令 $f[S]$ 表示加入了 $S$ 中的所有物品后的最优情况，此处最优情况指最小组数，在最小组数前提下最后一组的当前大小。不难发现这个二元组是可以比较优劣的，优先比较最小组数，最小组数相同时最后一组的当前大小越小越优。 计算 $f[S]$ 时每次枚举一个 $S$ 中的元素 $i$，从 $f[S \\setminus {i}]$ 中转移即可。 例题2：洛谷P1879 [USACO06NOV] Corn Fields G [USACO06NOV] Corn Fields G题目描述Farmer John has purchased a lush new rectangular pasture composed of M by N (1 ≤ M ≤ 12, 1 ≤ N ≤ 12) square parcels. He wants to grow some yummy corn for the cows on a number of squares. Regrettably, some of the squares are infertile and can’t be planted. Canny FJ knows that the cows dislike eating close to each other, so when choosing which squares to plant, he avoids choosing squares that are adjacent; no two chosen squares share an edge. He has not yet made the final choice as to which squares to plant. Being a very open-minded man, Farmer John wants to consider all possible options for how to choose the squares for planting. He is so open-minded that he considers choosing no squares as a valid option! Please help Farmer John determine the number of ways he can choose the squares to plant. 农场主 $\\rm John$ 新买了一块长方形的新牧场，这块牧场被划分成 $M$ 行 $N$ 列 $(1 \\le M \\le 12, 1 \\le N \\le 12)$，每一格都是一块正方形的土地。 $\\rm John$ 打算在牧场上的某几格里种上美味的草，供他的奶牛们享用。 遗憾的是，有些土地相当贫瘠，不能用来种草。并且，奶牛们喜欢独占一块草地的感觉，于是 $\\rm John$ 不会选择两块相邻的土地，也就是说，没有哪两块草地有公共边。 $\\rm John$ 想知道，如果不考虑草地的总块数，那么，一共有多少种种植方案可供他选择？（当然，把新牧场完全荒废也是一种方案） 输入格式第一行：两个整数 $M$ 和 $N$，用空格隔开。 第 $2$ 到第 $M+1$ 行：每行包含 $N$ 个用空格隔开的整数，描述了每块土地的状态。第 $i+1$ 行描述了第 $i$ 行的土地，所有整数均为 $0$ 或 $1$ ，是 $1$ 的话，表示这块土地足够肥沃，$0$ 则表示这块土地不适合种草。 输出格式一个整数，即牧场分配总方案数除以 $100,000,000$ 的余数。 样例 #1样例输入 #11232 31 1 10 1 0 样例输出 #119 概率dp概率 dp 用于解决概率问题与期望问题。一般情况下，解决概率问题需要顺序循环，而解决期望问题使用逆序循环，如果定义的状态转移方程存在后效性问题，还需要用到高斯消元来优化。概率 dp 也会结合其他知识进行考察，例如状态压缩，树上进行dp转移等。 例题1：洛谷CF16E Fish&#x2F;Codeforces 16E Fish题面翻译题目描述 有n条鱼，编号从1到n，住在湖里。每天有一对鱼相遇， 彼此相遇的概率是一样的。如果两条标号为i和j的鱼见面，第一只吃了第二只的概率为$a_{i,j}$，第二只会吃了第一只的概率为$a_{j,i}$&#x3D;$1-a_{i,j}$。 所描述的过程继续进行，直到湖里只剩下一条鱼。请你算出每只鱼最后存活在湖里的可能性。 输入格式 第一行包含整数n( 1&lt;&#x3D;n&lt;&#x3D;18)–湖里的鱼数量。接下来n行为实数矩阵a，其中$a_{i,j}$代表相遇时第i条鱼吃掉第j条的概率。数据保证主对角线上只包含0，且$a_{j,i}$&#x3D;$1-a_{i,j}$。每个实数小数点后只有6位。 输出格式 输出n个六位小数，以空格隔开，其中第i个表示第i条鱼存活到最后的概率。 题目描述$ n $ fish, numbered from $ 1 $ to $ n $ , live in a lake. Every day right one pair of fish meet, and the probability of each other pair meeting is the same. If two fish with indexes i and j meet, the first will eat up the second with the probability $ a_{ij} $ , and the second will eat up the first with the probability $ a_{ji}&#x3D;1-a_{ij} $ . The described process goes on until there are at least two fish in the lake. For each fish find out the probability that it will survive to be the last in the lake. 输入格式The first line contains integer $ n $ ( $ 1&lt;&#x3D;n&lt;&#x3D;18 $ ) — the amount of fish in the lake. Then there follow $ n $ lines with $ n $ real numbers each — matrix $ a $ . $ a_{ij} $ ( $ 0&lt;&#x3D;a_{ij}&lt;&#x3D;1 $ ) — the probability that fish with index $ i $ eats up fish with index $ j $ . It’s guaranteed that the main diagonal contains zeros only, and for other elements the following is true: $ a_{ij}&#x3D;1-a_{ji} $ . All real numbers are given with not more than 6 characters after the decimal point. 输出格式Output $ n $ space-separated real numbers accurate to not less than 6 decimal places. Number with index $ i $ should be equal to the probability that fish with index $ i $ will survive to be the last in the lake. 样例 #1样例输入 #112320 0.50.5 0 样例输出 #110.500000 0.500000 样例 #2样例输入 #212345650 1 1 1 10 0 0.5 0.5 0.50 0.5 0 0.5 0.50 0.5 0.5 0 0.50 0.5 0.5 0.5 0 样例输出 #211.000000 0.000000 0.000000 0.000000 0.000000 分析； 本题可以状压dp。 令 $f[S]$ 表示目前只有集合 $S$ 中的鱼活着的情况的发生概率。对于 $i ∈ [1, n]$，都应有 $∑ _{|S|&#x3D;i} f[S] &#x3D; 1$。 初始状态是 $f[{1,2,…,n}]&#x3D;1$。 对于一个情况 $S$，我们可以直接枚举那天哪一对鱼发生了碰面，然后把这一天的概率转移到下一天上。 具体地，对于一个状态 $S$，设它的大小 $|S| &#x3D; m(m \\ge 2)$，我们可以枚举二元组 $(i, j)$，满足 $i &lt; j$ 且$ i, j ∈ S$，并进行转移：$$f[S\\setminus {i}]+&#x3D;\\frac{f[S]}{\\frac{m(m-1)}{2}}\\times a_{j,i},f[s\\setminus {j}]+&#x3D;\\frac{f[S]}{\\frac{m(m-1)}{2}}\\times a_{i,j}$$代码： 12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;const int N=1&lt;&lt;18;int n;double f[N];double a[20][20];int main()&#123; cin &gt;&gt; n; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; cin &gt;&gt; a[i][j]; &#125; &#125; f[(1&lt;&lt;n)-1]=1; for(int i=(1&lt;&lt;n)-1;i&gt;=1;i--)&#123; int t=__builtin_popcount(i); if(t==1)continue; for(int j=1;j&lt;=n;j++)&#123; if((i&amp;(1&lt;&lt;j-1))==0)continue; for(int k=j+1;k&lt;=n;k++)&#123; if((i&amp;(1&lt;&lt;k-1))==0)continue; double p=f[i]/(t*(t-1)/2.0); f[i-(1&lt;&lt;j-1)]+=p*a[k][j]; f[i-(1&lt;&lt;k-1)]+=p*a[j][k]; &#125; &#125; &#125; for(int i=1;i&lt;=n;i++)&#123; cout &lt;&lt; fixed &lt;&lt; setprecision(6) &lt;&lt; f[1&lt;&lt;i-1] &lt;&lt; &#x27; &#x27;; &#125; return 0;&#125; 例题2：洛谷P5249 [LnOI2019] 加特林轮盘赌 [LnOI2019] 加特林轮盘赌题目背景加特林轮盘赌是一个养生游戏。 题目描述与俄罗斯轮盘赌等手枪的赌博不同的是，加特林轮盘赌的赌具是加特林。 加特林轮盘赌的规则很简单：在加特林的部分弹夹中填充子弹。游戏的参加者坐在一个圆桌上，轮流把加特林对着自己的头，扣动扳机一秒钟。中枪的自动退出，坚持到最后的就是胜利者。 我们使用的是 2019 年最新技术的加特林，他的特点是无需预热、子弹无限，每一个人，在每一回合，中枪的概率是完全相同的 $P_0$。 每局游戏共有 $n$ 只长脖子鹿，从 1 长脖子鹿开始，按照编号顺序从小到大进行游戏，绕着圆桌不断循环。 游戏可能会循环进行多轮，直到场上仅剩下最后一只长脖子鹿时，游戏结束。 给出 $P_0$ 和 $n$，询问 $k$ 号长脖子鹿最终成为唯一幸存者的概率 $P_k$。 如果 $P_0&#x3D;0$，我们认为胜者为 $1$ 号。 输入格式仅一行三个数，$P_0,n,k$。 输出格式一个浮点数 $P_{k}$，误差应该小于 $10^{-8}$。（请保留更多位数的小数） 样例 #1样例输入 #110.5 2 1 样例输出 #110.33333333 样例 #2样例输入 #210.5 2 2 样例输出 #210.66666667 样例 #3样例输入 #310.5 3 1 样例输出 #310.23809524 样例 #4样例输入 #410.5 3 2 样例输出 #410.28571429 提示 对于 $10%$ 的数据，$n \\le 100$。 对于 $30%$ 的数据，$n \\le 500$。 对于另外 $20%$ 的数据，$k &#x3D; n$。 对于 $100%$ 的数据，$1 \\le k \\le n \\le 10^{4}, 0 \\le P_0 \\le 1$。 所有数据的时间限制为 1000ms，空间限制为256MB，可开启 O2 优化。 前缀和优化前缀和优化，一般用于组合计数类DP。 在DP的过程中，每次的转移对象是一段区间的求和，故可以采用前缀和来快速求和。 例题：洛谷P2513 [HAOI2009] 逆序对数列 [HAOI2009] 逆序对数列题目描述对于一个数列 ${a_i}$，如果有 $i&lt;j$ 且 $a_i&gt;a_j$，那么我们称 $a_i$ 与 $a_j$ 为一对逆序对数。若对于任意一个由 $1 \\sim n$ 自然数组成的数列，可以很容易求出有多少个逆序对数。那么逆序对数为 $k$ 的这样自然数数列到底有多少个？ 输入格式第一行为两个整数n，k。 输出格式写入一个整数，表示符合条件的数列个数，由于这个数可能很大，你只需输出该数对10000求余数后的结果。 样例 #1样例输入 #114 1 样例输出 #113 提示样例说明： 下列3个数列逆序对数都为1；分别是1 2 4 3 ；1 3 2 4 ；2 1 3 4； 测试数据范围 30%的数据 n&lt;&#x3D;12 100%的数据 n&lt;&#x3D;1000，k&lt;&#x3D;1000 分析： 考虑从小往大把1到n插入序列中。 放入元素i时，根据插入的位置可以产生$0\\sim i-1$个逆序对。 用$f[i][j]$表示前i个数产生j个逆序对的方案数，转移方程为$$f[i][j]&#x3D;\\sum_{k&#x3D;j-i+1}^j f[i-1][k]$$对$f[i][j]$记录前缀和即可$O(1)$转移。 代码： 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;const int N=1005,p=10000;int n,k;long long f[N][N];int main()&#123; cin &gt;&gt; n &gt;&gt; k; f[1][0]=1; for(int i=2;i&lt;=n;i++)&#123; long long sum=0; for(int j=0;j&lt;=k;j++)&#123; sum+=f[i-1][j]; sum%=p; f[i][j]=sum; if(j-i+1&gt;=0)&#123; sum-=f[i-1][j-i+1]; sum%=p; sum+=p; sum%=p; &#125; &#125; &#125; cout &lt;&lt; f[n][k]%p &lt;&lt; endl; return 0;&#125; 数据结构优化前缀和仅适用于按照下标顺序进行转移的计数类动态规划问题。 而面对转移仍然是一个区间&#x2F;矩形&#x2F;树上，但是是最优化问题，或者不是按照顺序转移，则无法用前缀和优化，这个时候可以借助一些常用的数据结构，如树状数组，线段树等。 例题1：洛谷P4644 [USACO05DEC] Cleaning Shifts S [USACO05DEC] Cleaning Shifts S题目描述约翰的奶牛们从小娇生惯养，她们无法容忍牛棚里的任何脏东西。约翰发现，如果要使这群有洁癖的奶牛满意，他不得不雇佣她们中的一些来清扫牛棚，约翰的奶牛中有 $ N(1 \\leq N \\leq 10000) $ 头愿意通过清扫牛棚来挣一些零花钱。 由于在某个时段中奶牛们会在牛棚里随时随地地乱扔垃圾，自然地，她们要求在这段时间里，无论什么时候至少要有一头奶牛正在打扫。需要打扫的时段从某一天的第 $ M $ 秒开始，到第 $ E $ 秒结束 $ (0 \\leq M \\leq E \\leq 86399) $。注意这里的秒是指时间段而不是时间点，也就是说，每天需要打扫的总时间是 $ E-M+1 $ 秒。 约翰已经从每头牛那里得到了她们愿意接受的工作计划：对于某一头牛，她每天都愿意在笫 $ T_1 \\ldots T_2 $ 秒的时间段内工作 $ (M \\leq T_1 \\leq T_2 \\leq E) $ ，所要求的报酬是 $ S $ 美元 $ (0 \\leq S \\leq 500000) $。与需打扫时段的描述一样，如果一头奶牛愿意工作的时段是每天的第 $ 10 \\ldots 20 $ 秒，那她总共工作的时间是 $ 11 $ 秒，而不是 $ 10 $ 秒。 约翰一旦决定雇佣某一头奶牛，就必须付给她全额的工资，而不能只让她工作一段时间，然后再按这段时间在她愿意工作的总时间中所占的百分比来决定她的工资。现在请你帮约翰决定该雇佣哪些奶牛以保持牛棚的清洁，当然，在能让奶牛们满意的前提下，约翰希望使总花费尽量小。 输入格式第 $ 1 $ 行： $ 3 $ 个正整数 $ N,M,E $ 。 第 $ 2 $ 到 $ N+1 $ 行：第 $ i+1 $ 行给出了编号为 $ i $ 的奶牛的工作计划，即 $ 3 $ 个正整数 $ T_1,T_2,S $ 。 输出格式输出一个整数，表示约翰需要为牛棚清理工作支付的最少费用。如果清理工作不可能完成，那么输出 $ -1 $ 。 样例 #1样例输入 #112343 0 40 2 33 4 20 0 1 样例输出 #115 提示约翰有 $ 3 $ 头牛，牛棚在第 $ 0 $ 秒到第 $ 4 $ 秒之间需要打扫。 约翰雇佣前两头牛清扫牛棚，可以只花 $ 5 $ 美元就完成一整天的清扫。 分析： 用$f[i]$表示按照从左到右的顺序选择了第$i$个区间，保证当前已经覆盖了$[L,b_i]$的所有数。 转移：$$f[i]&#x3D;\\min_{a_i&lt;b_j&lt;b_i}(f[j])+c_i$$标称了一个单点修改，区间查询最小值的问题，采用树状数组优化即可。 例题2：洛谷P3287 [SCOI2014] 方伯伯的玉米田 [SCOI2014] 方伯伯的玉米田题目描述方伯伯在自己的农田边散步，他突然发现田里的一排玉米非常的不美。这排玉米一共有 $N$ 株，它们的高度参差不齐。方伯伯认为单调不下降序列很美，所以他决定先把一些玉米拔高，再把破坏美感的玉米拔除掉，使得剩下的玉米的高度构成一个单调不下降序列。方伯伯可以选择一个区间，把这个区间的玉米全部拔高 $1$ 单位高度，他可以进行最多 $K$ 次这样的操作。拔玉米则可以随意选择一个集合的玉米拔掉。问能最多剩多少株玉米，来构成一排美丽的玉米。 输入格式第一行包含两个整数 $n, K$，分别表示这排玉米的数目以及最多可进行多少次操作。第二行包含 $n$ 个整数，第 $i$ 个数表示这排玉米，从左到右第 $i$ 株玉米的高度 $a_i$。 输出格式输出一个整数，最多剩下的玉米数。 样例 #1样例输入 #1123 12 1 3 样例输出 #113 提示$100%$ 的数据满足：$2 \\le N \\lt 10^4 $，$2 \\le K \\le 500$，$1 \\leq a_i \\leq 5000$。 分析： 显然，只有每次操作都是后缀时，操作才最优。 用$F[i][j]$表示第$i$个数被进行了$j$次$+1$，以$i$结尾的最长上升子序列长度，则$$F[i][j]&#x3D;\\max_{k&lt;i,0\\le l \\le j,h[i]+j \\ge h[k]+l}(F[k][l])+1$$按照$i$的顺序，剩下的是一个二维偏序，可以用二维树状数组进行维护。 例题3：洛谷P9871 [NOIP2023] 天天爱打卡 [NOIP2023] 天天爱打卡题目描述小 T 同学非常热衷于跑步。为了让跑步更加有趣，他决定制作一款叫做《天天爱打卡》的软件，使得用户每天都可以进行跑步打卡。 开发完成后，小 T 同学计划进行试运行，他找了大 Y 同学来帮忙。试运行共 $n$ 天，编号为从 $1$ 到 $n$。 对大 Y 同学来说，如果某天他选择跑步打卡，那么他的能量值会减少 $d$。初始时，他的能量值是 $0$，并且试运行期间他的能量值可以是负数。 而且大 Y 不会连续跑步打卡超过 $k$ 天；即不能存在 $1\\le x\\le n-k$，使得他在第 $x$ 到第 $x+k$ 天均进行了跑步打卡。 小 T 同学在软件中设计了 $m$ 个挑战，第 $i$（$1\\le i \\le m$）个挑战可以用三个正整数 $(x_i,y_i,v_i)$ 描述，表示如果在第 $x_i$ 天时，用户已经连续跑步打卡至少 $y_i$ 天（即第 $x_i-y_i+1$ 到第 $x_i$ 天均完成了跑步打卡），那么小 T 同学就会请用户吃饭，从而使用户的能量值提高 $v_i$。 现在大 Y 想知道，在软件试运行的 $n$ 天结束后，他的能量值最高可以达到多少？ 输入格式本题的测试点包含有多组测试数据。 输入的第一行包含两个整数 $c$ 和 $t$，分别表示测试点编号和测试数据组数。对于样例，$c$ 表示该样例与测试点 $c$ 拥有相同的限制条件。 接下来，对于每组测试数据： 输入的第一行包含四个正整数 $n,m,k,d$，分别表示试运行的天数、挑战的个数、大 Y 单次跑步打卡的连续天数限制以及大 Y 跑步打卡减少的能量值。 接下来 $m$ 行，每行包含三个正整数 $x_i,y_i,v_i$，表示一次挑战。 输出格式输出一行一个整数表示对应的答案。 样例 #1样例输入 #112341 13 2 2 12 2 43 2 3 样例输出 #112 提示【样例解释 #1】 在第 $1,2$ 天跑步打卡，第 $3$ 天不跑步打卡，最终会获得 $(-1)+(-1)+4&#x3D;2$ 的能量值。 【样例解释 #2】 该组样例满足测试点 $3$ 的条件。 【样例解释 #3】 该组样例满足测试点 $5$ 的条件。 【样例解释 #4】 该组样例满足测试点 $15$ 的条件。 【样例解释 #5】 该组样例满足测试点 $17$ 的条件。 【样例解释 #6】 该组样例满足测试点 $19$ 的条件。 【数据范围】 记 $l_i&#x3D;x_i-y_i+1$，$r_i&#x3D;x_i$； 对于所有测试数据，保证：$1\\le t\\le 10$，$1\\le k\\le n\\le 10^9$，$1\\le m\\le 10^5$，$1\\le l_i\\le r_i\\le n$，$1\\le d,v_i\\le 10^9$。 测试点编号 $n \\le$ $m \\le$ 特殊性质 $1, 2$ $18$ $10 ^ 2$ 无 $3, 4$ $10 ^ 2$ $10 ^ 2$ 无 $5 \\sim 7$ $10 ^ 3$ $10 ^ 3$ 无 $8, 9$ $10 ^ 3$ $10 ^ 5$ 无 $10, 11$ $10 ^ 5$ $10 ^ 3$ 无 $12 \\sim 14$ $10 ^ 5$ $10 ^ 5$ 无 $15, 16$ $10 ^ 9$ $10 ^ 5$ A $17, 18$ $10 ^ 9$ $10 ^ 5$ B $19 \\sim 21$ $10 ^ 9$ $10 ^ 5$ C $22 \\sim 25$ $10 ^ 9$ $10 ^ 5$ 无 特殊性质 A：$k\\le 10^2$； 特殊性质 B：$\\forall 1\\le i&lt;m$，$r_i&lt;l_{i+1}$； 特殊性质 C：$\\forall 1\\le i&lt;j\\le m$，$l_i&lt;l_j$，$r_i&lt;r_j$。 分析：因为本题要求$1$必须连续才有贡献，跨过$0$的区间没有贡献，因此可以进行如下的dp设计： 用$f_i$表示第$i$天不跑步的情况下最大贡献，注意到状态无后向性，因此从前向后处理不会产生之前的某一天对当前天有影响，因此，可以写出状态转移：$$f_i&#x3D;\\max_{i-k-1 \\le j \\le i-1}f_j-val(j,i)-d \\times (i-j-1)$$其中$val(j,i)$表示$i \\sim j$中如果全部跑步，能产生多少贡献，期望得分$36pts$。 注意到对于某个挑战$(l,r,w)$，如果我们在计算$f_r$后，将$l-1$以前的所有$f_i$加上$w$，就可以消除$val(i,j)$的影响，因为在之后的转移中，我们在从$f_{i-1}$及之前的位置转移时，一定会钦定$l \\sim r$全部为$1$，从而产生了$w$的贡献。 对于$d \\times (i-j-1)$一项，我们只需将其拆开，变为 不妨另$g_i&#x3D;f_i+i \\times d$，我们的转移式就变为$$g_i&#x3D;\\max_{i-k-1 \\le j \\le i-1}g_j-val(j,i)+d$$"},{"title":"前缀和","path":"/2024/07/25/前缀和/","content":"前缀和作用：快速求区间和 公式:$s[i]&#x3D;s[i-1]+a[i]$,其中$s[i]$表示前$i$项的和 例：给定一个$n$项的数列$a$，共$m$次询问，每次询问给出两个数$l,r$，求区间$[l,r]$的和 分析：区间$[l,r]$的和即为前$r$项的和减去前$l-1$项的和，即$s[r]-s[l-1]$ 1234567891011121314151617181920#include&lt;bits/stdc++.h&gt;using namespace std;const int N=1e5+5;int n,m;int s[N];int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i=1;i&lt;=n;i++)&#123; cin &gt;&gt; s[i]; s[i]+=s[i-1]; &#125; for(int i=1;i&lt;=m;i++)&#123; int l,r; cin &gt;&gt; l &gt;&gt; r; cout &lt;&lt; s[r]-s[l-1] &lt;&lt; endl; &#125; return 0;&#125; 二维前缀和用$s[i][j]$表示前$i$行每行的前$j$个数之和 $s[i][j]&#x3D;s[i-1][j]+s[i][j-1]-s[i-1][j-1]+a[i][j]$ 例：给定一个$n*n$的矩阵，求最大子矩阵和 分析：左上角为$(x_1,y_1)$,右下角为$(x_2,y_2)$的矩阵和为$s[x_2][y_2]-s[x_1-1][y_2]-s[x_2][y_1-1]+s[x_1-1][y_1-1]$ 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;const int N=105;int n;int s[N][N];int ans=-1e9;int sum(int a,int b,int c,int d)&#123; return s[c][d]-s[a-1][d]-s[c][b-1]+s[a-1][b-1];&#125;int main()&#123; cin &gt;&gt; n; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; cin &gt;&gt; s[i][j]; s[i][j]+=s[i-1][j]+s[i][j-1]-s[i-1][j-1]; &#125; &#125; for(int x_1=1;x_1&lt;=n;x_1++)&#123; for(int y_1=1;y_1&lt;=n;y_1++)&#123; for(int x_2=x_1;x_2&lt;=n;x_2++)&#123; for(int y_2=y_1;y_2&lt;=n;y_2++)&#123; ans=max(ans,sum(x_1,y_1,x_2,y_2)); &#125; &#125; &#125; &#125; cout &lt;&lt; ans; return 0;&#125;"},{"title":"凸包","path":"/2024/07/25/凸包/","content":"凸包在平面上能包含所有给定点的最小凸多边形叫做凸包。可以理解为用一个橡皮筋围住所有给定点的形态。 凸包是周长最小的能围住所有点的凸多边形。 Andrew 算法 将点排序 x 为第一关键字，y 为第二关键字 从左向右维护可以得到凸包的上半部分（上凸包），从右向左可以得到凸包的下半部分（下凸包），可以发现，若下一个点在当前边的左侧，则这条边在凸包上，删去，否则保留这条边，然后就可以得到凸包。使用叉积判断下一个点的位置 注意排序，去重 洛谷 P2742 [USACO5.1] 圈奶牛Fencing the Cows &#x2F;【模板】二维凸包&#x2F;AcWing 1401. 围住奶牛 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;bits/stdc++.h&gt;using namespace std;const int N=1e5+5;struct Point&#123; double x,y; Point(double a=0,double b=0)&#123; x=a,y=b; &#125; Point operator + (const Point a)const&#123; return Point(x+a.x,y+a.y); &#125; Point operator - (const Point a)const&#123; return Point(x-a.x,y-a.y); &#125; Point operator * (const int a)const&#123; return Point(x*a,y*a); &#125; double operator * (const Point a)const&#123; return x*a.x+y*a.y; &#125; friend double cross(Point a,Point b)&#123; return a.x*b.y-a.y*b.x; &#125; bool operator &lt; (const Point a)const&#123; return (x==a.x)?y&lt;a.y:x&lt;a.x; &#125; bool operator &gt; (const Point a)const&#123; return (x==a.x)?y&gt;a.y:x&gt;a.x; &#125; bool operator == (const Point a)const&#123; return x==a.x&amp;&amp;y==a.y; &#125; friend double area(Point a,Point b,Point c)&#123; return cross(b-a,c-a); &#125; friend double get_dist(Point a,Point b)&#123; return sqrt((b-a)*(b-a)); &#125;&#125;q[N];int n;int stk[N],top;double andrew()&#123; sort(q,q+n); n=unique(q,q+n)-q; top=0; for(int i=0;i&lt;n;i++)&#123; while(top&gt;=2&amp;&amp;area(q[stk[top-1]],q[stk[top]],q[i])&gt;=0)&#123; top--; &#125; stk[++top]=i; &#125; for(int i=n-1;i&gt;=0;i--)&#123; if(q[stk[top]]==q[i])continue;//不考虑重复点 while(top&gt;=2&amp;&amp;area(q[stk[top-1]],q[stk[top]],q[i])&gt;0)&#123; top--; &#125; stk[++top]=i; &#125; double res=0; for(int i=2;i&lt;=top;i++)&#123; res+=get_dist(q[stk[i-1]],q[stk[i]]); &#125; return res;&#125;int main()&#123; cin &gt;&gt; n; for(int i=0;i&lt;n;i++)&#123; cin &gt;&gt; q[i].x &gt;&gt; q[i].y; &#125; double res=andrew(); cout &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; res; return 0;&#125;"},{"title":"位运算","path":"/2024/07/25/位运算/","content":"位运算常用操作： $n*2^k$ :n&lt;&lt;k $n&#x2F;2^k$:n&gt;&gt;k $2^k$:1&lt;&lt;k $n$在二进制下最后一位的数（奇偶）:n&amp;1 $n$在二进制下的第$k$位： 先把第$k$位移到末尾:n&gt;&gt;k 再判断当前位的数值:n&amp;1 合起来:n&gt;&gt;k&amp;1 $lowbit$ : $lowbit(x)$：返回$x$的最后一位$1$ 实现：x&amp;-x 原理：$-x&#x3D;\\sim x+1$ （$\\textasciitilde$表示取反）, 设$x$的第$k$位是$1$,则$\\sim x$的$1\\thicksim k-1$位都是$1$,第$k$位是$0$,加$1$后产生进位，使第$1\\thicksim k-1$都变为$0$,第$k$位是$1$。因为加$1$后不会影响$k$位以上，所以$k$位以上都与原数相反,进行$&amp;$操作后都为$0$,第$1\\thicksim k-1$也为$0$,所以只有第$k$位是$1$。 例：$x&#x3D;100&#x3D;(1100100)_2$ ​ $\\sim x&#x3D;(0011011)_2$ ​ $-x&#x3D;\\sim x+1&#x3D;(0011100)_2$ ​ $x&amp;-x&#x3D;(0000100)_2$ 例题：求$n$个数$x$的二进制中$1$的个数 分析：当$x$不为零时，每次减去$x$的最后一位$1$，统计次数 12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;using namespace std;int n;int lowbit(int x)&#123; return x&amp;-x;&#125;int main()&#123; cin &gt;&gt; n; while(n--)&#123; int x,ans=0; cin &gt;&gt; x; while(x)&#123; ans++; x-=lowbit(x); &#125; cout &lt;&lt; ans &lt;&lt; &#x27; &#x27;; &#125; return 0;&#125; 应用：树状数组 原码、反码、补码 反码$&#x3D;$原码取反 补码$&#x3D;$反码$+1$ 例：$x&#x3D;100$ 原码：00...001100100 反码：11...110011011 补码：11...110011100"},{"title":"二分图","path":"/2024/07/25/二分图/","content":"二分图 二分图：当一个图的顶点可以被分为两个集合，且任意一条边的两个端点属于不同集合时为二分图 即：相邻两个点位于不同集合内 一个图是二分图当且仅当图中不含有奇数环（长度为奇数的环） 染色法可以把二分图看作染色 用途：判断二分图 做法：循环，若一个点未被染色，用$DFS$染色，若冲突，则不是二分图 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;using namespace std;const int N=1e5+5,M=1e5+5;int h[N],ne[2*M],to[2*M];int cnt;void addedge(int u,int v)&#123; ne[++cnt]=h[u]; to[cnt]=v; h[u]=cnt;&#125;int n,m;int color[N];bool dfs(int now,int col)&#123; color[now]=col; for(int i=h[now];i;i=ne[i])&#123; if(!color[to[i]])&#123; if(!dfs(to[i],3-col))return 0;//3-col:将1-&gt;2,2-&gt;1,注意这里也要判断 &#125; if(color[to[i]]==color[now])return 0; &#125; return 1;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i=1;i&lt;=m;i++)&#123; int u,v; cin &gt;&gt; u &gt;&gt; v; addedge(u,v); addedge(v,u); &#125; bool flag=1; for(int i=1;i&lt;=n;i++)&#123; if(!color[i])&#123; if(!dfs(i,1))&#123; flag=0; break; &#125; &#125; &#125; if(flag)&#123; cout &lt;&lt; &quot;Yes&quot;; &#125; else&#123; cout &lt;&lt; &quot;No&quot;; &#125; return 0;&#125; 匈牙利算法作用：求二分图的最大匹配 二分图的匹配：给定一个二分图 $G$，在 $G$ 的一个子图 $M$ 中，$M$ 的边集 ${E}$ 中的任意两条边都不依附于同一个顶点，则称 $M$ 是一个匹配。 二分图的最大匹配：所有匹配中包含边数最多的一组匹配被称为二分图的最大匹配，其边数即为最大匹配数。 思路： 循环左侧的每一个点，从头匹配，若当前边的终点未被考虑过，若这个点未被匹配或已经被匹配的对应点可以匹配另外一个，则当前点匹配终点。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;using namespace std;const int N=505,M=1e5+5;int nl[N],nr[N];int h[N],ne[M],to[M];int cnt;void addedge(int u,int v)&#123; ne[++cnt]=h[u]; to[cnt]=v; h[u]=cnt;&#125;int n1,n2,m;bool st[N];int match[N];bool find(int x)&#123; for(int i=h[x];i;i=ne[i])&#123; if(!st[to[i]])&#123; st[to[i]]=1; if(match[to[i]]==0||find(match[to[i]]))&#123; match[to[i]]=x; return 1; &#125; &#125; &#125; return 0;&#125;int main()&#123; cin &gt;&gt; n1 &gt;&gt; n2 &gt;&gt; m; for(int i=1;i&lt;=m;i++)&#123; int u,v; cin &gt;&gt; u &gt;&gt; v; addedge(u,v); &#125; int ans=0; for(int i=1;i&lt;=n1;i++)&#123; memset(st,0,sizeof st); if(find(i))ans++; &#125; cout &lt;&lt; ans; return 0;&#125;"},{"title":"Trie","path":"/2024/07/25/Trie/","content":"Trie作用：高效地存储和查找字符串集合的数据结构 例：存储abcdef,abdef,aced,bcdf,bcff,cdaa,bcdc 存储：用$trie$数组记录节点，第一维为节点编号，大小为字符串总长度，第二维记录当前节点的对应字符的子节点，大小为字符种类数，$cnt$数组记录每个节点对应的单词数量，$idx$记录当前已使用节点数。 1int trie[N][30],cnt[N],idx; 插入： 判断当前节点的子节点是否包含当前字母，若不包含，新建一个节点，跳到下一节点 当遍历到当前单词最后一个字符时，标记当前节点，表示当前节点有一个单词 12345678void insert(string s)&#123; int p=0,len=s.length()-1; for(int i=0;i&lt;=len;i++)&#123; if(!trie[p][s[i]-&#x27;a&#x27;])trie[p][s[i]-&#x27;a&#x27;]=++idx; p=trie[p][s[i]-&#x27;a&#x27;]; &#125; cnt[p]++;&#125; 查找： 判断当前节点的子节点是否包含当前字母，若不包含，说明没有该单词，返回$0$，否则跳到下一节点 当遍历到当前单词最后一个字符时，返回当前节点的$cnt$，表示当前节点的单词数量。 12345678int find(string s)&#123; int p=0,len=s.length()-1; for(int i=0;i&lt;=len;i++)&#123; if(!trie[p][s[i]-&#x27;a&#x27;])return 0; p=trie[p][s[i]-&#x27;a&#x27;]; &#125; return cnt[p];&#125;"},{"title":"KMP","path":"/2024/07/25/KMP/","content":"KMP作用：字符串匹配 例：给定一个$m$位字符串$s$，一个$n$位模式串$p$，求出$p$在$s$中所有出现的位置的起始下标 分析： 暴力算法： 1234567891011char s[N],p[N];for(int i=1;i&lt;=m;i++)&#123; bool flag=true; for(int j=1;j&lt;=n;j++)&#123; if(s[i+j-1]!=p[i])&#123; flag=false; break; &#125; &#125;&#125; 考虑优化： 使用$ne[j]$记录$p$中$[1,j]$的前缀和后缀的最大相同长度，即$p$中$p[1,ne[j]]&#x3D;p[j-ne[j]+1,j]$ $ne[j]$用于求若匹配失败则最少往后移动多少可以成功匹配。 用$j$表示模式串$p$已经有几位匹配成功，若$p[j]{&#x3D;}\\mathllap{&#x2F;,}s[i+1]$，则表示当前位不匹配，此时把$p$向后移动$ne[j]$位即可保证$p[1\\thicksim j-1]$再次匹配。 如上图，若在绿线之前均匹配，绿线之后不匹配，则最少把$p$向后移动$ne[j]$位至第二条线，此时三条黑线均相等。 由此，可以想到KMP的匹配： 若$j$没有退回起点且当前的$s[i]{&#x3D;}\\mathllap{&#x2F;,}p[j+1]$，则把模式串向后移$ne[j]$位，此时的$j&#x3D;ne[j]$，重复直至$s[i]&#x3D;p[j+1]$ 此时因为$s[i]&#x3D;p[j+1]$，所以$p$中匹配的个数由$j$变成$j+1$，所以$j++$ 若$j&#x3D;n$，即模式串$p$完全匹配，则输出答案继续下一轮匹配($j&#x3D;ne[j]$) 12345678for(int i=1,j=0;i&lt;=m;i++)&#123; while(j&amp;&amp;s[i]!=p[j+1])j=ne[j]; if(s[i]==p[j+1])j++; if(j==n)&#123; cout &lt;&lt; i-n+1 &lt;&lt; &#x27; &#x27;; j=ne[j]; &#125;&#125; $ne$数组求法：例：$p&#x3D;$”$abcab$” $p$ $a$ $b$ $c$ $a$ $b$ 下标 $1$ $2$ $3$ $4$ $5$ $ne[]$ $0$ $0$ $0$ $1$ $2$ $ne[1]$：前缀&#x3D;$\\phi$，后缀&#x3D;$\\phi$，$ne[1]&#x3D;0$ $ne[2]$：前缀&#x3D;${a}$，后缀&#x3D;${b}$，$ne[2]&#x3D;0$ $ne[3]$：前缀&#x3D;${a,ab}$，后缀&#x3D;${c,bc}$，$ne[3]&#x3D;0$ $ne[4]$：前缀&#x3D;${a,ab,abc}$，后缀&#x3D;${a,ca,bca}$，$ne[4]&#x3D;1$ $ne[5]$：前缀&#x3D;${a,ab,abc,abca}$，后缀&#x3D;${b,ab,cab,bcab}$，$ne[5]&#x3D;2$ 具体方法：类似KMP的匹配 当$p[1\\thicksim j]&#x3D;p[j-ne[i-1]+1,j]$，且$p[i]{&#x3D;}\\mathllap{&#x2F;,}p[j+1]$时，模式串$p$一直向后移（$j&#x3D;ne[j]$）直至$p[i]&#x3D;p[j+1]$，此时表示$[1,i]$的前后缀的相同最大长度为$j+1$，即$ne[i]&#x3D;j+1$ 步骤： 若$j$没有退回起点且当前的$s[i]{&#x3D;}\\mathllap{&#x2F;,}p[j+1]$，则把模式串向后移$ne[j]$位，此时的$j&#x3D;ne[j]$，重复直至$s[i]&#x3D;p[j+1]$ 此时因为$s[i]&#x3D;p[j+1]$，所以$p$中匹配的个数由$j$变成$j+1$，所以$j++$ 则$ne[i]&#x3D;j$ 12345for(int i=2,j=0;i&lt;=n;i++)&#123; while(j&amp;&amp;p[i]!=p[j+1])j=ne[j]; if(p[i]==p[j+1])j++; ne[i]=j;&#125; 总体代码: 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;const int N=1e4+5,M=1e5+5;int n,m;char s[M],p[N];int ne[N];int main()&#123; cin &gt;&gt; n &gt;&gt; p+1 &gt;&gt; m &gt;&gt; s+1; //求next for(int i=2,j=0;i&lt;=n;i++)&#123; while(j&amp;&amp;p[i]!=p[j+1])j=ne[j]; if(p[i]==p[j+1])j++; ne[i]=j; &#125; //kmp匹配 for(int i=1,j=0;i&lt;=m;i++)&#123; while(j&amp;&amp;s[i]!=p[j+1])j=ne[j]; if(s[i]==p[j+1])j++; if(j==n)&#123; cout &lt;&lt; i-n+1 &lt;&lt; &#x27; &#x27;; j=ne[j]; &#125; &#125; return 0;&#125;"},{"title":"dp技巧总结","path":"/2024/07/25/dp技巧总结/","content":"dp 技巧总结P1020 [NOIP1999 提高组] 导弹拦截以最长不下降子序列为例，时间复杂度为 $O(n \\log n)$ 的一种算法： 记录每个长度的最长不下降子序列的结尾的最小值，可以发现有单调性，因此对于每个数二分查找可以接在哪一段后，更新即可。 12345678910for(int i=1;i&lt;=n;i++)&#123; int l=0,r=len; while(l&lt;r)&#123; int mid=l+r+1&gt;&gt;1; if(d[mid]&gt;=a[i])l=mid;//如求上升/下降/不上升/公共，修改二分条件 else r=mid-1; &#125; len=max(len,l+1); d[l+1]=a[i];&#125; Dilworth 定理 把序列划分成不下降子序列最少个数等于最长下降子序列长度 即有限偏序集中，最小链划分的个数等于最长反链长度 P1280 尼克的任务如果一个状态受后面某些状态的影响，但不受前面状态的影响，可以逆序dp P1439 【模板】最长公共子序列朴素算法：d[i][j] 表示 A 中前 i 个元素，B 中前 j 个元素构成的最长公共子序列，易得出 a[i]==b[j] 时 d[i][j]=max(d[i][j],d[i-1][j-1]+1) 优化：由于A,B都是 1到n的排列，可以把A中的元素重新编号，变为 1,2,…,n，这样只需要在新的 B 中找到最长上升子序列即可。 P4301 绝世好题出现位运算考虑是否可以按位dp优化时间复杂度 令dp[i]表示数列到目前为止最后一项第i位为1的最大子序列长度，每读入一个数时就转移。一个数可以被它所有的二进制位的dp值转移，然后把它转移到它的所有二进制位的dp值上。 P2516 [HAOI2010] 最长公共子序列空间不够用滚动数组 背包问题背包九讲 P1941 [NOIP2014 提高组] 飞扬的小鸟首先，原始的转移方程：$$f[i][j]&#x3D;min(f[i-1][j+y[i]],f[i-1][j-x[i]]+1,f[i-1][j-2 \\times x[i]]+2,\\cdots)$$但是这样的时间复杂度为 $O(nmk)$，会超时 观察转移方程： 可以发现，红色部分十分相似，记右半部分为 $g[i][j]$，不难得到转移方程：$$g[i][j]&#x3D;min(f[i-1][j-x[i]]+1,g[i][j-x[i]]+1)\\f[i][j]&#x3D;min(f[i-1][j+y[i]],g[i][j])$$因此时间复杂度优化为 $O(nm)$ 可以发现转移方程类似完全背包。"},{"title":"Dancing Links X(DLX)","path":"/2024/07/25/DLX/","content":"Dancing Links X(DLX)作用：优化搜索 题型： 精确覆盖 重复覆盖（配合IDA*） 前提：1的个数较少 存储：十字链表:每个数指向上下左右第一个元素 12int l[N],r[N],u[N],d[N],s[N],row[N],col[N],idx;// 左指针，右指针，上指针，下指针，当前列1的个数，行号，列号 初始化：创建第零行(第$i$个的左指针为$i-1$，右指针为$i+1$，上下指针为自己 12345for(int i=0;i&lt;=m;i++)&#123; l[i]=i-1,r[i]=i+1,u[i]=d[i]=i;&#125;l[0]=m,r[m]=0;//特判端点idx=m+1;//一共用了m+1个点 每次加入一行 维护当前行的第一个点$hh,tt$(初始均为$idx$)，每次插入一个点时插在$hh,tt$之间，修改对应关系，修改$hh$ 123456int add(int &amp;hh,int &amp;tt,int x,int y)&#123; row[idx]=x,col[idx]=y,s[y]++; u[idx]=y,d[idx]=d[y],u[d[y]]=idx,d[y]=idx; r[hh]=idx,l[tt]=idx,l[idx]=hh,r[idx]=tt; tt=idx++;&#125; 可以发现，建立完十字链表后可以用$d$从上到下查找，用$r$从左到右查找，用$l$从右到左查找 精确覆盖问题 给定一个 $ N \\times M $ 的数字矩阵 $ A $，矩阵中的元素 $ A_{i,j} \\in \\lbrace 0,1 \\rbrace $。 请问，你能否在矩阵中找到一个行的集合，使得这些行中，每一列都有且仅有一个数字 $ 1 $。 dfs：任意从未选择的行中选择一行 剪枝： 选择1的个数最少的一列，枚举当前列有1的行 123456789if(!r[0])return true;//若所有列都被删除，则已经找完所有列int p=r[0];for(int i=r[0];i;i=r[i])&#123; if(s[i]&lt;=s[p])p=i;&#125;//do somethingfor(int i=d[p];i!=p;i=d[i])&#123; //do something&#125; 删除第$p$列 可以发现，查找列时只会在第0列查找，所以只需删除第0列中的当前行，并在每个1所在的行删除（只需删除纵向即可跳过遍历） 1234567891011121314151617181920212223242526272829void remove(int p)&#123; r[l[p]]=r[p];l[r[p]]=l[p]; for(int i=d[p];i!=p;i=d[i])&#123; for(int j=r[i];j!=i;j=r[j])&#123; s[col[j]]--; u[d[j]]=u[j];d[u[j]]=d[j]; &#125; &#125;&#125;void resume(int p)&#123;//逆方向恢复 r[l[p]]=p;l[r[p]]=p; for(int i=u[p];i!=p;i=u[i])&#123; for(int j=l[i];j!=i;j=l[j])&#123; s[col[j]]++; u[d[j]]=j;d[u[j]]=j; &#125; &#125;&#125;bool dfs()&#123;\t... remove(p); for(int i=d[p];i!=p;i=d[i])&#123; ... &#125; resume(p); ...&#125; 删除选择的行中所有有1的列 12345678910bool dfs()&#123; ... for(int i=d[p];i!=p;i=d[i])&#123; ... for(int j=r[i];j!=i;j=r[j])remove(col[j]); ... for(int j=l[i];j!=i;j=l[j])resume(col[j]);//反向恢复 &#125; ...&#125; 总代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;bits/stdc++.h&gt;using namespace std;const int N=5510;//5000+501int n,m;int l[N],r[N],u[N],d[N],s[N],row[N],col[N],idx;int ans[N],top;void init()&#123; for(int i=0;i&lt;=m;i++)&#123; l[i]=i-1,r[i]=i+1,u[i]=d[i]=i; &#125; l[0]=m,r[m]=0; idx=m+1;&#125;void add(int &amp;hh,int &amp;tt,int x,int y)&#123; row[idx]=x,col[idx]=y,s[y]++; u[idx]=y,d[idx]=d[y],l[idx]=hh,r[idx]=tt; u[d[y]]=idx,d[y]=idx,r[hh]=idx,l[tt]=idx; tt=idx++;&#125;void remove(int p)&#123; r[l[p]]=r[p],l[r[p]]=l[p]; for(int i=d[p];i!=p;i=d[i])&#123; for(int j=r[i];j!=i;j=r[j])&#123; s[col[j]]--; u[d[j]]=u[j],d[u[j]]=d[j]; &#125; &#125;&#125;void resume(int p)&#123; for(int i=u[p];i!=p;i=u[i])&#123; for(int j=l[i];j!=i;j=l[j])&#123; u[d[j]]=j,d[u[j]]=j; s[col[j]]++; &#125; &#125; r[l[p]]=p,l[r[p]]=p;&#125;bool dfs()&#123; if(!r[0])return true; int p=r[0]; for(int i=r[0];i;i=r[i])&#123; if(s[i]&lt;s[p])p=i; &#125; remove(p); for(int i=d[p];i!=p;i=d[i])&#123; ans[++top]=row[i]; for(int j=r[i];j!=i;j=r[j])remove(col[j]); if(dfs())return true; for(int j=l[i];j!=i;j=l[j])resume(col[j]); top--; &#125; resume(p); return false;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; init(); for(int i=1;i&lt;=n;i++)&#123; int hh=idx,tt=idx; for(int j=1;j&lt;=m;j++)&#123; int x; cin &gt;&gt; x; if(x)add(hh,tt,i,j); &#125; &#125; if(dfs())&#123; for(int i=1;i&lt;=top;i++)cout &lt;&lt; ans[i] &lt;&lt; &#x27; &#x27;; &#125; else&#123; cout &lt;&lt; &quot;No Solution!&quot;; &#125; return 0;&#125; 重复覆盖问题 给定一个 $ N \\times M $ 的数字矩阵 $ A $，矩阵中的元素 $ A_{i,j} \\in {0,1} $。 请你在矩阵中找到一个行的集合，使得这些行中，每一列都包含数字 $ 1 $，并且集合中包含的行数尽可能少。 dfs: 选择一个空列(选择行数最少的列) 枚举当前列是1的行 枚举选当前行 递归"},{"title":"CYaRon 文档","path":"/2024/07/25/CYaRon文档/","content":"CYaRon 文档CYaRon 是一个可以帮助你快速生成随机数据的工具库，目标是实现帮您5分钟内生成一组测试数据。 使用CYaRon CYaRon 使用 Python 编写。在安装好 Python 的计算机上，下载 CYaRon 并放置在合适的目录下或使用 Python 自带的 pip 安装工具输入命令pip install cyaron即可安装 CYaRon。 CYaRon 的工具包可以帮助你写出 Python 数据生成器。通过使用各种工具包，你可以控制输入&#x2F;输出文件，并将std程序（标程）的输出写入到输出文件中。 要了解 CYaRon 的使用，可以查看本项目的examples。 若您对 Python 不熟悉，可看快速入门教程。 要详细了解 CYaRon 的各部分，可以查看右侧侧边栏中的各文档页面。 贡献 所有的贡献者请查看光荣榜页面，衷心感谢他们对CYaRon项目的付出。 欢迎您对 CYaRon 做出贡献。若您有希望加入的功能，可以给我们提出 Issue ，或者自己动手实现，然后发起 Pull Request。 有关于如何做出贡献的更详细内容，请查看如何做出贡献。 Python 30分钟入门指南为什么 OIer 要学 Python？ CYaRon 建立在 Python 上； Python 语言特性简洁明了，使用 Python 写测试数据生成器和对拍器，无论是否使用 CYaRon，比编写 C++ 事半功倍。借助 CYaRon 更是如虎添翼； Python 学习成本很低，只要您熟练掌握 C++&#x2F;Pascal，您只要花30分钟看完本文并完成实验，即可初步掌握 Python，并使用CYaRon编写脚本； NOI Linux (Ubuntu) 自带 Python，这意味着它可以是您在考场上虐题时的最佳拍档。 为什么我们要准备一个30分钟入门指南？按理说，在一个库中加入一个从零开始学习某语言的指南是挺搞笑的事情，但是为了节省您的学习成本，我们搬运了一个入门指南。 Python2 和 Python3 有些不太兼容的地方，但是 CYaRon 尽可能两者都兼容。 本教程讲述 Python3 。 本指南部分转载自 https://learnxinyminutes.com/docs/python3/ 环境安装Windows访问 https://www.python.org/downloads/ ，下载并安装。 使用交互式界面，在开始菜单打开Python3 IDLE即可，您可以开始以下的教程代码。 您也可以新建一个filename.py的文件，写上Python脚本，然后在命令行中输入python filename.py运行。您还可以用IDLE打开这个文件，按F5运行。 您可以在命令提示符中输入pip install cyaron，安装 CYaRon 。 如果要更新 CYaRon，您可以输入pip install --upgrade cyaron。 您也可以在 GitHub 中下载或者克隆。不过这一部分就没打算展开讲了。 macOS、LinuxmacOS 以及绝大部分 Linux 发行版自带 Python，无需特别安装。 您可以在终端中输入pip install cyaron，安装 CYaRon 。 如果要更新 CYaRon，您可以输入pip --upgrade。 入门指南正文123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559# 用井字符开头的是单行注释&quot;&quot;&quot; 多行字符串用三个引号 包裹，也常被用来做多 行注释&quot;&quot;&quot;###################################################### 1. 原始数据类型和运算符##################################################### 整数3 # =&gt; 3# 算术没有什么出乎意料的1 + 1 # =&gt; 28 - 1 # =&gt; 710 * 2 # =&gt; 20# 但是除法例外，会自动转换成浮点数35 / 5 # =&gt; 7.05 / 3 # =&gt; 1.6666666666666667# 整数除法的结果都是向下取整5 // 3 # =&gt; 15.0 // 3.0 # =&gt; 1.0 # 浮点数也可以-5 // 3 # =&gt; -2-5.0 // 3.0 # =&gt; -2.0# 浮点数的运算结果也是浮点数3 * 2.0 # =&gt; 6.0# 模除7 % 3 # =&gt; 1# x的y次方2**4 # =&gt; 16# 用括号决定优先级(1 + 3) * 2 # =&gt; 8# 布尔值TrueFalse# 用not取非not True # =&gt; Falsenot False # =&gt; True# 逻辑运算符，注意and和or都是小写True and False #=&gt; FalseFalse or True #=&gt; True# 整数也可以当作布尔值0 and 2 #=&gt; 0-5 or 0 #=&gt; -50 == False #=&gt; True2 == True #=&gt; False1 == True #=&gt; True# 用==判断相等1 == 1 # =&gt; True2 == 1 # =&gt; False# 用!=判断不等1 != 1 # =&gt; False2 != 1 # =&gt; True# 比较大小1 &lt; 10 # =&gt; True1 &gt; 10 # =&gt; False2 &lt;= 2 # =&gt; True2 &gt;= 2 # =&gt; True# 大小比较可以连起来！1 &lt; 2 &lt; 3 # =&gt; True2 &lt; 3 &lt; 2 # =&gt; False# 字符串用单引双引都可以&quot;这是个字符串&quot;&#x27;这也是个字符串&#x27;# 用加号连接字符串&quot;Hello &quot; + &quot;world!&quot; # =&gt; &quot;Hello world!&quot;# 字符串可以被当作字符列表&quot;This is a string&quot;[0] # =&gt; &#x27;T&#x27;# 用.format来格式化字符串&quot;&#123;&#125; can be &#123;&#125;&quot;.format(&quot;strings&quot;, &quot;interpolated&quot;)# 可以重复参数以节省时间&quot;&#123;0&#125; be nimble, &#123;0&#125; be quick, &#123;0&#125; jump over the &#123;1&#125;&quot;.format(&quot;Jack&quot;, &quot;candle stick&quot;)#=&gt; &quot;Jack be nimble, Jack be quick, Jack jump over the candle stick&quot;# 如果不想数参数，可以用关键字&quot;&#123;name&#125; wants to eat &#123;food&#125;&quot;.format(name=&quot;Bob&quot;, food=&quot;lasagna&quot;) #=&gt; &quot;Bob wants to eat lasagna&quot;# 如果你的Python3程序也要在Python2.5以下环境运行，也可以用老式的格式化语法&quot;%s can be %s the %s way&quot; % (&quot;strings&quot;, &quot;interpolated&quot;, &quot;old&quot;)# None是一个对象None # =&gt; None# 当与None进行比较时不要用 ==，要用is。is是用来比较两个变量是否指向同一个对象。&quot;etc&quot; is None # =&gt; FalseNone is None # =&gt; True# None，0，空字符串，空列表，空字典都算是False# 所有其他值都是Truebool(0) # =&gt; Falsebool(&quot;&quot;) # =&gt; Falsebool([]) #=&gt; Falsebool(&#123;&#125;) #=&gt; False###################################################### 2. 变量和集合##################################################### print是内置的打印函数print(&quot;I&#x27;m Python. Nice to meet you!&quot;)# 在给变量赋值前不用提前声明# 传统的变量命名是小写，用下划线分隔单词some_var = 5some_var # =&gt; 5# 访问未赋值的变量会抛出异常# 参考流程控制一段来学习异常处理some_unknown_var # 抛出NameError# 用列表(list)储存序列li = []# 创建列表时也可以同时赋给元素other_li = [4, 5, 6]# 用append在列表最后追加元素li.append(1) # li现在是[1]li.append(2) # li现在是[1, 2]li.append(4) # li现在是[1, 2, 4]li.append(3) # li现在是[1, 2, 4, 3]# 用pop从列表尾部删除li.pop() # =&gt; 3 且li现在是[1, 2, 4]# 把3再放回去li.append(3) # li变回[1, 2, 4, 3]# 列表存取跟数组一样li[0] # =&gt; 1# 取出最后一个元素li[-1] # =&gt; 3# 越界存取会造成IndexErrorli[4] # 抛出IndexError# 列表有切割语法li[1:3] # =&gt; [2, 4]# 取尾li[2:] # =&gt; [4, 3]# 取头li[:3] # =&gt; [1, 2, 4]# 隔一个取一个li[::2] # =&gt;[1, 4]# 倒排列表li[::-1] # =&gt; [3, 4, 2, 1]# 可以用三个参数的任何组合来构建切割# li[始:终:步伐]# 用del删除任何一个元素del li[2] # li is now [1, 2, 3]# 列表可以相加# 注意：li和other_li的值都不变li + other_li # =&gt; [1, 2, 3, 4, 5, 6]# 用extend拼接列表li.extend(other_li) # li现在是[1, 2, 3, 4, 5, 6]# 用in测试列表是否包含值1 in li # =&gt; True# 用len取列表长度len(li) # =&gt; 6# 元组是不可改变的序列tup = (1, 2, 3)tup[0] # =&gt; 1tup[0] = 3 # 抛出TypeError# 列表允许的操作元组大都可以len(tup) # =&gt; 3tup + (4, 5, 6) # =&gt; (1, 2, 3, 4, 5, 6)tup[:2] # =&gt; (1, 2)2 in tup # =&gt; True# 可以把元组合列表解包，赋值给变量a, b, c = (1, 2, 3) # 现在a是1，b是2，c是3# 元组周围的括号是可以省略的d, e, f = 4, 5, 6# 交换两个变量的值就这么简单e, d = d, e # 现在d是5，e是4# 用字典表达映射关系empty_dict = &#123;&#125;# 初始化的字典filled_dict = &#123;&quot;one&quot;: 1, &quot;two&quot;: 2, &quot;three&quot;: 3&#125;# 用[]取值filled_dict[&quot;one&quot;] # =&gt; 1# 用keys获得所有的键。因为keys返回一个可迭代对象，所以在这里把结果包在list里。我们下面会详细介绍可迭代。# 注意：字典键的顺序是不定的，你得到的结果可能和以下不同。list(filled_dict.keys()) # =&gt; [&quot;three&quot;, &quot;two&quot;, &quot;one&quot;]# 用values获得所有的值。跟keys一样，要用list包起来，顺序也可能不同。list(filled_dict.values()) # =&gt; [3, 2, 1]# 用in测试一个字典是否包含一个键&quot;one&quot; in filled_dict # =&gt; True1 in filled_dict # =&gt; False# 访问不存在的键会导致KeyErrorfilled_dict[&quot;four&quot;] # KeyError# 用get来避免KeyErrorfilled_dict.get(&quot;one&quot;) # =&gt; 1filled_dict.get(&quot;four&quot;) # =&gt; None# 当键不存在的时候get方法可以返回默认值filled_dict.get(&quot;one&quot;, 4) # =&gt; 1filled_dict.get(&quot;four&quot;, 4) # =&gt; 4# setdefault方法只有当键不存在的时候插入新值filled_dict.setdefault(&quot;five&quot;, 5) # filled_dict[&quot;five&quot;]设为5filled_dict.setdefault(&quot;five&quot;, 6) # filled_dict[&quot;five&quot;]还是5# 字典赋值filled_dict.update(&#123;&quot;four&quot;:4&#125;) #=&gt; &#123;&quot;one&quot;: 1, &quot;two&quot;: 2, &quot;three&quot;: 3, &quot;four&quot;: 4&#125;filled_dict[&quot;four&quot;] = 4 # 另一种赋值方法# 用del删除del filled_dict[&quot;one&quot;] # 从filled_dict中把one删除# 用set表达集合empty_set = set()# 初始化一个集合，语法跟字典相似。some_set = &#123;1, 1, 2, 2, 3, 4&#125; # some_set现在是&#123;1, 2, 3, 4&#125;# 可以把集合赋值于变量filled_set = some_set# 为集合添加元素filled_set.add(5) # filled_set现在是&#123;1, 2, 3, 4, 5&#125;# &amp; 取交集other_set = &#123;3, 4, 5, 6&#125;filled_set &amp; other_set # =&gt; &#123;3, 4, 5&#125;# | 取并集filled_set | other_set # =&gt; &#123;1, 2, 3, 4, 5, 6&#125;# - 取补集&#123;1, 2, 3, 4&#125; - &#123;2, 3, 5&#125; # =&gt; &#123;1, 4&#125;# in 测试集合是否包含元素2 in filled_set # =&gt; True10 in filled_set # =&gt; False###################################################### 3. 流程控制和迭代器##################################################### 先随便定义一个变量some_var = 5# 这是个if语句。注意缩进在Python里是有意义的# 印出&quot;some_var比10小&quot;if some_var &gt; 10: print(&quot;some_var比10大&quot;)elif some_var &lt; 10: # elif句是可选的 print(&quot;some_var比10小&quot;)else: # else也是可选的 print(&quot;some_var就是10&quot;)&quot;&quot;&quot;用for循环语句遍历列表打印: dog is a mammal cat is a mammal mouse is a mammal&quot;&quot;&quot;for animal in [&quot;dog&quot;, &quot;cat&quot;, &quot;mouse&quot;]: print(&quot;&#123;&#125; is a mammal&quot;.format(animal))&quot;&quot;&quot;&quot;range(number)&quot;返回数字列表从0到给的数字打印: 0 1 2 3&quot;&quot;&quot;for i in range(4): print(i)&quot;&quot;&quot;while循环直到条件不满足打印: 0 1 2 3&quot;&quot;&quot;x = 0while x &lt; 4: print(x) x += 1 # x = x + 1 的简写# 用try/except块处理异常状况try: # 用raise抛出异常 raise IndexError(&quot;This is an index error&quot;)except IndexError as e: pass # pass是无操作，但是应该在这里处理错误except (TypeError, NameError): pass # 可以同时处理不同类的错误else: # else语句是可选的，必须在所有的except之后 print(&quot;All good!&quot;) # 只有当try运行完没有错误的时候这句才会运行# Python提供一个叫做可迭代(iterable)的基本抽象。一个可迭代对象是可以被当作序列# 的对象。比如说上面range返回的对象就是可迭代的。filled_dict = &#123;&quot;one&quot;: 1, &quot;two&quot;: 2, &quot;three&quot;: 3&#125;our_iterable = filled_dict.keys()print(our_iterable) # =&gt; range(1,10) 是一个实现可迭代接口的对象# 可迭代对象可以遍历for i in our_iterable: print(i) # 打印 one, two, three# 但是不可以随机访问our_iterable[1] # 抛出TypeError# 可迭代对象知道怎么生成迭代器our_iterator = iter(our_iterable)# 迭代器是一个可以记住遍历的位置的对象# 用__next__可以取得下一个元素our_iterator.__next__() #=&gt; &quot;one&quot;# 再一次调取__next__时会记得位置our_iterator.__next__() #=&gt; &quot;two&quot;our_iterator.__next__() #=&gt; &quot;three&quot;# 当迭代器所有元素都取出后，会抛出StopIterationour_iterator.__next__() # 抛出StopIteration# 可以用list一次取出迭代器所有的元素list(filled_dict.keys()) #=&gt; Returns [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]###################################################### 4. 函数##################################################### 用def定义新函数def add(x, y): print(&quot;x is &#123;&#125; and y is &#123;&#125;&quot;.format(x, y)) return x + y # 用return语句返回# 调用函数add(5, 6) # =&gt; 印出&quot;x is 5 and y is 6&quot;并且返回11# 也可以用关键字参数来调用函数add(y=6, x=5) # 关键字参数可以用任何顺序# 我们可以定义一个可变参数函数def varargs(*args): return argsvarargs(1, 2, 3) # =&gt; (1, 2, 3)# 我们也可以定义一个关键字可变参数函数def keyword_args(**kwargs): return kwargs# 我们来看看结果是什么：keyword_args(big=&quot;foot&quot;, loch=&quot;ness&quot;) # =&gt; &#123;&quot;big&quot;: &quot;foot&quot;, &quot;loch&quot;: &quot;ness&quot;&#125;# 这两种可变参数可以混着用def all_the_args(*args, **kwargs): print(args) print(kwargs)&quot;&quot;&quot;all_the_args(1, 2, a=3, b=4) prints: (1, 2) &#123;&quot;a&quot;: 3, &quot;b&quot;: 4&#125;&quot;&quot;&quot;# 调用可变参数函数时可以做跟上面相反的，用*展开序列，用**展开字典。args = (1, 2, 3, 4)kwargs = &#123;&quot;a&quot;: 3, &quot;b&quot;: 4&#125;all_the_args(*args) # 相当于 foo(1, 2, 3, 4)all_the_args(**kwargs) # 相当于 foo(a=3, b=4)all_the_args(*args, **kwargs) # 相当于 foo(1, 2, 3, 4, a=3, b=4)# 函数作用域x = 5def setX(num): # 局部作用域的x和全局域的x是不同的 x = num # =&gt; 43 print (x) # =&gt; 43def setGlobalX(num): global x print (x) # =&gt; 5 x = num # 现在全局域的x被赋值 print (x) # =&gt; 6setX(43)setGlobalX(6)# 函数在Python是一等公民def create_adder(x): def adder(y): return x + y return adderadd_10 = create_adder(10)add_10(3) # =&gt; 13# 也有匿名函数(lambda x: x &gt; 2)(3) # =&gt; True# 内置的高阶函数map(add_10, [1, 2, 3]) # =&gt; [11, 12, 13]filter(lambda x: x &gt; 5, [3, 4, 5, 6, 7]) # =&gt; [6, 7]# 用列表推导式可以简化映射和过滤。列表推导式的返回值是另一个列表。[add_10(i) for i in [1, 2, 3]] # =&gt; [11, 12, 13][x for x in [3, 4, 5, 6, 7] if x &gt; 5] # =&gt; [6, 7]###################################################### 5. 类##################################################### 定义一个继承object的类class Human(object): # 类属性，被所有此类的实例共用。 species = &quot;H. sapiens&quot; # 构造方法，当实例被初始化时被调用。注意名字前后的双下划线，这是表明这个属 # 性或方法对Python有特殊意义，但是允许用户自行定义。你自己取名时不应该用这 # 种格式。 def __init__(self, name): # Assign the argument to the instance&#x27;s name attribute self.name = name # 实例方法，第一个参数总是self，就是这个实例对象 def say(self, msg): return &quot;&#123;name&#125;: &#123;message&#125;&quot;.format(name=self.name, message=msg) # 类方法，被所有此类的实例共用。第一个参数是这个类对象。 @classmethod def get_species(cls): return cls.species # 静态方法。调用时没有实例或类的绑定。 @staticmethod def grunt(): return &quot;*grunt*&quot;# 构造一个实例i = Human(name=&quot;Ian&quot;)print(i.say(&quot;hi&quot;)) # 印出 &quot;Ian: hi&quot;j = Human(&quot;Joel&quot;)print(j.say(&quot;hello&quot;)) # 印出 &quot;Joel: hello&quot;# 调用一个类方法i.get_species() # =&gt; &quot;H. sapiens&quot;# 改一个共用的类属性Human.species = &quot;H. neanderthalensis&quot;i.get_species() # =&gt; &quot;H. neanderthalensis&quot;j.get_species() # =&gt; &quot;H. neanderthalensis&quot;# 调用静态方法Human.grunt() # =&gt; &quot;*grunt*&quot;###################################################### 6. 模块##################################################### 用import导入模块import mathprint(math.sqrt(16)) # =&gt; 4.0# 也可以从模块中导入个别值from math import ceil, floorprint(ceil(3.7)) # =&gt; 4.0print(floor(3.7)) # =&gt; 3.0# 可以导入一个模块中所有值# 警告：不建议这么做from math import *# 如此缩写模块名字import math as mmath.sqrt(16) == m.sqrt(16) # =&gt; True# Python模块其实就是普通的Python文件。你可以自己写，然后导入，# 模块的名字就是文件的名字。# 你可以这样列出一个模块里所有的值import mathdir(math)###################################################### 7. 高级用法##################################################### 用生成器(generators)方便地写惰性运算def double_numbers(iterable): for i in iterable: yield i + i# 生成器只有在需要时才计算下一个值。它们每一次循环只生成一个值，而不是把所有的# 值全部算好。这意味着double_numbers不会生成大于15的数字。## range的返回值也是一个生成器，不然一个1到900000000的列表会花很多时间和内存。## 如果你想用一个Python的关键字当作变量名，可以加一个下划线来区分。range_ = range(1, 900000000)# 当找到一个 &gt;=30 的结果就会停for i in double_numbers(range_): print(i) if i &gt;= 30: break 基本入门CYaRon是一个基于Python的测试数据生成库。要使用CYaRon，您首先应当安装Python。 您可以访问https://www.python.org/downloads/获得具体的安装步骤信息。 您如果不太了解Python的使用方法，可以查看快速入门教程。 在您安装完毕后，可以通过pip获取CYaRon：pip install cyaron 如果您不方便使用pip，也可直接下载压缩包，解压缩后在根目录进行脚本编写。 一个典型的数据生成器脚本如下所示： 123456789101112131415161718192021#!/usr/bin/env pythonfrom cyaron import * # 引入CYaRon的库_n = ati([0, 7, 50, 1E4]) # ati函数将数组中的每一个元素转换为整形，方便您可以使用1E4一类的数来表示数据大小_m = ati([0, 11, 100, 1E4]) # 这是一个图论题的数据生成器，该题目在洛谷的题号为P1339for i in range(1, 4): # 即在[1, 4)范围内循环，也就是从1到3 test_data = IO(file_prefix=&quot;heat&quot;, data_id=i) # 生成 heat[1|2|3].in/out 三组测试数据 n = _n[i] # 点数 m = _m[i] # 边数 s = randint(1, n) # 源点，随机选取一个 t = randint(1, n) # 汇点，随机选取一个 test_data.input_writeln(n, m, s, t) # 写入到输入文件里，自动以空格分割并换行 graph = Graph.graph(n, m, weight_limit=5) # 生成一个n点，m边的随机图，边权限制为5 test_data.input_writeln(graph) # 自动写入到输入文件里，默认以一行一组u v w的形式输出 test_data.output_gen(&quot;D:\\\\std_binary.exe&quot;) # 标程编译后的可执行文件，不需要freopen等，CYaRon自动给该程序输入并获得输出 输入输出 IOIO库可以方便的帮您建立一组测试数据。构造函数的调用方法有以下几种： 1234567IO(&quot;test1.in&quot;, &quot;test1.out&quot;) # test1.in, test1.outIO(file_prefix=&quot;test&quot;) # test.in, test.outIO(file_prefix=&quot;test&quot;, data_id=3) # test3.in, test3.outIO(file_prefix=&quot;test&quot;, data_id=6, input_suffix=&quot;.input&quot;, output_suffix=&quot;.answer&quot;) # test6.input, test6.answerIO(&quot;test2.in&quot;) # test2.in, .out文件生成为临时文件IO(file_prefix=&quot;test&quot;, data_id=5, disable_output=True) # test5.in, 不建立.outIO() # .in, .out文件均生成为临时文件，一般配合对拍器使用 以上方法可以帮您创建一组测试数据的文件。其中使用file_prefix和data_id配合for循环可以较为方便地批量生成多个数据点。 IO库的方法主要有以下几种： 12345678910io = IO(&quot;test1.in&quot;, &quot;test1.out&quot;) # 先新建一组数据io.input_write(1, 2, 3) # 写入1 2 3到输入文件io.input_writeln(4, 5, 6) # 写入4 5 6到输入文件并换行io.output_write(1, 2, 3) # 写入1 2 3到输出文件io.output_writeln(4, 5, 6) # 写入4 5 6到输出文件并换行io.input_write([1, 2, 3]) # 写入1 2 3到输入文件io.output_write(1, 2, [1, 2, 3], [4]) # 写入1 2 1 2 3 4到输出文件io.input_write(1, 2, 3, separator=&#x27;,&#x27;) # 写入1,2,3,到输入文件，目前版本尾部会多一个逗号，之后可能修改行为io.output_gen(&quot;~/Documents/std&quot;) # 执行shell命令或二进制文件，把输入文件的内容通过stdin送入，获得stdout的内容生成输出io.output_gen(&quot;C:\\\\Users\\\\Aqours\\\\std.exe&quot;) # 当然Windows也可以 图 GraphGraph库可以用来生成各种各样的树、图、链等结构。 这个库中本身已经配备了各种常用的图的模板，不过我们先来看看手动建立一个图的方法。 123456789101112131415161718graph = Graph(10) # 建立一个10个节点的无向图graph = Graph(10, directed=True) # 建立一个10个节点的有向图# 这两个图的节点编号范围都为1到10graph.add_edge(1, 5) # 建立一条从1到5，权值为1的边，若是无向图，还会建立从5到1的边graph.add_edge(1, 6, weight=3) # 建立一条从1到6，权值为3的边，若是无向图，还会建立从6到1的边graph.edges # 一个邻接表数组，每一维度i保存的是i点出发的所有边，以Edge对象存储for edge in graph.iterate_edges(): # 遍历所有边，其中edge内保存的也是Edge对象 edge.start # 获取这条边的起点 edge.end # 获取这条边的终点 edge.weight # 获取这条边的边权 io.input_writeln(edge) # 输出这条边，以u v w的形式io.input_writeln(graph) # 输出这个图，以每条边u v w一行的格式io.input_writeln(graph.to_str(shuffle=True)) # 打乱边的顺序并输出这个图io.input_writeln(graph.to_str(output=my_func)) # 使用my_func函数替代默认的输出函数，请查看源代码以理解使用方法io.input_writeln(graph.to_str(output=Edge.unweighted_edge)) # 输出无权图，以每条边u v一行的格式 不过在大多数情况下您不需要手动建图，我们为您准备了大量模板，用法如下： 1234567891011121314151617181920graph = Graph.graph(n, m) # 生成一个n点，m边的无向图，边权均为1graph = Graph.graph(n, m, directed=True, weight_limit=(5, 300)) # 生成一个n点，m边的有向图，边权范围是5到300graph = Graph.graph(n, m, weight_limit=20) # 生成一个n点，m边的无向图，边权范围是1到20graph = Graph.graph(n, m, weight_gen=my_func) # 生成一个n点，m边的无向图，使用自定义随机函数my_func的返回值作为边权graph = Graph.graph(n, m, self_loop=False, repeated_edges=False) # 生成一个n点，m边的无向图，禁止重边和自环# 以上的directed, weight_limit, weight_gen参数，对如下的所有函数都有效。chain = Graph.chain(n) # 生成一条n个节点的链，是Graph.tree(n, 1, 0)的别名flower = Graph.flower(n) # 生成一朵n个节点的菊花图，是Graph.tree(n, 0, 1)的别名tree = Graph.tree(n) # 生成一棵n个节点的随机树tree = Graph.tree(n, 0.4, 0.35) # 生成一棵n个节点的树，其中40%的节点呈现链状，35%的节点呈现菊花图状，剩余25%的节点随机加入binary_tree = Graph.binary_tree(n) # 生成一棵n个节点的随机二叉树binary_tree = Graph.binary_tree(n, 0.4, 0.35) # 生成一棵n个节点的二叉树，其中节点有40%的概率是左儿子，35%的概率是右儿子，25%的概率被随机选择graph = Graph.hack_spfa(n) # 生成一个n点，1.5*n(下取整)边的图，具有卡SPFA的特点graph = Graph.hack_spfa(n, extra_edge=m) # 生成一个n点，1.5*n+m(下取整)边的图，具有卡SPFA的特点# 下列方法生成的图保证连通# 支持 self_loop, repeated_edges, weight_limit, weight_gen 参数，但不支持 directed，DAG 的 self_loop 默认为 Falsegraph = Graph.DAG(n, m) # 生成一个 n 点，m 边的有向无环图graph = Graph.DAG(n, m, loop=True) # 生成一个 n 点，m 边的有向有环图graph = Graph.UDAG(n, m) # 生成一个 n 点，m 边的无向联通图 多边形 Polygon使用Polygon库您可以输入、生成多边形，并对其进行一些简单的操作。 12345678p = Polygon([(0,0), (0,4), (4,4), (4,0)]) # 以这四个点生成四边形，注意点需要按照连线顺序p.perimeter() # 周长p.area() # 面积io.input_writeln(p)# 您也可以使用以下的模板生成随机的多边形p = Polygon.convex_hull(n) # 生成一个N个点的凸包p = Polygon.simple_polygon(n) # 生成一个N个点的简单多边型 有关于Polygon库的更多高级用法，请参见源代码。 向量 VectorCYaRon的向量功能可以帮助您生成一个list，包括若干个向量。 在算法竞赛中，需要生成互不相同的坐标集，或者一组不重复的数列是很有用的。 用法： 1list Vector.random(num=5, position_range=[10], mode=0) 参数 num：生成的向量个数。 参数 position_range：一个list。内有几个元素那么就是输出几维向量。每个元素可以是一个二维整数（或实数）元组(min,max)表示每一维的取值是[min,max]，也可以是可以是一个整数（或实数）k，则范围是[0,k]。当该参数只有一个元素是，则生成的是一组数列而不是向量 参数 mode：模式选择。0为互相不重复的整数向量，1为允许出现重复的整数向量（各维完全独立随机），2为实数向量。 一些范例： 1234567891011121314output = Vector.random()#默认值，随机生成5个[0,10]的不重复数字的数列。output = Vector.random(10, [(10,50)])#生成10个范围在[10,50]之间的不重复数字数列。output = Vector.random(30, [(10,50), 20])#生成30个第一维范围[10,50]之间、第二维范围在[0,20]之间的不重复的二维向量。output = Vector.random(30, [(1,10), (1,10), (1,10)], 2)#生成30个每一维范围[1,10]之间的三维实数向量。output = Vector.random(30, [10], 1)#生成30个[0,10]之间的随机数，当然肯定会有重复咯。 在不使用pypy的情况下，生成一组1e5个unique的二维向量，坐标值不超过1e9，大约需要10秒钟。生成向量的算法均摊复杂度大于O(num)，小于O(num*log(num)) 默认情况下，即使是一维数列，每一项数字也是一个列表。例如 [[7], [110], [230], [415]]，如果需要展平成一个一维 list，可以使用 sum(output,[])。 字符串 StringString库可以帮您生成各种随机字符串、单词、句子、段落等。 使用方法如下： 1234567891011121314151617str = String.random(5) # 生成一个5个字母的单词，从小写字母中随机选择str = String.random((10, 20), charset=&quot;abcd1234&quot;) # 生成一个10到20个字母之间的单词，从abcd1234共8个字符中随机选择str = String.random(10, charset=&quot;#######...&quot;) # 生成一个10个字母的只有&#x27;#&#x27;和&#x27;.&#x27;组成的字符串，&#x27;#&#x27;的可能性是70%，&#x27;.&#x27;可能30%。str = String.random(None, charset=[&quot;foo&quot;, &quot;bar&quot;]) # 从foo、bar两个单词中随机选择一个返回# charset参数对于以下所有指令也有效。str = String.random_sentence(5) # 生成一个5个单词的句子，以空格分割，第一个单词首字母自动大写，结尾有句号或感叹号，每个单词3到8个字母长str = String.random_sentence((10, 20), word_separators=&quot;,;&quot;, sentence_terminators=None, first_letter_uppercase=False, word_length_range=(2, 10), charset=&quot;abcdefg&quot;) # 生成一个10到20个单词的句子，以逗号或分号随机分割，第一个单词首字母不大写，结尾没有任何符号，每个单词2到10字母长，从abcdefg共7个字符中随机选择# 以上所有参数，对于以下所有指令也有效str = String.random_paragraph((3, 10)) # 生成一个3到10个句子的段落，句子之间以句号或感叹号分割，小句之间以逗号或分号分割，句子和小句结束后均接有一个空格，句子开头首字母大写而小句开头首字母不大写。生成句子的可能性为30%而小句的可能性为70%。str = String.random_paragraph(6, sentence_joiners=&quot;|&quot;, sentence_separators=&quot;,&quot;, sentence_terminators=&quot;.?&quot;, termination_percentage=0.1) # 生成一个6个句子的段落，句子之间以句号或问号号分割，小句之间以逗号分割，句子和小句结束后均接有一个&quot;|&quot;号，句子开头首字母大写而小句开头首字母不大写。生成句子的可能性为10%而小句的可能性为90%。# 注意：如果您需要以两个空格分割单词，应该使用如下写法：str = String.random_sentence(5, word_separators=[&quot; &quot;]) # 以两个空格分割单词# 而不是：str = String.random_sentence(5, word_separators=&quot; &quot;) # 这会导致从两个空格中随机选择一个，也就是只有一个空格 序列 SequenceSequence是一个可以用来通过一个函数或者一个表达式，制造各种序列的东西。 使用方法如下面代码所示： 123Sequence(lambda i, f: 2*i+1) # f(i)=2*i+1Sequence(lambda i, f: f(i-1) + 1, [0, 1]) # f(i)=f(i-1)+1, f(0)=0, f(1)=1Sequence(lambda i, f: f(i-1) + 1, &#123;100: 101, 102: 103&#125;) # f(i)=f(i-1)+1, f(100)=101, f(102)=103 其第一个参数为一个lambda函数，该lambda函数的第一个参数i代表这是序列的第几项，而第二个参数f则是一个可以获取该数列任意一项的函数。 第二个参数则是一个数组或dict，默认为空，是该序列的初始值列表。当这个序列的表达式中需要使用到f（即，需要递归进去获取函数值）的时候，必须提供第二个参数，否则找不到初始值会陷入死循环。 我们可以对其做如下操作： 1234seq = Sequence(lambda i, f: f(i-1) + 2, [0, 2, 4])seq.get(3) # 6seq.get(4, 6) # [8, 10, 12]io.input_write(seq.get(7, 10)) # 可以直接传递给IO库，写入14 16 18 20 对拍器 Compare将对拍器与您的数据生成器结合使用，您可以方便地检测您的程序的正确性。 对拍输出文件 12345678# 默认比较器为NOIP风格，忽略最后空行和行尾空格Compare.output(&quot;1.out&quot;, &quot;2.out&quot;, std=&quot;std.out&quot;) # 以std.out为标准，对比1.out和2.out的正确性std_io = IO()std_io.output_writeln(1, 2, 3) # 往std_io的output里写入一些东西Compare.output(&quot;1.out&quot;, &quot;2.out&quot;, std=std_io) # 以std_io这个IO对象中的output为标准，对拍1.out和2.out， 对拍程序 123456789101112131415161718192021input_io = IO()input_io.input_write(&quot;1111 &quot;)Compare.program(&quot;a.exe&quot;, input=input_io, std_program=&quot;std.exe&quot;) # 以input_io这个IO对象中的input为stdin输入。# std.exe的输出为标准输出，以此为标准对拍a.exe的输出。Compare.program(&quot;a.exe&quot;, &quot;b.exe&quot;, input=input_io, std_program=&quot;std.exe&quot;) # 和上面的方法类似，但是你可以以std.exe为标准对拍多个程序输出。Compare.program(&quot;a.exe&quot;, &quot;b.exe&quot;, &quot;c.exe&quot;, input=&quot;data.in&quot;, std=&quot;std.out&quot;) # 当然input也可以简单地是文件，并以std.out这个输出文件的内容来对a.exe, b.exe, c.exe对拍。# 这里std也可以是IO对象。while True: input_io = IO() input_io.input_writeln(randint(1,100)) Compare.program(&quot;a.exe&quot;, &quot;b.exe&quot;, input=input_io, std_program=&quot;std.exe&quot;) # 不断地生成测试数据（这里是1到100的随机数），然后放到a.exe，b.exe中，分别以std.exe为标准进行对拍比较# CYaRon 现在使用多线程比较器，原 stop_on_incorrect 参数现已 deprecated 且无实际作用。# 并在工作目录下输出a.exe.out, std.out, error_input.in三个文件方便您进一步调试。 对于对拍程序的附加提示：CYaRon将每一个参数视为shell命令执行，也就是说在Linux下有必要写成./a, ./b等。 使用其他比较器 CYaRon内置NOIPStyle和FullText两种比较器，默认为NOIPStyle，更换比较器的方法如下： 1Compare.program(&quot;a.exe&quot;, input=input_io, std_program=&quot;std.exe&quot;, grader=&quot;FullText&quot;) 您也可以自己撰写比较器，请参考如下的代码示例。 1234567891011from cyaron import *from cyaron.graders import CYaRonGraders@CYaRonGraders.grader(&quot;MyGrader&quot;)def my_grader(content, std): if is_correct: # 请自行改为判断是否正确的逻辑 return True, None else: return False, &quot;Answer incorrect!&quot;Compare.program(&quot;a.exe&quot;, input=input_io, std_program=&quot;std.exe&quot;, grader=&quot;MyGrader&quot;) 工具函数CYaRon 提供了一些简单的工具函数。 ati(array) ati函数输入一个数组，将数组的每一个元素转换为整形数后返回。 因为Python的1E5此类表达式返回的是浮点值，因此使用这类表达式定义数据范围时，需要通过此函数处理数组。 1_n = ati([0, 5, 100, 1E3, 1E5]) randint(n, m) 为标准库random.randint的别名。randint接受两个参数，生成[n, m]范围内（既，包含n和m）的随机整数。 1randint(1, 5) # int in [1, 5] randrange([n,] m [,step]) 为标准库random.randrange的别名。请查看Python文档获得更多信息。 uniform(n, m) 为标准库random.uniform的别名。uniform接受两个参数，生成[n, m]范围内（既，包含n和m）的随机浮点数。 1uniform(1, 5) # float in [1, 5] choice(seq) 为标准库random.choice的别名。choice从给定的数组中随机选取一个值返回。 1choice([1, 2, 3]) random() 为标准库random.random的别名。random返回[0, 1)范围内（既，包含0但不包含1）的随机浮点数。 1random() # float in [0, 1) 常用常数CYaRon 提供了一些常用的常数。 PI 即圆周率的值。3.1415926... E 即自然底数的值。2.7182818... ALPHABET_SMALL 一个字符串，包含所有的小写字母。&quot;abcdefghijklmnopqrstuvwxyz&quot; ALPHABET_CAPITAL 一个字符串，包含所有的大写字母。&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot; 5.ALPHABET 一个字符串，包含所有的字母。&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot; 6.NUMBERS 一个字符串，包含所有的数字。&quot;0123456789&quot; 数学函数此处文档待补充，请先查看math.py中的注释。 提高运行效率Python 是一门解释执行语言，因此用 Python 和 CYaRon 编写的数据生成器会比同样功能的 C++ 等语言编写的运行缓慢。 但是我们有一些简单的的方法能够最大限度地抹平这个差异，从而使您在能够快速编写生成器的同时也能使生成器的运行效率最高。 使用 PyPy PyPy 是一个以 Python 编写的 Python 语言的 JIT 编译器。对于具有大量循环和重复操作的程序，使用 PyPy 可以让执行效率获得成倍的提升。 有关 PyPy 的安装和具体使用方法，请参见 https://pypy.org/。 在 Python2 中，使用xrange代替range 如果您使用 Python2 ，需要执行大循环时，可以使用xrange代替range函数，这可以避免一个很大的循环数组被生成。 数学相关CYaRon 只提供了一个简单的数学库。如果您需要生成更多和数学相关的内容，您可以使用 NumPy 。 请访问 http://www.numpy.org 以了解更多信息。 稍后将在此搬运一个教程以及和 CYaRon 配合使用的方式。 如何做出贡献感谢您对 CYaRon 的支持。如果您想要做出贡献，可以采用以下的方法之一。 提交 Issue 当您发现 CYaRon 中存在的 Bug 或者您认为可以加入的实用功能的时候，可以提出 Issue 。 在您提出 Issue 时，请遵守以下的原则： 请您使用中文、英语、德语或日语提出您的问题，其他语言我们可能无法理解。 Please post your Issues in Chinese, English, German or Japanese only. We may not be able to understand other languages. Posten Sie Issues nur auf Chinesisch, Englisch, Deutsch oder Japanisch. Die anderen Sprachen können wir leider nicht verstehen. 中国語、英語、ドイツ語または日本語でIssuesをお書きください。他の言語での場合においては理解できない可能性があります。 在提出问题之前，请先查看是否有其他人提出过同样的问题。 若是 Bug 反馈，请您写清问题的现象、复现方式、Python 版本，最好能够附带上您编写的代码。 若是功能请求，请您先确定 CYaRon 没有类似功能。 提交 Pull Request 您也可以直接 Fork 代码后对不足之处进行改进。改进之后您可以提交 Pull Request ，请求将改进内容合并到主仓库。 在您提出 Pull Request 时，请遵守以下的原则： 请确保您的代码规范清晰可读。 请说明清您做了什么样的改进。 您提交代码的同时，即代表您愿意将您的代码以 LGPLv3 协议并入 CYaRon 项目。 如果您的代码被合并，可选择在光荣榜留名。 光荣榜Toto Lin edited this page on May 18, 2017 · 8 revisions kkksc03 Idea, Development lin_toto GitHub lin714093880 Head Development, Doc fjzzq2002 Development, Algorithms mrj1018 Doc w GitHub wyr123 Graders shyakocat&#x2F;RandomUnit Algorithms"},{"title":"BSGS","path":"/2024/07/25/BSGS/","content":"BSGS(Baby Step Giant Step)BSGS应用：求解关于 $t$ 的同余方程 $a^t \\equiv b\\pmod p,(a,p)&#x3D;1$ 的最小正整数解 核心思想：分块 做法： 因为 $(a,p)&#x3D;1$，根据欧拉定理 $a^{\\varphi(p)} \\equiv 1 \\pmod p$ 所以 $a^t \\equiv a^{t\\text{ }\\bmod\\text{ }\\varphi(p)} \\pmod p$ 所以 $t \\in [0,\\varphi(p)-1]$ 由于 $p&gt;\\varphi(b)$，所以 $t \\in [0,p]$ 令 $k&#x3D;\\lfloor \\sqrt p \\rfloor +1$，则可以将 $0 \\sim p$ 分成 $\\sqrt p $ 段，每一段的长度为 $k$，则可以令 $t&#x3D;kx-y,x\\in[1,k],y \\in [0,k-1]$ ，这样 $t$ 取不到 $0$，特判即可。$$a^t&#x3D;a^{kx-y} \\equiv b \\pmod p\\a^{kx} \\equiv b\\cdot a^y \\pmod p$$枚举 $x$，则需要判断是否存在一个 $y$ 满足上式，可以将右侧的值存进哈希表，每次查找即可。若查到一组 $(x,y)$ 满足上式，则可以求出一个 $t$。 洛谷 P3846 [TJOI2007] 可爱的质数&#x2F;【模板】BSGS&#x2F;AcWing 3124. BSGS 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int bsgs(int a,int b,int p)&#123; if(1%p==b%p)return 0;//特判t=0 int k=sqrt(p)+1; unordered_map&lt;int,int&gt;hash;//哈希表 for(int i=0,j=b%p;i&lt;k;i++)&#123;//j=a^y hash[j]=i; j=1ll*j*a%p; &#125; //求a^k int ak=1; for(int i=1;i&lt;=k;i++)ak=1ll*ak*a%p; for(int i=1,j=ak;i&lt;=k;i++)&#123;//j=a^x if(hash.count(j)) return 1ll*i*k-hash[j]; j=1ll*j*ak%p; &#125; return -1;&#125;int main()&#123; int a,p,b; while(cin &gt;&gt; a &gt;&gt; p &gt;&gt; b,a||p||b)&#123; int res=bsgs(a,b,p); if(res==-1)cout &lt;&lt; &quot;No Solution &quot;; else cout &lt;&lt; res &lt;&lt; endl; &#125; return 0;&#125; 扩展BSGS应用：求解关于 $t$ 的同余方程 $a^t \\equiv b\\pmod p$ 的最小正整数解，$a,p$不一定互质 做法： 若 $a^0 \\equiv b \\pmod p$，则 $t&#x3D;0$ 否则，$a^t \\equiv b \\pmod p $。 设 $(a,p)&#x3D;d$，若 $d&#x3D;1$，则按照 BSGS 处理，否则：$$a^t \\equiv b \\pmod p \\Longleftrightarrow a^t+kp&#x3D;b$$若 $d ot \\mid b$ 则无解（$a,p$ 均为 $d$ 的倍数，所以 $b$ 必须是 $d$ 的倍数），否则：$$a^t+kp&#x3D;b \\Longleftrightarrow \\frac a d\\cdot a^{t-1} + k \\cdot \\frac p d &#x3D; \\frac b d \\Longleftrightarrow \\frac a d \\cdot a^{t-1} \\equiv \\frac b d \\pmod {\\frac p d} \\\\xLeftrightarrow{(\\frac a d,\\frac p d)&#x3D;1} a^{t-1} \\equiv \\frac b d \\cdot (\\frac a d)^{-1}\\pmod {\\frac p d}$$此时，记 $t’&#x3D;t-1,b’&#x3D; \\frac b d \\cdot (\\frac a d)^{-1},p’&#x3D;\\frac p d$，则原式转化为 $a^{t’} \\equiv b’ \\pmod {p’}$，回到第一步，求出一个 $t’$，则 $t’+1$ 就是答案。 洛谷 P4195 【模板】扩展 BSGS&#x2F;exBSGS&#x2F;AcWing 3125. 扩展BSGS 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int INF=0x3f3f3f3f;int bsgs(int a,int b,int p)&#123; if(1%p==b%p)return 0; int k=sqrt(p)+1; unordered_map&lt;int,int&gt;hash; for(int i=0,j=b%p;i&lt;k;i++)&#123; hash[j]=i; j=1ll*j*a%p; &#125; int ak=1; for(int i=1;i&lt;=k;i++)ak=1ll*ak*a%p; for(int i=1,j=ak;i&lt;=k;i++)&#123; if(hash.count(j)) return 1ll*i*k-hash[j]; j=1ll*j*ak%p; &#125; return -INF;&#125;int gcd(int a,int b)&#123; if(b==0)return a; return gcd(b,a%b);&#125;int exgcd(int a,int b,int &amp;x,int &amp;y)&#123; if(!b)&#123; x=1,y=0; return a; &#125; int d=exgcd(b,a%b,y,x); y-=a/b*x; return d;&#125;int exbsgs(int a,int b,int p)&#123; b=(b%p+p)%p;//把b变成正的 if(1%p==b%p)return 0; int d=gcd(a,p);// 欧几里得算法 if(d&gt;1)&#123;//若a,p不互质 if(b%d)return -INF;//返回负无穷，防止上一步+1后变成正数 int x,y; exgcd(a/d,p/d,x,y);//求a/d的逆元存在x中 return exbsgs(a,1ll*b/d*x%(p/d),p/d)+1; &#125; return bsgs(a,b,p);//a,p互质，使用bsgs&#125;int main()&#123; int a,p,b; while(scanf(&quot;%d%d%d&quot;,&amp;a,&amp;p,&amp;b),a||p||b)&#123; int res=exbsgs(a,b,p); if(res&lt;0)printf(&quot;No Solution &quot;); else printf(&quot;%d &quot;,res); &#125; return 0;&#125; 例题：洛谷 P3306 [SDOI2013] 随机数生成器&#x2F;AcWing 2526. 随机数生成器 小 $ W $ 喜欢读书，尤其喜欢读《约翰克里斯朵夫》。 最近小 $ W $ 准备读一本新书，这本书一共有 $ p $ 页，页码范围为 $ 0..p-1 $。 小 $ W $ 很忙，所以每天只能读一页书。 为了使事情有趣一些，他打算使用 NOI2012 上学习的线性同余法生成一个序列，来决定每天具体读哪一页。 我们用 $ X_i $ 来表示通过这种方法生成出来的第 $ i $ 个数，也即小 $ W $ 第 $ i $ 天会读哪一页。 这个方法需要设置 $ 3 $ 个参数 $ a,b,X_1 $，满足 $ 0 \\le a,b,X_1 \\le p-1 $，且 $ a,b,X_1 $ 都是整数。 按照下面的公式生成出来一系列的整数。 $$X_{i+1}&#x3D;(aX_i+b) \\bmod p$$ 其中 $ \\bmod p $ 表示前面的数除以 $ p $ 的余数。 可以发现，这个序列中下一个数总是由上一个数生成的，而且每一项都在 $ 0..p-1 $ 这个范围内，是一个合法的页码。 同时需要注意，这种方法有可能导致某两天读的页码完全一样。 小 $ W $ 非常急切的想去读这本书的第 $ t $ 页。 所以他想知道，对于一组给定的 $ a,b,X_1 $，如果使用线性同余法来生成每一天读的页码，最早读到第 $ t $ 页是在哪一天，或者指出他永远不会读到第 $ t $ 页。 输入格式输入含有多组数据，第一行一个正整数 $ T $，表示这个测试点内的数据组数。 接下来 $ T $ 行，每行有五个整数 $ p，a，b，X_1，t $，表示一组数据。保证 $ X_1 $ 和 $ t $ 都是合法的页码。 注意：$ P $ 一定为质数。 输出格式共 $ T $ 行，每行一个整数表示他最早读到第 $ t $ 页是哪一天。 如果他永远不会读到第 $ t $ 页，输出 $ -1 $。 数据范围$ 0 \\le a \\le p-1 $,$ 0 \\le b \\le p-1 $,$ 2 \\le p \\le 10^9 $ 输入样例：123437 1 1 3 37 2 2 2 07 2 2 2 1 输出样例：12313-1 分析： $x_n&#x3D;(ax_{n-1}+b)\\bmod p$ 若 $a&#x3D;0$，则如果 $x_1&#x3D;t$，则答案为 $1$，如果 $x_1 e t,b&#x3D;t$，则答案为 $2$ ，否则无解。 若 $a&#x3D;1$，若 $b&#x3D;0$ ，则如果 $x_1&#x3D;t$，则答案为 $1$，否则无解，否则 $x_n&#x3D;x_{n-1}+b&#x3D;x_1+(n-1)b\\equiv t \\pmod p$，也就是解同余方程 $x_1+(n-1)b\\equiv t \\pmod p$，相当于解不定方程 $(n-1)b + mp &#x3D; t -x_1 $，使用扩展欧几里得算法。 首先要求出通项公式，由于每一项都是模 $p$ 意义下的，因此可以省略 $\\bmod p$，即求 $x_n&#x3D;ax_{n-1}+b$ 的通项公式。 设 $x_n&#x3D;ax_{n-1}+b$ 等价于 $x_n+c&#x3D;a(x_{n-1}+c)$，解得 $c&#x3D;\\frac b {a-1}$ 原式等价于 $x_n+\\frac b {a-1}&#x3D;a(x_{n-1}+\\frac b {a-1})&#x3D;a^{n-1}(x_1+\\frac b {a-1})$ 所以 $a^{n-1} \\equiv \\frac {x_n+\\frac b {a-1}} {x_1+\\frac b {a-1}} \\pmod p$ 由于要求最小的 $n$ 使得 $x_n&#x3D;t$ ，因此将式子中的 $x_n$ 换为 $t$ 即可。 $a\\ge 2,b\\ge 1,1\\le a-1\\le p-2$，所以原式分数上下各部分都与 $p$ 互质，因此使用有理数取模将右侧转化为一个整数 $b’$$$a^{n-1} \\equiv \\frac {x_n+\\frac b {a-1}} {x_1+\\frac b {a-1}} \\equiv [x_n+b(a-1)^{-1}] [x_1+b(a-1)^{-1}]&#x3D;b’ \\pmod p$$ 所以原式转化为 $a^{n-1} \\equiv b’ \\pmod p$，使用 BSGS 求解即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int quick_pow(int a,int b,int p)&#123; int res=1; while(b)&#123; if(b&amp;1)res=1ll*res*a%p; a=1ll*a*a%p; b&gt;&gt;=1; &#125; return res;&#125;int inv(int a,int p)&#123;//求逆元(费马小定理) return quick_pow(a,p-2,p);&#125;int exgcd(int a,int b,int &amp;x,int &amp;y)&#123; if(!b)&#123; x=1,y=0; return a; &#125; int d=exgcd(b,a%b,y,x); y-=a/b*x; return d;&#125;int bsgs(int a,int b,int p)&#123; if(1%p==b%p)return 0; int k=sqrt(p)+1; unordered_map&lt;int,int&gt;hash; for(int i=0,j=b%p;i&lt;k;i++)&#123; hash[j]=i; j=1ll*j*a%p; &#125; int ak=1; for(int i=1;i&lt;=k;i++)ak=1ll*ak*a%p; for(int i=1,j=ak;i&lt;=k;i++)&#123; if(hash.count(j)) return 1ll*i*k-hash[j]; j=1ll*j*ak%p; &#125; return -2;&#125;int main()&#123; int T; cin &gt;&gt; T; while(T--)&#123; int p,a,b,x1,t; cin &gt;&gt; p &gt;&gt; a &gt;&gt; b &gt;&gt; x1 &gt;&gt; t; if(a==0)&#123; if(x1==t)cout &lt;&lt; 1 &lt;&lt; endl; else if(b==t)cout &lt;&lt; 2 &lt;&lt; endl; else cout &lt;&lt; -1 &lt;&lt; endl; &#125; else if(a==1)&#123; if(b==0)&#123; if(x1==t)cout &lt;&lt; 1 &lt;&lt; endl; else cout &lt;&lt; -1 &lt;&lt; endl; &#125; else&#123; int x,y; exgcd(b,p,x,y); cout &lt;&lt; (1ll*x*(t-x1)%p+p)%p+1 &lt;&lt; endl; &#125; &#125; else&#123; int C=1ll*b*inv(a-1,p)%p; int A=(x1+C)%p; if(A==0)&#123; int u=(-C+p)%p; if(u==t)cout &lt;&lt; 1 &lt;&lt; endl; else cout &lt;&lt; -1 &lt;&lt; endl; &#125; else&#123; int B=(t+C)%p; cout &lt;&lt; bsgs(a,1ll*B*inv(A,p)%p,p)+1 &lt;&lt; endl; &#125; &#125; &#125; return 0;&#125;"},{"title":"2-SAT","path":"/2024/07/25/2-SAT/","content":"2-SAT有 n 个布尔变量 $x_1 \\sim x_n$，另有 m 个需要满足的条件，每个条件的形式都是 「$x_i$ 为 true &#x2F; false 或 $x_j$ 为 true &#x2F; false」。比如 「$x_1$ 为真或 $x_3$ 为假」、「$x_7$ 为假或 $x_2$ 为假」。 2-SAT 问题的目标是给每个变量赋值使得所有条件得到满足。 建立2n个点，令$x_i$表示$x_i&#x3D;1$，$ eg x_i$表示$x_i&#x3D;0$。 通过分析可以发现：$x_1 \\or x_2 \\Leftrightarrow eg x_1 \\to x_2 \\Leftrightarrow eg x_2 \\to x_1$，而 $x_1$ $x_2$ $x_1 \\to x_2$ 0 0 1 0 1 1 1 0 0 1 1 1 对于每个条件 $x_1\\or x_2$，连接两条边$( eg x_1 , x_2),( eg x_2,x_1)$，表示若$x_1$取0，则$x_2$必然取1（$ eg x_1 \\or x_2, eg x_1 \\or eg x_2$等同理） 何时无解？ 若沿着路径走出现$x_1 \\to \\cdots \\to eg x_1$，且$ eg x_1 \\to \\cdots \\to x_1$时，即$x_1$可以走到$ eg x_1$，$ eg x_1$也可以走到$x_1$，也就是$x_1$和$ eg x_1$在一个强连通分量时，则一定无解（这表示无论$x_1$等于1还是0，都会出现矛盾）。 何时有解？ 按上述方式连边，进行Tarjan算法，若任何一个变量$x_i$和$ eg x_i$不在同一个强连通分量中，则一定有解。 如何求解？ 缩点后，求拓扑排序，枚举所有$x_i$和$ eg x_i$所在的强连通分量，取拓扑序靠后的值。 由于Tarjan算法求强连通分量的顺序是拓扑排序的逆序，因此只需取点所在强连通分量编号小的即可。正因为这样，实际求解不需要缩点。 模板题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;bits/stdc++.h&gt;using namespace std;const int N=2e6+5,M=2e6+5;int n,m;int h[N],to[N],ne[N],idx;int dfn[N],low[N],timestamp;stack&lt;int&gt;s;bool ins[N];int id[N],cnt;//用2*i表示 eg x_i，2*i+1表示x_ivoid add(int a,int b)&#123; to[idx]=b,ne[idx]=h[a],h[a]=idx++;&#125;void tarjan(int u)&#123; dfn[u]=low[u]=++timestamp; s.push(u); ins[u]=1; for(int i=h[u];~i;i=ne[i])&#123; int j=to[i]; if(!dfn[j])&#123; tarjan(j); low[u]=min(low[u],low[j]); &#125; else if(ins[j])&#123; low[u]=min(low[u],dfn[j]); &#125; &#125; if(low[u]==dfn[u])&#123; cnt++; int k; do&#123; k=s.top(); s.pop(); ins[k]=0; id[k]=cnt; &#125;while(k!=u); &#125;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0),cout.tie(0); cin &gt;&gt; n &gt;&gt; m; memset(h,-1,sizeof h); for(int k=1;k&lt;=m;k++)&#123; int i,a,j,b; cin &gt;&gt; i &gt;&gt; a &gt;&gt; j &gt;&gt; b; i--,j--; add(2*i+!a,2*j+b); add(2*j+!b,2*i+a); &#125; for(int i=0;i&lt;2*n;i++)&#123; if(!dfn[i])&#123; tarjan(i); &#125; &#125; for(int i=0;i&lt;n;i++)&#123; if(id[i*2]==id[i*2+1])&#123; cout &lt;&lt; &quot;IMPOSSIBLE &quot;; return 0; &#125; &#125; cout &lt;&lt; &quot;POSSIBLE &quot;; for(int i=0;i&lt;n;i++)&#123; if(id[i*2]&lt;id[i*2+1])&#123; cout &lt;&lt; 0 &lt;&lt; &#x27; &#x27;; &#125; else cout &lt;&lt; 1 &lt;&lt; &#x27; &#x27;; &#125; return 0;&#125;"}]